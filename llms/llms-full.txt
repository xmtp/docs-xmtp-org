# XMTP Full Documentation

Generated at 11:41 PM UTC / August 29, 2025

## Instructions for AI Tools

This documentation includes code samples for multiple SDKs. Please use the code samples that correspond to the SDK you are working with:

- For **xmtp-react-native**, use the code samples marked with `[React Native]`.
- For **xmtp-android**, use the code samples marked with `[Kotlin]`.
- For **xmtp-ios**, use the code samples marked with `[Swift]`.
- For **xmtp-js** in a browser environment, use the code samples marked with `[Browser]`.
- For **xmtp-js** in a Node.js environment, use the code samples marked with `[Node]`.

Ensure that you select the correct code block to avoid compatibility issues.

## pages/index.mdx
---
title: Build with XMTP
layout: landing
showLogo: false
---

import { CustomHomePage } from '../components/CustomHomePage'

<CustomHomePage.Root>

<CustomHomePage.Headline>

Build with <img src="/x-mark-blue-lightmode.png" alt="XMTP" className="xmtp-logo-light-mode" /><img src="/x-mark-blue-darkmode.png" alt="XMTP" className="xmtp-logo-dark-mode" /> XMTP

</CustomHomePage.Headline>

<CustomHomePage.Subhead>

The largest and most secure decentralized messaging network

</CustomHomePage.Subhead>

<div className="custom-homepage-cta-container">
  <a href="/agents/get-started/build-an-agent" className="custom-homepage-cta-button custom-homepage-cta-button--primary">Build an agent</a>
  <a href="/chat-apps/intro/get-started" className="custom-homepage-cta-button custom-homepage-cta-button--secondary">Build a chat app</a>
</div>

<CustomHomePage.TileGrid>

<CustomHomePage.Tile
  title="Quantum-resistant"
  description="Protection against 'harvest now, decrypt later' attacks through post-quantum cryptography"
/>

<CustomHomePage.Tile
  title="End-to-end encrypted"
  description="Messages encrypted client-side and only recipients can decrypt them"
/>

<CustomHomePage.Tile
  title="Decentralized"
  description="Messages are distributed across a censorship-resistant network of nodes"
/>

<CustomHomePage.Tile
  title="Flexible identities"
  description="Use any public DiD, like @ensdomains or @bluesky, or just a single device-bound passkey"
/>

<CustomHomePage.Tile
  title="Built-in consent"
  description="Chats are spam-free spaces for a user's chosen contacts only"
/>

<CustomHomePage.Tile
  title="Rich content types"
  description="Send text, attachments, reactions, read receipts, onchain transactions, and more"
/>

</CustomHomePage.TileGrid>

<CustomHomePage.SectionTitle id="start-building">

Start building today

</CustomHomePage.SectionTitle>

<CustomHomePage.SDKGrid>

<CustomHomePage.SDKTile
  href="chat-apps/sdks/browser"
  lightSrc="/ts-logo-128.svg"
  darkSrc="/ts-logo-128.svg"
  alt="TypeScript"
  name="Browser SDK"
/>

<CustomHomePage.SDKTile
  href="chat-apps/sdks/node"
  lightSrc="/nodejsStackedDark.svg"
  darkSrc="/nodejsStackedLight.svg"
  alt="Node.js"
  name="Node SDK"
/>

<CustomHomePage.SDKTile
  href="chat-apps/sdks/react-native"
  lightSrc="/rn-header_logo.svg"
  darkSrc="/rn-header_logo.svg"
  alt="React Native"
  name="React Native SDK"
/>

<CustomHomePage.SDKTile
  href="chat-apps/sdks/android"
  lightSrc="/Kotlin_Icon.svg"
  darkSrc="/Kotlin_Icon.svg"
  alt="Android/Kotlin"
  name="Android SDK"
/>

<CustomHomePage.SDKTile
  href="chat-apps/sdks/ios"
  lightSrc="/swift_logo_color.svg"
  darkSrc="/swift_logo_color.svg"
  alt="iOS/Swift"
  name="iOS SDK"
/>

</CustomHomePage.SDKGrid>

</CustomHomePage.Root>


## pages/privacy.md
# Privacy policy

`docs.xmtp.org` does not use cookies and does not collect any personal data or personally-identifiable information (PII).

The site does use Plausible analytics to track overall trends in website traffic. Plausible does not track individual visitors. All analytics data is aggregated data only and it contains no personal information.

The site uses Plausible analytics for the sole purpose of helping site contributors understand how to best deliver content that serves the needs of the XMTP community.

To learn more about the data Plausible tracks, see the [Plausible Data Policy](https://plausible.io/data-policy).

If you have any questions about this privacy policy, post to the [XMTP Community Forums](https://community.xmtp.org/).


## pages/terms.md
---
description: "We are pleased to license much of the documentation on this site under terms that explicitly encourage people to take, modify, reuse, re-purpose, and remix this content as they see fit."
---

# Terms of service

Our content licensing policies are based on those of the [Google Developer](https://developers.google.com/site-policies) website.

We are pleased to license much of the documentation on `docs.xmtp.org` under terms that explicitly encourage people to take, modify, reuse, re-purpose, and remix this content as they see fit.

You will find the following notice at the bottom of pages on `docs.xmtp.org`:

> CC BY 4.0

This means that except as otherwise noted, page content is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/) and code samples are licensed under the [MIT License](http://opensource.org/licenses/MIT).

When you see a page with this notice, you are free to use [nearly everything](#what-is-not-licensed) on the page in your own creations. For example, you could quote the text in a book, cut-and-paste sections to your blog, record it as an audiobook for the visually impaired, or even translate it into Swahili. Really. That's what open content licenses are all about. We just ask that you give us [attribution](#attribution) when you reuse our work.

If you have any questions about these terms of service, post to the [XMTP Community Forums](https://community.xmtp.org/).

## What is _not_ licensed?

We say “nearly everything” as there are a few simple conditions that apply.

Trademarks and other brand features are not included in this license.

In some cases, a page might include content consisting of images, audio or video material, or a link to content on a different webpage (such as videos or slide decks). This content is not covered by the license, unless specifically noted.

## Attribution

Proper attribution is required when you reuse or create modified versions of content that appears on a page made available under the terms of the Creative Commons Attribution license. The complete requirements for attribution can be found in section 3 of the [Creative Commons legal code](https://creativecommons.org/licenses/by/4.0/legalcode).

In practice, we ask that you provide attribution to XMTP to the best of the ability of the medium in which you are producing the work.

There are several typical ways in which this might apply:

### Exact reproductions

If your online work _exactly reproduces_ text or images from this site, in whole or in part, please include a paragraph at the bottom of your page that reads:

>Portions of this page are reproduced from work created and shared by XMTP and used according to terms described in the [Creative Commons 4.0 Attribution License](https://creativecommons.org/licenses/by/4.0/).

Also, please link back to the original source page so that readers can refer to it for more information.

### Modified versions

If your online work shows _modified_ text or images based on the content from this site, please include a paragraph at the bottom of your page that reads:

>Portions of this page are modifications based on work created and shared by XMTP and used according to terms described in the [Creative Commons 4.0 Attribution License](https://creativecommons.org/licenses/by/4.0/).

Again, please link back to the original source page so that readers can refer to it for more information. This is even more important when the content has been modified.

### Other media

If you produce non-hypertext works, such as books, audio, or video, we ask that you make a best effort to include a spoken or written attribution in the spirit of the messages above.


## pages/agents/agent-security.mdx
# Follow agent security best practices

For an agent to function—whether it's answering questions, executing commands, or providing automated responses—it must be able to read the conversation to understand what's being asked, and write messages to respond.

Like any other user, this means your agent holds the cryptographic keys required to decrypt and send messages in the conversation. As an agent developer, it's important to uphold the security of these keys and messages.

Here are some security best practices:

- **Never expose private keys**: Use environment variables.
- **Keep messages secure and private**: Do not log messages in plaintext. Do not share messages with third parties.
- **Label agents clearly**: Clearly identify your agent as an agent and don't have an agent impersonate a human.


## pages/agents/deploy-agent.mdx
# Deploy an agent

This section covers how to deploy an agent using Railway—a platform many developers prefer for quickly and easily deploying agents. While this tutorial focuses on Railway, you can use any hosting provider that supports Node.js and environment variables.

Alternative platforms include:

- Heroku
- Fly.io
- Render
- Vercel

Want to contribute a deployment guide for another platform? We welcome [pull requests](https://github.com/xmtp/docs-xmtp-org/blob/main/README.md)!

## 1. Create a Railway account

Sign up for an account at [Railway](https://railway.app/) if you don't already have one.

## 2. Start a new project

From your Railway dashboard, click **New Project** and select **Empty Project**.

![Railway New Project Screen](https://github.com/user-attachments/assets/42016550-0ab5-4c6b-a644-39d27746916f)

## 3. Import your agent's GitHub repository

Click **Deploy from GitHub repo** and select the repository that contains your agent code.

![Import GitHub Repository](https://github.com/user-attachments/assets/88305e11-0e8a-4a92-9bbf-d9fece23b42f)

## 4. Configure volume storage

Your XMTP agent will need persistent storage. Add a volume to your container:

1. Navigate to your service settings.
2. Select the **Volumes** tab.
3. Add a new volume and specify the mount path.

   ![Adding a Volume](https://github.com/user-attachments/assets/85c45d1b-ee5b-469a-9c57-6e4a71c8bb92)

Use this code in your agent to properly connect to the Railway volume:

```tsx [Node]
export const getDbPath = (env: string, suffix: string = "xmtp") => {
  //Checks if the environment is a Railway deployment
  const volumePath = process.env.RAILWAY_VOLUME_MOUNT_PATH ?? ".data/xmtp";
  // Create database directory if it doesn't exist
  if (!fs.existsSync(volumePath)) {
    fs.mkdirSync(volumePath, { recursive: true });
  }
  const dbPath = `${volumePath}/${env}-${suffix}.db3`;

  return dbPath;
};
```

Then, specify `dbPath` in your client options:

```tsx [Node]
const receiverClient = await Client.create(signer, {
    dbEncryptionKey,
    env: XMTP_ENV as XmtpEnv,
    dbPath: getDbPath(XMTP_ENV),
  });
```

## 5. Configure environment variables

1. Get the connection string for your database.

   ![Get Redis Connection String](https://github.com/user-attachments/assets/0fbebe34-e09f-4bf7-bc8b-b43cbc2b7762)

2. Add the connection string and any other required environment variables to your service.

   ![Environment Variables Editor](https://github.com/user-attachments/assets/4393b179-227e-4c7c-8313-165f191356ff)

## 6. Deploy your agent

Once all configurations are set, Railway will automatically deploy your agent. You can monitor the deployment process on the **Deployments** tab.

## 7. Share your agent (optional)

Consider registering an [ENS domain](https://ens.domains/) for your agent to make it easy to share and access.

## Example Railway deployment

For reference, here's an example Railway deployment of a [gm-bot](https://railway.com/deploy/UCyz5b) agent.


## pages/agents/debug-agents.mdx
# Debug an agent

You can debug and interact with your agent using [xmtp.chat](https://xmtp.chat), the official web chat app for developers.

Be sure to point xmtp.chat to the XMTP environment set in your agent's `.env` file.

You can use this code to get your agent's client information, which provides useful values for debugging:

```tsx [Node]
const clientsByAddress = client.accountIdentifier?.identifier;
// Get XMTP SDK version from package.json
const require = createRequire(import.meta.url);
const packageJson = require("../package.json") as {
  dependencies: Record<string, string>;
};
const xmtpSdkVersion = packageJson.dependencies["@xmtp/node-sdk"];
const bindingVersion = (
  require("../node_modules/@xmtp/node-bindings/package.json") as {
    version: string;
  }
).version;

const inboxId = client.inboxId;
const installationId = client.installationId;
const environments = client.options?.env ?? "dev";

const urls = [`http://xmtp.chat/dm/${clientsByAddress}`];

const conversations = await client.conversations.list();
const inboxState = await client.preferences.inboxState();
const keyPackageStatuses =
  await client.getKeyPackageStatusesForInstallationIds([installationId]);

let createdDate = new Date();
let expiryDate = new Date();

// Extract key package status for the specific installation
const keyPackageStatus = keyPackageStatuses[installationId];
if (keyPackageStatus.lifetime) {
  createdDate = new Date(Number(keyPackageStatus.lifetime.notBefore) * 1000);
  expiryDate = new Date(Number(keyPackageStatus.lifetime.notAfter) * 1000);
}
console.log(`
  ✓ XMTP Client:
  • InboxId: ${inboxId}
  • SDK: ${xmtpSdkVersion}
  • Bindings: ${bindingVersion}
  • Version: ${Client.version}
  • Address: ${clientsByAddress}
  • Conversations: ${conversations.length}
  • Installations: ${inboxState.installations.length}
  • InstallationId: ${installationId}
  • Key Package created: ${createdDate.toLocaleString()}
  • Key Package valid until: ${expiryDate.toLocaleString()}
  • Networks: ${environments}
  ${urls.map((url) => `• URL: ${url}`).join("\n")}`);
```


## pages/agents/get-started/intro.mdx
# What is XMTP?

XMTP (Extensible Message Transport Protocol) is the largest and most secure decentralized messaging network

XMTP is open and permissionless, empowering any developer to build end-to-end encrypted 1:1, group, and agent messaging experiences, and more.

## Why should I build with XMTP?

Build with XMTP to:

- **Deliver secure and private messaging**

    Using the [Messaging Layer Security](/protocol/security) (MLS) standard, a ratified [IETF](https://www.ietf.org/about/introduction/) standard, XMTP provides end-to-end encrypted messaging with forward secrecy and post-compromise security.

- **Provide spam-free chats**

    In any open and permissionless messaging ecosystem, spam is an inevitable reality, and XMTP is no exception. However, with XMTP user consent preferences, developers can give their users spam-free chats displaying conversations with chosen contacts only.

- **Build on native crypto rails**

    Build with XMTP to tap into the capabilities of crypto and web3. Support decentralized identities, crypto transactions, and more, directly in a messaging experience.

- **Empower users to own and control their communications**

    With apps built with XMTP, users own their conversations, data, and identity. Combined with the interoperability that comes with protocols, this means users can access their end-to-end encrypted communications using any app built with XMTP.

- **Create with confidence**

    Developers are free to create the messaging experiences their users want—on a censorship-resistant protocol architected to last forever. Because XMTP isn't a closed proprietary platform, developers can build confidently, knowing their access and functionality can't be revoked by a central authority.

## Try an app built with XMTP

One of the best ways to understand XMTP is to use an app built with XMTP.

Try [xmtp.chat](https://xmtp.chat/), an app made for devs to learn to build with XMTP—using an app built with XMTP.

## Join the XMTP community

- **XMTP builds in the open**

  - Explore the documentation on this site
  - Explore the open [XMTP GitHub org](https://github.com/xmtp), which contains code for LibXMTP, XMTP SDKs, and xmtpd, node software powering the XMTP testnet.
  - Explore the open source code for [xmtp.chat](https://github.com/xmtp/xmtp-js/tree/main/apps/xmtp.chat), an app made for devs to learn to build with XMTP—using an app built with XMTP.

- **XMTP is for everyone**

  - [Join the conversation](https://community.xmtp.org/) and become part of the movement to redefine digital communications.


## pages/agents/get-started/build-an-agent.mdx
# Tutorial: Build an agent that uses XMTP

This tutorial provides a map to building agents with the [XMTP Node SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/node-sdk). These agents can communicate with humans and other agents in chats built with XMTP.

Building with XMTP gives your agent access to:

- The [most secure](/protocol/security), [decentralized](/network/network-nodes) messaging network
- The building blocks of AI + money + secure chat
- Users on apps built with XMTP, including Coinbase Wallet, Convos, and more

## Resources to get started

### Quickstart video guide

<iframe width="560" height="315" src="https://www.youtube.com/embed/djRLnWUvwIA?si=JX25iQt57wgXnqVX" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

### Agent examples

From a simple agent that replies "GM" to one that supports onchain transactions, explore and run a dozen [xmtp-agent-examples](https://github.com/ephemeraHQ/xmtp-agent-examples) built with the [XMTP Node SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/node-sdk).

### Cursor rules

You can use these [Cursor rules](https://github.com/ephemeraHQ/xmtp-agent-examples/blob/main/.cursor/README.md) to code agents with AI following XMTP development best practices.

## Build an agent

### Listen for and send messages

These are the steps to initialize the XMTP listener and send messages.

```tsx [Node]
// import the xmtp sdk
import { Client, type XmtpEnv, type Signer } from "@xmtp/node-sdk";

// encryption key, must be consistent across runs
const encryptionKey: Uint8Array = ...;
const signer: Signer = ...;
const env: XmtpEnv = "dev";

// create the client
const client = await Client.create(signer, {
  encryptionKey,
  env,
  appVersion: 'alix-agent/2.x'
});

// sync the client to get the latest messages
await client.conversations.sync();

// listen to all messages
const stream = await client.conversations.streamAllMessages();
for await (const message of stream) {
  // ignore messages from the agent
  if (message?.senderInboxId === client.inboxId) continue;
  // get the conversation by id
  const conversation = await client.conversations.getConversationById(message.conversationId);
  // send a message from the agent
  await conversation.send("gm");
}
```

### Get the address of a user

Each user has a unique `inboxId` used to retrieve their associated addresses (identities). One `inboxId` can have multiple identities, such as EOAs and SCWs.

:::tip

An `inboxId` differs from an address. An `inboxId` is a user identifier, while an address identifies a user's wallet. Not all users have associated addresses. To learn more, see [Manage agent installations](/agents/core-messaging/agent-installations).

:::

```tsx [Node]
const inboxState = await client.preferences.inboxStateFromInboxIds([
  message.senderInboxId,
]);
const addressFromInboxId = inboxState[0].identifiers[0].identifier;
```

### Support onchain transactions and transaction references

To learn more, see the example [xmtp-transactions](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-transactions) agent, as well as the [Support onchain transactions](/agents/content-types/transactions) and [Support onchain transaction references](/agents/content-types/transaction-refs) (receipts) documentation.

### Support attachments

To learn more, see the example [xmtp-attachments](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-attachments) agent and [Support attachments](/agents/content-types/attachments) documentation.

### Support replies

To learn more, see [Support replies](/agents/content-types/replies) documentation.

### Support reactions

To learn more, see [Support reactions](/agents/content-types/reactions) documentation.

### Observe rate limits

XMTP enforces separate rate limits for read and write operations per client.

To learn more, see [Observe rate limits](/agents/core-messaging/rate-limits)

### Follow security best practices

To learn more, see [Follow agent security best practices](/agents/agent-security)

## Manage agent installations

To learn more, see [Manage agent installations](/agents/core-messaging/agent-installations).

## Debug an agent

To learn more, see [Debug an agent](/agents/debug-agents)

## Deploy an agent

To learn more, see [Deploy an agent](/agents/deploy-agent).

## Get featured

:::tip

**Want your agent or mini-app featured on TBA?**

[Complete this form](https://docs.google.com/forms/d/e/1FAIpQLSfZ7JgOt4tw36dGLL9cEmw_y09VoE5_Knk7X6EnJd1IJ3CLEg/viewform) to tell the team about your project, get feedback, and collaborate on possibly getting it featured.

:::


## pages/agents/get-started/faq.mdx
# FAQ about XMTP

Get answers to the most frequently asked questions about XMTP.

## What works with XMTP?

In the spirit of web3 composability, here are **just a few** of the building blocks that work well with XMTP. Building your app with these tools can help you deliver and distribute an app—faster and with quality.

:::tip
This list is not exhaustive and is just a starting point. A highly extensible protocol like XMTP can work with more tools than those listed in each section.
:::

### Wallet connectors

Here are some options for connecting wallets to your app built with XMTP:

- [RainbowKit](https://www.rainbowkit.com/)  
  Support for WalletConnect v2 is now standard in RainbowKit. To learn how to upgrade, see [Migrating to WalletConnect v2](https://www.rainbowkit.com/guides/walletconnect-v2).
- [Thirdweb](https://thirdweb.com/)
- [wagmi](https://wagmi.sh/)

### Message payload storage

Here are some options for storing encrypted message payload content:

- [IPFS](https://ipfs.io/)
- [ThirdwebStorage](https://portal.thirdweb.com/infrastructure/storage/how-storage-works)
- [web3.storage](https://web3.storage/)

### Wallet apps

XMTP can be used with EVM-compatible wallet apps that support ECDSA signing on the secp256k1 elliptic curve. These include common wallet apps such as:

- [Coinbase Wallet](https://www.coinbase.com/wallet)
- [MetaMask](https://metamask.io/)
- [Rainbow Wallet](https://rainbow.me/)
- Most wallets in the [WalletConnect network](https://explorer.walletconnect.com/?type=wallet)

The XMTP SDK **does not** include a wallet app abstraction, as XMTP assumes that developers have a way to obtain a wallet app connection.

### Chains

XMTP can work with signatures from any private public key pair and currently supports EOAs and SCWs on Ethereum and Ethereum side-chains and L2s.

Because all Ethereum Virtual Machine (EVM) chains share the same Ethereum wallet and address format and XMTP messages are stored off-chain, XMTP is interoperable across EVM chains, including testnets. (XMTP itself does not use EVMs.)

For example, whether a user has their wallet app connected to Ethereum or an Ethereum side-chain or L2, their private key can generate and retrieve their XMTP key pair to give them access to XMTP.

XMTP is also chain-agnostic, so multi-chain support is possible.

Here are just a few chains that work with XMTP:

- [Arbitrum](https://arbitrum.foundation/)
- [Avalanche](https://www.avax.network/)
- [Base](https://base.org/)
- [(BNB) Chain](https://www.bnbchain.org/)
- [Ethereum](https://ethereum.org/)
- [zk-EVM](https://linea.build/)
- [Optimism](https://www.optimism.io/)
- [Polygon](https://polygon.technology/)
- [Scroll](https://www.scroll.io/)

## Build with XMTP

### Which languages does the XMTP SDK support?

XMTP SDKs are [available for multiple languages](https://docs.xmtp.org/#start-building).

### Which web3 libraries does the XMTP SDK require?

The XMTP SDK currently requires you to use [ethers](https://ethers.org/) or another web3 library capable of supplying an [ethers Signer](https://docs.ethers.io/v5/api/signer/), such as [wagmi](https://wagmi.sh/).

### What is the invalid key package error?

<iframe width="560" height="315" src="https://www.youtube.com/embed/hNlby-SfPzw?si=V7LqaBxk-i4xhbNC" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

### Where can I get official XMTP brand assets?

See the [XMTP brand guidelines](https://github.com/xmtp/brand) GitHub repo.

## Network

See [Network FAQ](/network/run-a-node/#faq-about-the-xmtp-network).

## Fees

### Does XMTP have fees?

XMTP core developers and researchers are working on a specific fee model for XMTP, with the following guiding principles in mind:

- Fees will be dynamic to protect the network from Denial of Service (DoS) attacks.
- Infrastructure costs for the network must remain low even when decentralized, and comparable to the costs for an equivalent centralized messaging service.
- There must be a low "take rate": the biggest driver of cost must be infrastructure costs, with any remaining cost returned to the network.

Have questions or feedback about the fee model for XMTP? See [XIP-57: Messaging fee collection](https://community.xmtp.org/t/xip-57-messaging-fee-collection/876) in the XMTP Community Forums.

## Security

### Has XMTP undergone a security audit?

A security assessment of [LibXMTP](https://github.com/xmtp/libxmtp) and its use of Messaging Layer Security (MLS) was completed by [NCC Group](https://www.nccgroup.com/) in Dec 2024.

See [Public Report: XMTP MLS Implementation Review](https://www.nccgroup.com/us/research-blog/public-report-xmtp-mls-implementation-review/).

## Storage

### Where are XMTP messages stored?

XMTP stores messages in the XMTP network before and after retrieval. App-specific message storage policies may vary.

### What are the XMTP message retention policies?

#### For XMTP's blockchain and node databases

Currently, encrypted payloads are stored indefinitely.

In the coming year, a retention policy will be added.

This retention policy would represent a minimum retention period, not a maximum.

For example, a retention policy may look something like the following, though specifics are subject to change:

- One year for messages
- Indefinite storage for account information and personal preferences  

The team is researching a way to provide this indefinite storage and have it scale forever.

- If research shows that it's possible, we'll share a plan for how it will be achieved.
- If research shows that it isn't possible, we'll share a plan that shows how retention periods will provide a permanent solution to storage scaling.

Have questions or feedback regarding message storage and retention? Post to the [XMTP Community Forums](https://community.xmtp.org/c/development/ideas/54).

#### For the on-device database managed by the XMTP SDK

Messages are stored for as long as the user decides to keep them. However, encryption keys are regularly rotated.

### What are XMTP message storage and retrieval costs?

Messages are stored off-chain on the XMTP network, with all nodes currently hosted by Ephemera. Ephemera currently absorbs all message storage and retrieval costs.

Today, there are no message storage and retrieval-related fees incurred by developers for building with the XMTP SDK.

## Messages

### Which message formats does XMTP support?

XMTP transports a message payload as a set of bytes that can represent any format that a developer wants to support, such as plain text, JSON, or non-text binary or media content.

With XMTP, these message formats are called content types. Currently, there are two basic content types available. These content types aim to establish broad compatibility among apps built with XMTP.

The XMTP community can propose and adopt standards for other content types, either informally or through a governance process.

To learn more about content types, see [Content types](/agents/content-types/content-types).

To learn more about the XMTP improvement proposals governance process, see [What is an XIP?](https://github.com/xmtp/XIPs/blob/main/XIPs/xip-0-purpose-process.md)

### Does XMTP have a maximum message size?

Yes. Messages sent on the XMTP network are limited to just short of 1MB (1048214 bytes).

For this reason, XMTP supports [remote attachments](/agents/content-types/attachments).

### Does XMTP support message deletion and editing?

Not currently. However, Ephemera is exploring ways to support message deletion and editing.

Have ideas about message deletion and editing? Post to the [XMTP Community Forums](https://community.xmtp.org/c/development/ideas/54).

### Is XMTP more like email or chat?

XMTP enables developers to implement messaging features and UX paradigms that best fit their needs. As a result, messages sent using apps built with XMTP might resemble many typical forms of communication, such as email, direct and group messaging, broadcasts, text messaging, push notifications, and more.

## What is Ephemera?

Ephemera is a web3 software company that contributes to XMTP, an open network, protocol, and standards for secure messaging between blockchain accounts.

Ephemera employees work alongside other XMTP community members to build with and extend XMTP. Community [contributions and participation](https://community.xmtp.org/) are critical to the development and adoption of XMTP.

Ephemera focuses on serving developers. We build [SDKs](https://docs.xmtp.org/#start-building), developer tools, and example apps that help developers build great experiences with XMTP.

Ephemera [acquired Converse](https://paragraph.xyz/@ephemera/converse) in June 2024. Converse is now [Convos](https://github.com/ephemeraHQ/convos-app), open-sourced for the entire XMTP network.


## pages/agents/core-messaging/create-a-signer.mdx
# Create a EOA or SCW signer

XMTP SDKs support message signing with 2 different types of Ethereum accounts: Externally Owned Accounts (EOAs) and Smart Contract Wallets (SCWs). All SDK clients accept a signer object (or instance), which provides a method for signing messages.

## Create an Externally Owned Account signer

The EOA signer must have 3 properties: the account type, a function that returns the account identifier, and a function that signs messages.

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from "@xmtp/node-sdk";

const accountIdentifier: Identifier = {
  identifier: "0x...", // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: "EOA",
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};
```

## Create a Smart Contract Wallet signer

The SCW signer has the same 3 required properties as the EOA signer, but also requires a function that returns the chain ID of the blockchain being used and an optional function that returns the block number to verify signatures against. If a function is not provided to retrieve the block number, the latest block number will be used.

Here is a list of supported chain IDs:

- chain_rpc_1     = string
- chain_rpc_8453  = string
- chain_rpc_42161 = string
- chain_rpc_10    = string
- chain_rpc_137   = string
- chain_rpc_324   = string
- chain_rpc_59144 = string
- chain_rpc_480   = string

Need support for a different chain ID? Please post your request to the [XMTP Community Forums](https://community.xmtp.org/c/general/ideas/54).

The details of creating an SCW signer are highly dependent on the wallet provider and the library you're using to interact with it. Here are some general guidelines to consider:

- **Wallet provider integration**: Different wallet providers (Safe, Argent, Rainbow, etc.) have different methods for signing messages. See the wallet provider documentation for more details.

- **Library selection**: Choose a library that supports your wallet provider (e.g., viem, ethers.js, web3.js). Each library has its own API for interacting with wallets. See the library documentation for more details.

- **Add an Ethereum-specific prefix**: Before signing, Ethereum requires a specific prefix to be added to the message. To learn more, see [ERC-191: Signed Data Standard](https://eips.ethereum.org/EIPS/eip-191). Libraries and wallet providers might add the prefix for you, so make sure you don't add the prefix twice.

- **Hash the prefixed message with Keccak-256**: The prefixed message is hashed using the Keccak-256 algorithm, which is Ethereum's standard hashing algorithm. This step creates a fixed-length representation of the message, ensuring consistency and security. Note that some wallet providers might handle this hashing internally.

- **Sign the replay-safe hash**: The replay-safe hash is signed using the private key of the SCW. This generates a cryptographic signature that proves ownership of the wallet and ensures the integrity of the message.

- **Convert the signature to a Uint8Array**: The resulting signature is converted to a `Uint8Array` format, which is required by the XMTP SDK for compatibility and further processing.

The code snippets below are examples only and will need to be adapted based on your specific wallet provider and library.

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from "@xmtp/node-sdk";

const accountIdentifier: Identifier = {
  identifier: "0x...", // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: "SCW",
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
  getChainId: () => BigInt(8453), // Example: Base chain ID
};
```


## pages/agents/core-messaging/rate-limits.mdx
# Observe rate limits

XMTP enforces separate rate limits for read and write operations per client per rolling 5-minute window:

- **Read operations**: 20,000 requests per 5-minute window
- **Write operations**: 3,000 messages published per 5-minute window

When you reach either rate limit, your API calls will be rejected with a 429 (Too Many Requests) error.

**Read operations** include actions like:

- Fetching conversations
- Retrieving messages
- Getting inbox state
- Listing installations

**Write operations** include actions like:

- Sending chat messages
- Adding and removing wallets
- Adding and revoking installations
- Adding and removing group members
- Updating group metadata


## pages/agents/core-messaging/create-a-client.mdx
# Create an XMTP client

Create an XMTP client that can use the signing capabilities provided by the [signer](/agents/core-messaging/create-a-signer). This signer links the client to the appropriate EOA or SCW.

## Understand creating and building a client

This video provides a walkthrough of creating and building a client.

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/kdUP1ZaauNI?si=ETuEbvwbKx4bjtwc"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowFullScreen
></iframe>

### How it works

When you call `Client.create()`, the following steps happen under the hood:

1. Extracts the `signer` and retrieves the wallet address from it.
2. Checks the XMTP identity ledger to find an inbox ID associated with the signer address. The inbox ID serves as the user's identity on the XMTP network.
   1. If it doesn't find an existing inbox ID, it requests a wallet signature to register the identity and create an inbox ID.
   2. If it finds an existing inbox ID, it uses the existing inbox ID.
3. Checks if a local SQLite database exists. This database contains the identity's installation state and message data.
   1. If it doesn't find an existing local database, it creates one. On non-web platforms, it encrypts the database with the provided `dbEncryptionKey`.
   2. If it finds an existing local database:
      - **For the Node, React Native, Android, and iOS SDKs**: It checks if the provided `dbEncryptionKey` matches. If it matches, it uses the existing database. If not, it creates a new database encrypted with the provided key.
      - **For the Browser SDK**: A `dbEncryptionKey` is not used for encryption due to technical limitations in web environments. Be aware that the database is not encrypted.
4. Returns the XMTP client, ready to send and receive messages.

### Keep the database encryption key safe

The `dbEncryptionKey` client option is used by the Node, React Native, Android, and Swift SDKs only.

The encryption key is critical to the stability and continuity of an XMTP client. It encrypts the local SQLite database created when you call `Client.create()`, and must be provided every time you create or build a client.

This encryption key is not stored or persisted by the XMTP SDK, so it's your responsibility as the app developer to store it securely and consistently.

If the encryption key is lost, rotated, or passed incorrectly during a subsequent `Client.create()` or `Client.build()` call (on non-web platforms), the app will be unable to access the local database. Likewise, if you initially provided the `dbPath` option, you must always provide it with every subsequent call or the client may be unable to access the database. The client will assume that the database can't be decrypted or doesn't exist, and will fall back to creating a new installation.

Creating a new installation requires a new identity registration and signature—and most importantly, **results in loss of access to all previously stored messages**.

To ensure seamless app experiences persist the `dbEncryptionKey` securely, and make sure it's available and correctly passed on each app launch

The `dbEncryptionKey` client option is not used by the Browser SDK for due to technical limitations in web environments. In this case, be aware that the database is not encrypted.

To learn more about database operations, see the [XMTP MLS protocol spec](https://github.com/xmtp/libxmtp/blob/main/xmtp_mls/README.md).

### View an encrypted database

For debugging, it can be useful to decrypt a locally stored database. When a `dbEncryptionKey` is used, the XMTP client creates a [SQLCipher database](https://www.zetetic.net/sqlcipher/) which applies transparent 256-bit AES encryption. A `.sqlitecipher_salt` file is also generated alongside the database.

To open this database, you need to construct the password by prefixing `0x` (to indicate hexadecimal numbers), then appending the encryption key (64 hex characters, 32 bytes) and the salt (32 hex characters, 16 bytes). For example, if your encryption key is `A` and your salt is `B`, the resulting password would be `0xAB`.

The database also uses a [plaintext header size](https://www.zetetic.net/sqlcipher/sqlcipher-api/#cipher_plaintext_header_size) of 32 bytes.

If you want to inspect the database visually, you can use [DB Browser for SQLite](https://sqlitebrowser.org/), an open source tool that supports SQLite and SQLCipher. In its **Custom** encryption settings, set the **Plaintext Header Size** to **_32_**, and use the full **Password** as a **Raw key**:

![DB Browser for SQLite](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/db-browser-sqlite.png)

## Create a client

To call `Client.create()`, you must pass in a required `signer` and can also pass in any of the optional parameters covered in [Configure an XMTP client](#configure-an-xmtp-client).

```tsx [Node]
import { Client, type Signer } from "@xmtp/node-sdk";
import { getRandomValues } from "node:crypto";

// create a signer
const signer: Signer = { /* ... */ };

/**
 * The database encryption key is optional but strongly recommended for
 * secure local storage of the database.
 *
 * This value must be consistent when creating a client with an existing
 * database.
 */
const dbEncryptionKey = getRandomValues(new Uint8Array(32));

const client = await Client.create(
  signer,
  // client options
  {
    dbEncryptionKey,
  },
);
```

### Configure an XMTP client

You can configure an XMTP client with these options passed to `Client.create`:

```tsx [Node]
import type { ContentCodec } from "@xmtp/content-type-primitives";
import type { LogLevel } from "@xmtp/node-bindings";

type ClientOptions = {
  /**
   * Specify which XMTP environment to connect to. (default: `dev`)
   */
  env?: "local" | "dev" | "production";
  /**
   * Add a client app version identifier that's included with API requests.
   * Production apps are strongly encouraged to set this value.
   *
   * You can use the following format: `appVersion: 'AGENT_NAME/AGENT_VERSION'`.
   * For example, `appVersion: 'alix/2.x'`
   *
   * If you have an agent and an app, it's best to distinguish them from each other by 
   * adding `-agent` and `-app` to the names. For example:
   * - Agent: `appVersion: 'alix-agent/2.x'`
   * - App: `appVersion: 'alix-app/3.x'`
   * 
   * Setting this value provides telemetry that shows which agents are using the
   * XMTP client SDK. This information can help XMTP core developers provide you with agent
   * support, especially around communicating important SDK updates, including
   * deprecations and required upgrades.
   */
  appVersion?: string;
  /**
   * apiUrl can be used to override the `env` flag and connect to a
   * specific endpoint
   */
  apiUrl?: string;
  /**
   * Path to the local DB
   *
   * There are 3 value types that can be used to specify the database path:
   *
   * - `undefined` (or excluded from the client options)
   *    The database will be created in the current working directory and is based on
   *    the XMTP environment and client inbox ID.
   *    Example: `xmtp-dev-<inbox-id>.db3`
   *
   * - `null`
   *    No database will be created and all data will be lost once the client disconnects.
   *
   * - `string`
   *    The given path will be used to create the database.
   *    Example: `./my-db.db3`
   */
  dbPath?: string | null;
  /**
   * Encryption key for the local DB
   */
  dbEncryptionKey?: Uint8Array;
  /**
   * Allow configuring codecs for additional content types
   */
  codecs?: ContentCodec[];
  /**
   * Enable structured JSON logging
   */
  structuredLogging?: boolean;
  /**
   * Logging level
   */
  loggingLevel?: LogLevel;
};
```

### Set the `appVersion` client option

Be sure to set the `appVersion` client option for your production agent.

You can use the following format: `appVersion: 'AGENT_NAME/AGENT_VERSION'`.

For example: `appVersion: 'alix/2.x'`

If you have an agent and an app, it's best to distinguish them from each other by adding `-agent` and `-app` to the names. For example:

- Agent: `appVersion: 'alix-agent/2.x'`
- App: `appVersion: 'alix-app/3.x'`

The `appVersion` value is included with API requests to provide telemetry that shows which agents are using the XMTP client SDK. This information can help XMTP core developers provide you with agent support, especially around communicating important SDK updates, deprecations, and required upgrades.

### XMTP network environments

XMTP provides `dev` and `production` network environments. These networks are completely separate and not interchangeable.

For example, an XMTP identity on the `dev` network is completely distinct from the XMTP identity on the `production` network, as are the messages associated with these identities. In addition, XMTP identities and messages created on the `dev` network can't be accessed from or moved to the `production` network, and vice versa.

:::tip
When you create a client, it connects to the XMTP `dev` network by default. Set your client's network environment using the appropriate [client option](#configure-an-xmtp-client).
:::

The `production` network is configured to store messages indefinitely. XMTP may occasionally delete messages and identities from the `dev` network, and will provide advance notice in the [XMTP Community Forums](https://community.xmtp.org/).

You can use a `local` network environment to have a client communicate with an XMTP node you are running locally. During development, using `local` is a great option for speed and reliability. Use the [xmtp-local-node](https://github.com/xmtp/xmtp-local-node/tree/main) repo to easily run a local XMTP node.

## Log out a client

When you log a user out of your app, you can give them the option to delete their local database.

:::tip[Important]
If the user chooses to delete their local database, they will lose all of their messages and will have to create a new installation the next time they log in.
:::

```tsx [Node]
/**
 * The Node SDK client does not have a method to delete the local database.
 * Simply delete the local database file from the file system.
 */
```


## pages/agents/core-messaging/group-permissions.mdx
# Manage group permissions

Robust group chat permissions are key to providing users with a friendly and safe group chat experience.

## Understand the group permissions system

### Member statuses

Member statuses are the roles that can be assigned to each participant (inbox ID) in a group chat. These are the available member statuses:

- Member
  - Everyone in a group chat is a member. A member can be granted admin or super admin status. If a member's admin or super admin status is removed, they are still a member of the group.
- Admin
- Super admin

### Options

Use options to assign a role to a permission. These are the available options:

- All members
- Admin only
  - Includes super admins
- Super admin only

### Permissions

Permissions are the actions a group chat participant can be allowed to take. These are the available permissions:

- Grant admin status to a member
- Remove admin status from a member
- Add a member to the group
- Remove a member from the group
- Update [group metadata](/agents/core-messaging/group-metadata), such as group name, description, and image
- Update group permissions on an item-by-item basis, such as calling `updateNamePermission` or `updateAddMemberPermission` . To learn more, see [Group.kt](https://github.com/xmtp/xmtp-android/blob/main/library/src/main/java/org/xmtp/android/library/Group.kt#L251-L313) in the xmtp-android SDK repo.

The following permissions can be assigned by super admins only. This helps ensure that a “regular” admin cannot remove the super admin or otherwise destroy a group.

- Grant super admin status to a member
- Remove super admin status from a member
- Update group permissions

## How the group permissions system works

When a group is created, all groups have the same initial member "roles" set:

- There is one super admin, and it is the group creator
- There are no admins
- Each user added to the group starts out as a member

The super admin has all of the [available permissions](#permissions) and can use them to adjust the group's permissions and options.

The app's developer can provide a UI that enables group participants to make further adjustments. For example, they can give the super admin the following permission options for group members when creating the group:

- Add members
- Update group metadata

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/group-perm-toggles.png" width="300px" />
</div>

You can use member statuses, options, and permissions to create a custom policy set. The following table represents the valid policy options for each of the permissions:

| Permission | Allow all | Deny all  | Admin only | Super admin only |
| --- | --- | --- | --- | --- |
| Add member | ✅ | ✅ | ✅ | ✅ |
| Remove member | ✅ | ✅ | ✅ | ✅ |
| Add admin | ❌ | ✅ | ✅ | ✅ |
| Remove admin | ❌ | ✅ | ✅ | ✅ |
| Update group permissions | ❌ | ❌ | ❌ | ✅ |
| Update group metadata | ✅ | ✅ | ✅ | ✅ |

If you aren't opinionated and don't set any permissions and options, groups will default to using the delivered `All_Members` policy set, which applies the following permissions and options:

- Add member - All members
- Remove member - Admin only
- Add admin - Super admin only
- Remove admin - Super admin only
- Update group permissions - Super admin only
- Update group metadata - All members

To learn more about the `All_Members` and `Admin_Only` policy sets, see [group_permissions.rs](https://github.com/xmtp/libxmtp/blob/85dd6d36f46db1ed74fe98273eea6871fea2e078/xmtp_mls/src/groups/group_permissions.rs#L1192-L1226) in the LibXMTP repo.

## Manage group chat admins

### Check if inbox ID is an admin

```js [Node]
const isAdmin = group.isAdmin(inboxId);
```

### Check if inbox ID is a super admin

```js [Node]
const isSuperAdmin = group.isSuperAdmin(inboxId);
```

### List admins

```js [Node]
const admins = group.admins;
```

### List super admins

```js [Node]
const superAdmins = group.superAdmins;
```

### Add admin status to inbox ID

```js [Node]
await group.addAdmin(inboxId);
```

### Add super admin status to inbox ID

```js [Node]
await group.addSuperAdmin(inboxId);
```

### Remove admin status from inbox ID

```js [Node]
await group.removeAdmin(inboxId);
```

### Remove super admin status from inbox ID

```js [Node]
await group.removeSuperAdmin(inboxId);
```

## Manage group chat membership

### Add members by inbox ID

The maximum group chat size is 250 members.

```js [Node]
await group.addMembers([inboxId]);
```

### Remove member by inbox ID

```js [Node]
await group.removeMembers([inboxId]);
```

### Get inbox IDs for members

```js [Node]
const inboxId = await client.getInboxIdByIdentities([bo.identity, caro.identity]);
```

### Get identities for members

```js [Node]
// sync group first
await group.sync();

// get group members
const members = group.members;

// map inbox ID to account identity
const inboxIdIdentityMap = new Map(
  members.map((member) => [member.inboxId, member.accountIdentity])
);
```

### Get the inbox ID that added the current member

```js [Node]
const addedByInboxId = group.addedByInboxId;
```


## pages/agents/core-messaging/send-messages.mdx
# Send messages

Once you have the group chat or DM conversation, you can send messages in the conversation.

```tsx [Node]
// For a DM conversation
await dm.send("Hello world");

// OR for a group chat
await group.send("Hello everyone");
```


## pages/agents/core-messaging/stream.mdx
# Stream conversations and messages

## Stream new group chat and DM conversations

Listens to the network for new group chats and DMs. Whenever a new conversation starts, it triggers the provided callback function with a [`ConversationContainer` object](/agents/core-messaging/create-conversations). This allows the client to immediately respond to any new group chats or DMs initiated by other users.

```js [Node]
const stream = await client.conversations.stream({
  onValue: (conversation) => {
    // Received a conversation
    console.log("New conversation:", conversation);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});

// Or use for-await loop
for await (const conversation of stream) {
  // Received a conversation
  console.log("New conversation:", conversation);
}
```

## Stream new group chat and DM messages

This function listens to the network for new messages within all active group chats and DMs.

Whenever a new message is sent to any of these conversations, the callback is triggered with a `DecodedMessage` object. This keeps the inbox up to date by streaming in messages as they arrive.

:::warning[Important]

The stream is infinite. Therefore, any looping construct used with the stream won't terminate unless you explicitly initiate the termination. You can initiate the termination by breaking the loop or by making an external call to `return`.

:::

```js [Node]
// stream all messages from conversations
const stream = await client.conversations.streamAllMessages({
  onValue: (message) => {
    // Received a message
    console.log("New message:", message);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});
 
// stream only group messages
const groupMessageStream = await client.conversations.streamAllGroupMessages({
  onValue: (message) => {
    console.log("New group message:", message);
  }
});
 
// stream only dm messages
const dmMessageStream = await client.conversations.streamAllDmMessages({
  onValue: (message) => {
    console.log("New DM message:", message);
  }
});
 
// Or use for-await loop
for await (const message of stream) {
  // Received a message
  console.log("New message:", message);
}
```

## Handle stream failures

:::warning

Streams will automatically attempt to reconnect if they fail. By default, a stream will attempt to reconnect up to 6 times with a 10 second delay between each retry. To change these defaults, use the `retryAttempts` and `retryDelay` options. To disable this feature, set the `retryOnFail` option to `false`. During the retry process, the `onRetry` and `onRestart` callbacks can be used to monitor progress.
:::

```ts [Node]
// disable automatic reconnects
const stream = await client.conversations.streamAllMessages({
  retryOnFail: false,
  onValue: (message) => {
    console.log("New message:", message);
  }
});

// use stream options with retry configuration
const stream = await client.conversations.streamAllMessages({
  retryAttempts: 10,
  retryDelay: 20000, // 20 seconds
  onValue: (message) => {
    console.log("New message:", message);
  },
  onError: (error) => {
    console.error("Stream error:", error);
  },
  onFail: () => {
    console.log("Stream failed after retries");
  },
  onRestart: () => {
    console.log("Stream restarted");
  },
  onRetry: (attempt, maxAttempts) => {
    console.log(`Stream retry attempt ${attempt} of ${maxAttempts}`);
  },
});
```


## pages/agents/core-messaging/agent-installations.mdx
# Manage agent installations

With XMTP, your agent has an inbox that you use to access its messages. An inbox can have multiple identities associated with it. Your agent's identity has a kind (such as EOA or SCW) and a string, which in the case of an EOA or SCW, is an Ethereum address. All messages associated with your agent's identity flow through the one inbox ID.

When you deploy your agent to a platform, you create an XMTP client for your agent. The client creates an inbox ID and installation ID associated with your agent's identity. Each time you deploy your agent to a new platform, it creates a new installation for the same inbox ID. The installation represents your agent running on that specific platform.

For example, consider deploying your agent to these platforms:

- Local development: Creates an installation
- Railway: Creates another installation
- Production server: Creates another installation

Your agent can have **up to 10 active installations** before you need to revoke one to add another. Installations only accumulate for agent deployments using the same XMTP network environment, such as `local`, `dev`, or `production`.

For example, if you deploy your agent across these network environments, you will have 3 inboxes, each with 1 installation:

- Local development: `local` network
- Railway: `dev` network  
- Production server: `production` network

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/agent-install-sep.png" width="500px" />
</div>

If you deploy your agent to this same network environment, you have 1 inbox with 3 installations:

- Local development: `production` network
- Railway: `production` network
- Production server: `production` network

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/agent-install.png" width="500px" />
</div>

Here are some best practices for agent installation management:

- Configure your deployments to preserve the agent's database
- Consider how many platforms you'll need before hitting the 10 installation limit
- Keep track of which installation corresponds to which platform
- Regularly [check how many installations your agent has](/agents/debug-agents)
- [Revoke installations](#revoke-agent-installations) from platforms you no longer use

## Common agent installation scenarios

### Deploy to a new platform

When you deploy your agent to a new platform (e.g., from Railway to Fly.io):

- Your agent creates a new installation for the new platform
- If you already have 10 installations, you'll need to [revoke one first](#revoke-agent-installations)
- The new installation will start fresh without conversation history

### Update an existing deployment

When you redeploy your agent to the same platform:

- If the platform preserves the database, the same installation continues working
- If the platform doesn't preserve the database, a new installation is created

## Revoke agent installations

:::warning[Important]

Revoking an installation is permanent. You cannot recover access to a revoked installation.

:::

When you revoke an agent installation, it can no longer send or receive messages. However, you can still access the local database.

Your agent can still run from any active installations on other deployment platforms.

To revoke an agent installation, use [revokeInstallations.ts](https://github.com/ephemeraHQ/xmtp-agent-examples/blob/eb1dc17e99570b77de906ba0d58094586a4af844/scripts/revokeInstallations.ts) in the xmtp-agent-examples repo. For example:

```bash

yarn revoke <inbox-id> <installations-to-exclude>

```


## pages/agents/core-messaging/group-metadata.mdx
# Manage group chat metadata

Group chats can have metadata, like names, descriptions, and images. Metadata can help users more easily identify their group chats. You can set group chat metadata when [creating a group chat](/agents/core-messaging/create-conversations), and get and update metadata using these methods.

## Updatable group chat metadata

The following group chat metadata can be updated:

- `group_name`: The name of the group chat
- `description`: A description of the group chat
- `image_url`: A URL pointing to an image for the group chat

## Get a group chat name

```js [Node]
const groupName = group.name;
```

## Update a group chat name

```js [Node]
await group.updateName("New Group Name");
```

## Get a group chat description

```js [Node]
const groupDescription = group.description;
```

## Update a group chat description

```js [Node]
await group.updateDescription("New Group Description");
```

## Get a group chat image URL

```js [Node]
const groupImageUrl = group.imageUrl;
```

## Update a group chat image URL

```js [Node]
await group.updateImageUrl("newurl.com");
```


## pages/agents/core-messaging/create-conversations.mdx
# Create conversations

## Check if an identity is reachable

The first step to creating a conversation is to verify that participants' identities are reachable on XMTP. The `canMessage` method checks each identity's compatibility, returning a response indicating whether each identity can receive messages.

Once you have the verified identities, you can create a new conversation, whether it's a group chat or direct message (DM).

```js [Node]
import { Client, IdentifierKind, type Identifier } from "@xmtp/node-sdk";

const identifiers: Identifier[] = [
  { identifier: "0xboAddress", identifierKind: IdentifierKind.Ethereum },
  { identifier: "0xcaroAddress", identifierKind: IdentifierKind.Ethereum }
];

// response is a Map of string (identifier) => boolean (is reachable)
const response = await Client.canMessage(identifiers);
```

## Create a new group chat

Once you have the verified identities, create a new group chat. The maximum group chat size is 250 members.

```js [Node]
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);
```

## Create a new DM

Once you have the verified identity, get its inbox ID and create a new DM:

```js [Node]
const group = await client.conversations.newDm(bo.inboxId);
```

## Conversation helper methods

Use these helper methods to quickly locate and access specific conversations—whether by conversation ID, topic, group ID, or DM identity—returning the appropriate ConversationContainer, group, or DM object.

```js [Node]
// get a conversation by its ID
const conversationById = await client.conversations.getConversationById(
  conversationId
);

// get a message by its ID
const messageById = await client.conversations.getMessageById(messageId);

// get a 1:1 conversation by a peer's inbox ID
const dmByInboxId = await client.conversations.getDmByInboxId(peerInboxId);
```


## pages/agents/content-types/reactions.mdx
# Support reactions with your agent built with XMTP

Use the reaction content type to support reactions with your agent. A reaction is a quick and often emoji-based way to respond to a message. Reactions are usually limited to a predefined set of emojis or symbols provided by the chat app.

## Use a local database for performance

Use a local database to store reactions. This enables your app to performantly display a reaction with its [referenced message](#send-a-reaction) when rendering message lists.

### Install the package

In some SDKs, the `ReactionCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-reaction
```

```bash [yarn]
yarn add @xmtp/content-type-reaction
```

```bash [pnpm]
pnpm add @xmtp/content-type-reaction
```

:::

## Configure the content type

After importing the package, you can register the codec.

```jsx [Node]
import {
  ReactionCodec,
} from "@xmtp/content-type-reaction";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new ReactionCodec()],
});
```

## Send a reaction

With XMTP, reactions are represented as objects with the following keys:

- `reference`: ID of the message being reacted to

- `action`: Action of the reaction (added or removed)

- `content`: String representation of the reaction (smile, for example) to be interpreted by clients

- `schema`: Schema of the reaction (Unicode, shortcode, or custom)

```tsx [Node]
const reaction = {
  reference: someMessageID,
  action: "added",
  content: "smile",
};

await conversation.send(reaction, {
  contentType: ContentTypeReaction,
});
```

## Receive a reaction

Now that you can send a reaction, you need a way to receive a reaction. For example:

```tsx [Node]
if (message.contentType.sameAs(ContentTypeReaction)) {
  // We've got a reaction.
  const reaction: Reaction = message.content;
}
```

To learn more, see the [Thinking reaction example](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-thinking-reaction) in the xmtp-agents-examples repo.

## Notifications and reactions

Reactions have `shouldPush` set to `false`, which means that reactions do not trigger push notifications as long as the notification server respects this flag.


## pages/agents/content-types/transactions.mdx
# Support onchain transactions with your agent built with XMTP

This package provides an XMTP content type to support sending transactions to a wallet for execution.

For an example of an agent that implements the transaction content type, see the [Transaction example](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-transactions) in the xmtp-agent-examples repo.

:::tip[Open for feedback]

You are welcome to provide feedback on this implementation by commenting on [XIP-59: Trigger on-chain calls via wallet_sendCalls](https://community.xmtp.org/t/xip-59-trigger-on-chain-calls-via-wallet-sendcalls/889).

:::

## Install the package

:::code-group

```bash [npm]
npm i @xmtp/content-type-wallet-send-calls
```

```bash [yarn]
yarn add @xmtp/content-type-wallet-send-calls
```

```bash [pnpm]
pnpm i @xmtp/content-type-wallet-send-calls
```

:::

## Configure the content type

After importing the package, you can register the codec.

```js [Node]
import {
  WalletSendCallsCodec,
} from "@xmtp/content-type-wallet-send-calls";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new WalletSendCallsCodec()],
});
```

## Create a transaction request

With XMTP, a transaction request is represented using `wallet_sendCalls` with additional metadata for display.

```ts [Node]
const walletSendCalls: WalletSendCallsParams = {
  version: "1.0",
  from: "0x123...abc",
  chainId: "0x2105",
  calls: [
    {
      to: "0x456...def",
      value: "0x5AF3107A4000",
      metadata: {
        description: "Send 0.0001 ETH on base to 0x456...def",
        transactionType: "transfer",
        currency: "ETH",
        amount: 100000000000000,
        decimals: 18,
        toAddress: "0x456...def",
      },
    },
    {
      to: "0x789...cba",
      data: "0xdead...beef",
      metadata: {
        description: "Lend 10 USDC on base with Morpho @ 8.5% APY",
        transactionType: "lend",
        currency: "USDC",
        amount: 10000000,
        decimals: 6,
        platform: "morpho",
        apy: "8.5",
      },
    },
  ],
};
```

## Send a transaction request

Once you have a transaction reference, you can send it as part of your conversation:

```ts [Node]
await conversation.messages.send(walletSendCalls, {
  contentType: ContentTypeWalletSendCalls,
});
```

## Receive a transaction request

To receive and process a transaction request:

```ts [Node]
// Assume `loadLastMessage` is a thing you have
const message: DecodedMessage = await loadLastMessage();

if (!message.contentType.sameAs(ContentTypeWalletSendCalls)) {
  // Handle non-transaction request message
  return;
}

const walletSendCalls: WalletSendCallsParams = message.content;
// Process the transaction request here
```


## pages/agents/content-types/transaction-refs.mdx
# Support onchain transaction references with your agent built with XMTP

This package provides an XMTP content type to support onchain transaction references. It is a reference to an onchain transaction sent as a message. This content type facilitates sharing transaction hashes or IDs, thereby providing a direct link to onchain activities. Transaction references serve to display transaction details, facilitating the sharing of onchain activities, such as token transfers, between users.

For an example of an agent that implements the transaction reference content type, see the [Transaction example](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-transactions) in the xmtp-agent-examples repo.

:::tip[Open for feedback]

You're welcome to provide feedback by commenting on [XIP-21: Onchain transaction reference content type](https://community.xmtp.org/t/xip-21-on-chain-transaction-reference-content-type/532).

:::

## Install the package

:::code-group

```bash [npm]
npm i @xmtp/content-type-transaction-reference
```

```bash [yarn]
yarn add @xmtp/content-type-transaction-reference
```

```bash [pnpm]
pnpm add @xmtp/content-type-transaction-reference
```

:::

## Configure the content type

After importing the package, you can register the codec.

```js [Node]
import {
  ContentTypeTransactionReference,
  TransactionReferenceCodec,
} from "@xmtp/content-type-transaction-reference";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new TransactionReferenceCodec()],
});
```

## Send a transaction reference

With XMTP, a transaction reference is represented as an object with the following keys:

```ts [Node]
const transactionReference: TransactionReference = {
  /**
   * Optional namespace for the networkId
   */
  namespace: "eip155",
  /**
   * The networkId for the transaction, in decimal or hexadecimal format
   */
  networkId: 1;
  /**
   * The transaction hash
   */
  reference: "0x123...abc";
  /**
   * Optional metadata object
   */
  metadata: {
    transactionType: "transfer",
    currency: "USDC",
    amount: 100000, // In integer format, this represents 1 USDC (100000/10^6)
    decimals: 6, // Specifies that the currency uses 6 decimal places
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  };
};
```

Once you have a transaction reference, you can send it as part of your conversation:

```js [Node]
await conversation.messages.send(transactionReference, {
  contentType: ContentTypeTransactionReference,
});
```

## Receive a transaction reference

To receive and process a transaction reference, you can use the following code samples.

```ts [Node]
// Assume `loadLastMessage` is a thing you have
const message: DecodedMessage = await loadLastMessage();

if (!message.contentType.sameAs(ContentTypeTransactionReference)) {
  // Handle non-transaction reference message
  return;
}

const transactionRef: TransactionReference = message.content;
// Process the transaction reference here
```

## Display the transaction reference

Displaying a transaction reference typically involves rendering details such as the transaction hash, network ID, and any relevant metadata. Because the exact UI representation can vary based on an app's design, you might want to fetch onchain data before showing it to the user.


## pages/agents/content-types/attachments.mdx
# Support attachments with your agent built with XMTP

Use the remote attachment content type (`RemoteAttachmentCodec`) and a storage provider to send one remote attachment of any size.

## Install the package

In some SDKs, the `AttachmentCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-remote-attachment
```

```bash [yarn]
yarn add @xmtp/content-type-remote-attachment
```

```bash [pnpm]
pnpm add @xmtp/content-type-remote-attachment
```

:::

## Configure the content type

After importing the package, you can register the codec.

```jsx [Node]
import {
  AttachmentCodec,
  RemoteAttachmentCodec,
} from "@xmtp/content-type-remote-attachment";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],
});
```

## Send a remote attachment

Load the file. This example uses a web browser to load the file:

```jsx [Node]
//image is the uploaded event.target.files[0];
const data = await new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    if (reader.result instanceof ArrayBuffer) {
      resolve(reader.result);
    } else {
      reject(new Error("Not an ArrayBuffer"));
    }
  };
  reader.readAsArrayBuffer(image);
});
```

Create an attachment object:

```tsx [Node]
// Local file details
const attachment = {
  filename: image?.name,
  mimeType: image?.type,
  data: new Uint8Array(data),
};
```

Use `RemoteAttachmentCodec.encodeEncrypted` to encrypt an attachment:

```tsx [Node]
const encryptedEncoded = await RemoteAttachmentCodec.encodeEncrypted(
  attachment,
  new AttachmentCodec()
);
```

Upload an encrypted attachment to a location where it will be accessible via an HTTPS GET request. This location will depend on which storage provider you use based on your needs.

Now that you have a `url`, you can create a `RemoteAttachment`:

```jsx [Node]
const remoteAttachment = {
  url: url,
  contentDigest: encryptedEncoded.digest,
  salt: encryptedEncoded.salt,
  nonce: encryptedEncoded.nonce,
  secret: encryptedEncoded.secret,
  scheme: "https://",
  filename: attachment.filename,
  contentLength: attachment.data.byteLength,
};
```

Now that you have a remote attachment, you can send it:

```jsx [Node]
await conversation.send(remoteAttachment, {
  contentType: ContentTypeRemoteAttachment,
});
```

## Receive, decode, and decrypt a remote attachment

Now that you can send a remote attachment, you need a way to receive it. For example:

```tsx [Node]
import { ContentTypeRemoteAttachment } from "@xmtp/content-type-remote-attachment";

if (message.contentType.sameAs(RemoteAttachmentContentType)) {
  const attachment = await RemoteAttachmentCodec.load(message.content, client);
}
```

You now have the original attachment:

```bash [Bash]
attachment.filename // => "screenshot.png"
attachment.mimeType // => "image/png",
attachment.data // => [the PNG data]
```

Once you've created the attachment object, you can create a preview to show in the message input field before sending:

```tsx [Node]
const objectURL = URL.createObjectURL(
  new Blob([Buffer.from(attachment.data)], {
    type: attachment.mimeType,
  })
);

const img = document.createElement("img");
img.src = objectURL;
img.title = attachment.filename;
```


## pages/agents/content-types/content-types.mdx
# Understand content types with XMTP

When you build an agent with XMTP, all messages are encoded with a content type to ensure that an XMTP client knows how to encode and decode messages, ensuring interoperability and consistent display of messages across apps.

In addition, message payloads are transported as a set of bytes. This means that payloads can carry any content type that a client supports, such as plain text, JSON, or even non-text binary or media content.

At a high level, there are three categories of content types with XMTP:

- Standard
- Standards-track
- Custom

## Standard content types

A standard content type is one that has undergone the XMTP Request for Comment (XRC) process and has been adopted as an [XMTP Improvement Proposal](https://github.com/xmtp/XIPs#readme) (XIP).

Once adopted, a standard content type is bundled in XMTP client SDKs. A developer can then import the standard content type from an SDK for use in their agent or app.

Here is the current standard content type:

### Text content type

An agent built with XMTP uses the `TextCodec` (plain text) standard content type by default. This means that if your agent is sending plain text messages only, you don't need to perform any additional steps related to content types.

```jsx [Node]
await conversation.send("gm");
```

## Standards-track content types

A standards-track content type is one that's being actively reviewed for adoption as a standard content type through the XIP process.

Here are standards-track content types that you can review, test, and adopt in your agent today:

- [Remote attachment content type](/agents/content-types/attachments): Use to send attachments of any size.
- [Reaction content type](/agents/content-types/reactions): Use a reaction to send a quick and often emoji-based way to respond to a message.
- [Reply content type](/agents/content-types/replies): Use a reply to send a direct response to a specific message in a conversation. Users can select and reply to a particular message instead of sending a new one.
- [Onchain transaction reference content type](/agents/content-types/transaction-refs): Use to send references to onchain transactions, such as crypto payments.
- [Onchain transaction content type](/agents/content-types/transactions): Use to support sending transactions to a wallet for execution.


## pages/agents/content-types/replies.mdx
# Support replies with your agent built with XMTP

Use the reply content type to support quote replies with your agent. A reply is a method to directly respond to a specific message in a conversation. Users can select and reply to a particular message instead of sending a new one.

## Use a local database for performance

Use a local database to store replies. This will enable your app to performantly display a reply with its [referenced message](#send-a-reply) when rendering message lists.

### Install the package

In some SDKs, the `ReplyCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-reply
```

```bash [yarn]
yarn add @xmtp/content-type-reply
```

```bash [pnpm]
pnpm add @xmtp/content-type-reply
```

:::

## Configure the content type

After importing the package, you can register the codec.

```js [Node]
import { ReplyCodec } from "@xmtp/content-type-reply";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new ReplyCodec()],
});
```

## Send a reply

Once you've created a reply, you can send it. Replies are represented as objects with two keys:

- `reference`: ID of the message being replied to

- `content`: String representation of the reply

```ts [Node]
import { ContentTypeText } from "@xmtp/content-type-text";
import { ContentTypeReply } from "@xmtp/content-type-reply";
import type { Reply } from "@xmtp/content-type-reply";

const reply: Reply = {
  reference: someMessageID,
  contentType: ContentTypeText,
  content: "I concur",
};

await conversation.send(reply, {
  contentType: ContentTypeReply,
});
```

## Receive the content type

```ts [Node]
if (message.contentType.sameAs(ContentTypeReply)) {
  // We've got a reply.
  const reply: Reply = message.content;
}
```


## pages/protocol/envelope-types.mdx
# Envelope types with XMTP

This document covers **envelope types** that clients can publish to XMTP APIs. These are the top-level message structures that can be sent and received through the XMTP network. This information is primarily useful for:

- Developers contributing to the XMTP protocol itself
- Understanding XMTP internals and debugging
- Reading XMTP Improvement Proposals (XIPs)

The envelope types described here are handled automatically by XMTP SDKs and rarely need direct interaction from app developers.

For **app development**, you'll typically work with [content types](/chat-apps/content-types/content-types) instead. Content types define how your app's messages are structured and encoded (text, attachments, reactions, etc.) and are what you'll use in your day-to-day development.

## Overview

XMTP supports several envelope types that clients can publish to the network:

- **Group message envelopes**: Contain MLS protocol messages (application messages and commits)
- **Welcome message envelopes**: Bootstrap new members into existing groups
- **Key package envelopes**: Register cryptographic credentials for user installations
- **Identity update envelopes**: Verify and authenticate user identities

These envelope types work together to enable secure group communication with [forward secrecy and post-compromise security](/protocol/security).

**Note**: In the MLS context, "group" refers to any collection of clients that share cryptographic state, which includes both direct message (1:1) or group chat conversations.

## Group message envelope

A group message envelope contains an MLS protocol message that can be either an application message or a commit message. This is the primary envelope type used for day-to-day communication.

### Application messages

Application messages represent the actual content that users send to each other, including:

- Text messages
- Attachments
- Reactions
- Read receipts
- On-chain transaction references
- Custom content types

Application messages are:

- Encrypted using the group's shared secrets
- Authenticated with sender signatures
- Encoded using XMTP content types
- Sent on the `groupMessage` topic

### Commit messages

Commit messages update the group's cryptographic state, membership, and permissions. While technically a single message type, commit messages serve many different purposes.

Understanding commit messages is especially helpful when debugging and understanding your app's user experience. For example:

- Different commit types help explain why certain messages appear in logs
- Some commits happen invisibly, while others are tied to user actions

#### User-initiated commits

- **Add member commits**: When a user explicitly adds someone to a group
- **Remove member commits**: When a user removes someone from a group  
- **Update metadata commits**: When a user changes group name, description, or permissions
- **Update permissions commits**: When a user modifies group permission settings

#### System-initiated commits

- **Key update commits**: Automatically generated when a new member joins before sending their first message
- **Missing member commits**: Triggered when the system detects someone is missing from the group
- **Scheduled commits**: Periodic commits for security maintenance

#### MLS protocol commits

- **Update path commits**: Generated by the MLS protocol for key rotation and security
- **External sender commits**: For handling external participants

For more information about MLS commits, see [RFC 9420 Section 12.4](https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4).

## Welcome message envelope

A welcome message envelope bootstraps a new member into an existing group. The welcome is dependent on the newcomer's [key package](#key-package-envelope) and provides the new member with the current state of the group after application of a [commit message](#commit-messages).

A welcome message contains:

- Group context information
- Encrypted group secrets
- Tree structure for the group
- Confirmation tags for epoch verification

If decryption fails due to an outdated or missing key package, the SDK automatically fetches the latest package and retries.

## Key package envelope

A key package envelope registers cryptographic credentials for a user installation. XMTP SDKs create and upload fresh key packages behind the scenes when an installation is initialized or rotated.

Think of a key package as a calling card for an installation that says: here's how to encrypt to me, here's how long this card is valid, and it's signed so you can trust it.

A key package contains:

- Public key for encrypting welcome messages
- Signature key for authentication
- Capabilities (supported protocol version, cipher suites, lifetime, etc.)
- Credential for identity verification
- Content of the leaf node representing this client

Group members cache key packages to authenticate future handshakes and welcome material, enabling asynchronous addition of clients to groups.

When an app inspects a group member, the SDK provides a `PublicIdentity` object containing the decoded fields, allowing apps to display identity information or check if the key package has expired.

## Identity update envelope

An identity update envelope verifies and authenticates a user identity across the network. It is signed by the user's identity and verifiable by peers.

Identity update envelopes enable group members to rotate their signature or HPKE keys while preserving group continuity and authenticity.

They handle:

- Linking an installation to an XMTP inbox
- Key rotation and revocation
- Linking multiple devices (though [history sync](/chat-apps/list-stream-sync/history-sync) is used to synchronize data between those devices)

Identity update messages are stored permanently to ensure continuity of trust and identity verification.


## pages/protocol/signatures.mdx
---
description: "Learn about wallet signature types when using XMTP"
---

# Wallet signatures with XMTP

Learn about the types of wallet address signatures you might be prompted to provide when using apps built with XMTP. These signatures are always made with a specific wallet address controlled by your wallet.

## First-time app installation use

The first time you use an installation of an app built with XMTP, a **Sign this message?** window displays to request that you sign an **XMTP : Authenticate to inbox** message. For example:

```text
XMTP : Authenticate to inbox

Inbox ID: ${INBOX_ID}
Current time: ${YYYY-MM-DD HH:MM:SS UTC}
```

More specifically, the message will request that you sign:

- A **Grant messaging access to app** message to grant the app installation access to messaging owned by your signing wallet address. For example:

  ```text
  - Grant messaging access to app
    (ID: ${hex(INSTALLATION_PUBLIC_KEY)})
  ```

- A **Create inbox** message to create an XMTP inbox owned by your signing address, but only if you have never used an app installation built with XMTP v3 before. For example:

  ```text
  - Create inbox
    (Owner: ${INITIAL_ADDRESS})
  ```

Sign the **XMTP : Authenticate to inbox** message with your wallet address to consent to the message requests.

<img width="400" src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/authen-to-inbox.PNG" alt="MetaMask wallet browser extension Sign this message? window showing an XMTP: Authenticate to inbox message" />

## Sign to add another address to your inbox

You can add another wallet address to your inbox at any time. For example, you might have started using an app with one wallet address and now want to use the app with an additional wallet address.

If you decide to add another wallet address to your inbox, a **Sign this message?** window displays to request that you sign an **XMTP : Authenticate to inbox** message. Specifically, the message requests that you sign a **Link address to inbox** message. For example:

```text
- Link address to inbox
  (Address: ${ASSOCIATED_ADDRESS})
```

Sign with the wallet address you want to add to grant it access to the inbox. You can now use your inbox to exchange messages using the wallet address you just added.

## Sign to remove address from your inbox

You can remove a wallet address from your inbox at any time.

If you decide to remove a wallet address from your inbox, a **Sign this message?** window displays to request that you sign an **XMTP : Authenticate to inbox** message. Specifically, the message requests that you sign an **Unlink address from inbox** message. For example:

```text
- Unlink address from inbox
  (Address: ${ASSOCIATED_ADDRESS})
```

Sign with the wallet address you want to remove to unlink it from your inbox. You can no longer access your inbox using the wallet address you removed.

## Sign to change inbox recovery address

The first time you used an app installation built with XMTP v3, the wallet address you used to create an inbox is automatically set as the inbox recovery address. You can change the recovery address to a different wallet address at any time.

If you decide to change the recovery address, a **Sign this message?** window displays to request that you sign an **XMTP : Authenticate to inbox** message. Specifically, the message requests that you sign a **Change inbox recovery address** message. For example:

```text
- Change inbox recovery address
  (Address: ${NEW_RECOVERY_ADDRESS})
```

Sign with the wallet address you want to set as the recovery address to change the recovery address.

## Sign to consent to receive broadcast messages

When you click a **Subscribe** button built with XMTP's consent standards, you're prompted to sign an **XMTP : Grant inbox consent to sender** message.

For example, here's the MetaMask **Signature request** window that displays when clicking the **Subscribe** button on this [example subscription page](https://subscribe-broadcast.vercel.app/subscribe/button) connected to the XMTP `dev` network. You typically see **Subscribe** buttons like this on a web page or in a dapp.

![MetaMask wallet browser extension Signature request window showing an "XMTP: Grant inbox consent to sender" message](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/consent-proof-sign.png)

When you click **Sign**, you're consenting to receive broadcast messages from the publisher at your connected wallet address. You can see the publisher's sending address in the **Signature request** window.

When you provide consent, you're adding the publisher's address to your personal XMTP allowed contacts list. This enables messages from the publisher to be displayed in your main inbox instead of being treated as a message from an unknown sender and placed in a secondary view.

To learn about XMTP's consent standards, see [Understand how user consent preferences support spam-free inboxes](/chat-apps/user-consent/user-consent).


## pages/protocol/xips.mdx
# XMTP Improvement Proposals (XIPs)

An XIP is a design document that proposes a new feature or improvement for XMTP or its processes or environment.

XIPs intend to be the primary mechanisms for:

- Proposing new features
- Collecting community technical input on an issue
- Documenting the design decisions that have gone into XMTP

For these reasons, XIPs are a great way to learn about XMTP's newest features and participate in shaping the evolution of the protocol.

To review the latest XIPs, see [Improvement Proposals](https://community.xmtp.org/c/xips/xip-drafts/53).

To learn more about XIPs and how to participate in the process, including authoring an XIP of your own, see [XIP purpose, process, and guidelines](https://github.com/xmtp/XIPs/blob/main/XIPs/xip-0-purpose-process.md).


## pages/protocol/topics.mdx
# Topics with XMTP

This document describes the concept of **topics** on the XMTP network. Topics are used to address and route [envelopes](/protocol/envelope-types), forming the backbone of the XMTP pub/sub messaging system.

While XMTP SDKs manage topic subscriptions automatically, understanding them can be helpful for protocol-level development, debugging, and building services like push notification servers.

## Topic naming convention

XMTP topics follow a standardized format that indicates the protocol version, message type, and a unique identifier. The general structure is:

`/xmtp/mls/1/{topic-type}-{identifier}/proto`

- `/xmtp/mls/1/`: The protocol namespace, indicating XMTP with MLS, version 1.
- `{topic-type}`: A single letter representing the purpose of the topic (for example, `g` for group, `w` for welcome).
- `{identifier}`: A unique ID for the specific conversation or installation.
- `/proto`: The payload serialization format.

## Core topics in XMTP

XMTP uses two primary topic types for delivering messages.

### Group message topic

The group message topic is used to send and receive messages within a specific conversation (both 1:1 DMs and group chats). Each conversation has its own unique topic.

- **Format**: `/xmtp/mls/1/g-$conversationId/proto`
- **Envelope**: [Group message envelope](/protocol/envelope-types#group-message-envelope)
- **Purpose**: Carries all ongoing communication for a conversation, including [application messages](/protocol/envelope-types#application-messages) (text, reactions, etc.) and [commit messages](/protocol/envelope-types#commit-messages) that modify the group state.
- **Usage**: When an app wants to receive messages for a conversation, it subscribes to this topic. The `conversation.topic` property in the SDKs provides this value.

> **Note on [DM stitching](/chat-apps/push-notifs/understand-push-notifs#understand-dm-stitching-and-push-notifications): For direct messages, multiple underlying conversations might be "stitched" together in the UI. For push notifications to be reliable, an app must subscribe to the group message topic for each of these underlying conversations.

### Welcome message topic

The welcome message topic is used to deliver a `Welcome` message to a new member of a group. This message bootstraps the new member, providing them with the group's state so they can participate.

- **Format**: `/xmtp/mls/1/w-$installationId/proto`
- **Envelope**: [Welcome message envelope](/protocol/envelope-types#welcome-message-envelope)
- **Purpose**: To notify a specific app installation that it has been added to a new conversation.
- **Usage**: A push notification server subscribes to an installation's welcome topic to be notified when that installation is invited to a new group chat or DM. The SDKs provide this via methods like `client.welcomeTopic()`.

## How other envelopes are handled

Not all envelope types are broadcast on persistent pub/sub topics.

- **[Key package envelopes](/protocol/envelope-types#key-package-envelope)**: These are not sent over a topic. Instead, they are published to a network-level store where they can be retrieved by other clients who need to start a conversation or add a new member to a group.

- **[Identity update envelopes](/protocol/envelope-types#identity-update-envelope)**: These are also not sent over a topic. They are stored permanently on the XMTP network to ensure the continuity and verifiability of a user's identity across their devices.


## pages/protocol/security.mdx
# Messaging security properties with XMTP

XMTP delivers end-to-end encrypted 1:1 and group chat using the following resources:

- Advanced cryptographic techniques
- Secure key management practices
- MLS ([Messaging Layer Security](https://www.rfc-editor.org/rfc/rfc9420.html))

Specifically, XMTP messaging provides the comprehensive security properties covered in the following sections. In these sections, **group** refers to the MLS concept of a group, which includes both 1:1 and group conversations.

🎥 **walkthrough: XMTP and MLS**

This video provides a walkthrough of XMTP's implementation of MLS.

<iframe width="560" height="315" src="https://www.youtube.com/embed/g6I9qXOkDMo?si=o5pD2xwa_yynoP5s" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

To dive deeper into how XMTP implements MLS, see the [XMTP MLS protocol specification](https://github.com/xmtp/libxmtp/tree/main/xmtp_mls).

## A deep dive into messaging security properties

### Message confidentiality

Ensures that the contents of messages in transit can't be read without the corresponding encryption keys.

Message confidentiality is achieved through symmetric encryption, ensuring that only intended recipients can read the message content. [AEAD](#cryptographic-tools-in-use) (Authenticated Encryption with Associated Data) is used to encrypt the message content, providing robust protection against unauthorized access.

## Forward secrecy

Ensures that even if current session keys are compromised, past messages remain secure.

MLS achieves this by using the ratcheting mechanism, where the keys used to encrypt application messages are ratcheted forward every time a message is sent. When the old key is deleted, old messages can't be decrypted, even if the newer keys are known. This property is supported by using ephemeral keys during the key encapsulation process.

## Post-compromise security

Ensures that future messages remain secure even if current encryption keys are compromised.

XMTP uses regular key rotation achieved through a commit mechanism with a specific update path in MLS, meaning a new group secret is encrypted to all other members. This essentially resets the key and an attacker with the old state can't derive the new secret, as long as the private key from the leaf node in the ratchet tree construction hasn't been compromised. This ensures forward secrecy and protection against future compromises.

## Message authentication

Validates the identity of the participants in the conversation, preventing impersonation.

XMTP uses digital signatures to strongly guarantee message authenticity. These signatures ensure that each message is cryptographically signed by the sender, verifying the sender's identity without revealing it to unauthorized parties. This prevents attackers from impersonating conversation participants.

## Message integrity

Ensures that messages can't be tampered with during transit and that messages are genuine and unaltered.

XMTP achieves this through the use of MLS. The combination of digital signatures and [AEAD](#cryptographic-tools-in-use) enables XMTP to detect changes to message content.

## Quantum resistance

Protects against future quantum computer attacks through post-quantum cryptography.

XMTP implements quantum-resistant encryption to protect against "Harvest Now, Decrypt Later" (HNDL) attacks, where adversaries store encrypted messages until quantum computers become powerful enough to break current encryption. XMTP uses a hybrid approach that combines post-quantum algorithms with conventional cryptography, ensuring protection against future quantum threats without compromising current security.

The quantum resistance is implemented by securing Welcome messages (the entry point for all conversations) with post-quantum key encapsulation. Since Welcome messages contain the group secrets needed to decrypt all messages in a conversation, protecting them with quantum-resistant encryption ensures the entire conversation remains secure against quantum attacks. Once inside a group, all messages maintain the same size and performance characteristics as before.

## User anonymity

Ensures that outsiders can't deduce the participants of a group, users who have interacted with each other, or the sender or recipient of individual messages.

User anonymity is achieved through a combination of the following functions:

- MLS Welcome messages encrypt the sender metadata and group ID, protecting the social graph.

- XMTP adds a layer of encryption to MLS Welcome messages using [HPKE](#cryptographic-tools-in-use) (Hybrid Public Key Encryption). This prevents multiple recipients of the same Welcome message from being correlated to the same group.

- XMTP uses MLS [PrivateMessage](https://www.rfc-editor.org/rfc/rfc9420.html#name-confidentiality-of-sender-d) framing to hide the sender and content of group messages.

- XMTP's backend doesn't authenticate reads or writes and only implements per-IP rate limits. Aside from Welcome messages, all payloads for a given group are stored under a single group ID, and any client may anonymously query or write to any group ID. Only legitimate members possess the correct encryption keys for a given group.

It's technically possible for XMTP network node operators to analyze query patterns per IP address. However, clients may choose to obfuscate this information using proxying/onion routing.

XMTP currently hides the sender of Welcome messages (used to add users to a group) but doesn't hide the Welcome message recipients. This makes it possible to determine how many groups a user was invited to but not whether the user did anything about the invitations.

## Cryptographic tools in use

XMTP messaging uses the ciphersuite _MLS_128_HPKEX25519_CHACHA20POLY1305_SHA256_Ed25519_.

Here is a summary of individual cryptographic tools used to collectively ensure that XMTP messaging is secure, authenticated, and tamper-proof:

- [HPKE](https://www.rfc-editor.org/rfc/rfc9180.html)

    Used to encrypt Welcome messages, protect the identities of group invitees, and maintain the confidentiality of group membership. We use the ciphersuite HPKEX25519.

- [AEAD](https://developers.google.com/tink/aead)

    Used to ensure both confidentiality and integrity of messages. In particular, we use the ciphersuite CHACHA20POLY1305.

- [SHA3_256 and SHA2_256](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)

    XMTP uses two cryptographic hash functions to ensure data integrity and provide strong cryptographic binding. SHA3_256 is used in the multi-wallet identity structure. SHA2_256 is used in MLS. The ciphersuite is SHA256.

- [Ed25519](https://ed25519.cr.yp.to/ed25519-20110926.pdf)

    Used for digital signatures to provide secure, high-performance signing and verification of messages. The ciphersuite is Ed25519.

- [XWING KEM](https://www.ietf.org/archive/id/draft-connolly-cfrg-xwing-kem-02.html)

    Used for quantum-resistant key encapsulation in Welcome messages. XWING is a hybrid post-quantum KEM that combines conventional cryptography with [ML-KEM](https://csrc.nist.gov/pubs/fips/203/final) (the NIST-standardized post-quantum component), providing protection against future quantum computer attacks while maintaining current security standards.


## pages/protocol/cursors.mdx
# Cursors with XMTP

This document explains the concept of **cursors** as they relate to message synchronization on the XMTP network. Cursors are a fundamental part of how XMTP clients efficiently fetch new messages and maintain state, particularly with the `sync()` family of functions.

While cursors are managed automatically by the XMTP SDKs, understanding how they work is crucial for debugging and for grasping the underlying mechanics of message synchronization.

## What is a cursor?

A cursor is a pointer or a marker that an XMTP client maintains for each topic it subscribes to (both [group message topics](/protocol/topics#group-message-topic) and [welcome message topics](/protocol/topics#welcome-message-topic)). This cursor is stored locally and is specific to each app installation.

Think of it as a bookmark in the chronological log of messages and events for a given topic. Its purpose is to remember the exact point up to which an installation has successfully synchronized its data.

## How cursors work with `sync()`

The primary role of a cursor becomes evident when you use the `sync()` functions (`conversation.sync()`, `conversations.sync()`, and `conversations.syncAll()`).

1. **Initial sync**: The first time an app installation calls `sync()` for a specific conversation, it fetches all available messages and events from the network for that conversation's topic.
2. **Cursor placement**: Once the sync is complete, the SDK places a cursor at the end of that batch of fetched messages.
3. **Subsequent syncs**: On the next `sync()` call for that same conversation, the client sends its current cursor position to the network. The network then returns only the messages and events that have occurred *after* that cursor.
4. **Cursor advancement**: After the new messages are successfully fetched, the SDK advances the cursor to the new latest point.

This process ensures that each `sync()` call only retrieves what's new, making synchronization efficient by avoiding the re-downloading of messages the client already has.

### How Cursors Enable Efficient Sync

The XMTP SDKs use cursors to make message synchronization highly efficient. The design principle is to fetch new data from the network with `sync()` while providing access to historical data from a local database.

- **`sync()` fetches new data from the network:** The `sync()` functions are designed specifically to retrieve new messages and events from the network. To do this efficiently, the SDK advances the cursor to the position of the last synchronized item. On subsequent `sync()` calls, the client provides this cursor, and the network returns only what has arrived since. This forward-only cursor movement is an intentional design choice that prevents re-downloading data the client already has.

- **Access old messages from the local database:** Once `sync()` fetches messages from the network, they are stored in a local database managed by the SDK. You can query this database at any time to retrieve historical messages without making a network request. This provides fast, local access to the full message history available to the installation.

- **History on new devices is handled by history sync:** The behavior of cursors should not be confused with loading message history on a new device. A new app installation lacks the encryption keys to decrypt old messages. Even if it could fetch them from the network, they would be unreadable. [History sync](/chat-apps/list-stream-sync/history-sync) is the dedicated process for securely transferring message history and the necessary encryption keys to a new installation.

- **Streaming does not affect the cursor:** Receiving messages via a real-time `stream()` does not move the cursor. Streaming provides instant message delivery but doesn't guarantee order or completeness if the client is briefly offline. `sync()` serves as the mechanism to ensure the local state is complete and correctly ordered, and only then is the cursor advanced.

## Cursors for different sync functions

Each `sync()` function corresponds to a different type of cursor:

- `conversation.sync()`: This operates on the **group message topic** for a single conversation. It moves the cursor for that specific conversation, fetching new messages or group updates (like name changes).
- `conversations.sync()`: This operates on the **welcome message topic**. It moves the cursor for welcome messages, fetching any new conversations the user has been invited to. It does *not* fetch the contents of those new conversations.
- `conversations.syncAll()`: This is the most comprehensive sync. It effectively performs the actions of the other two syncs for all of the user's conversations. It moves the cursors for the welcome topic *and* for every individual group message topic, ensuring the client has fetched all new conversations and all new messages in existing conversations.

For example, here is a sequence diagram illustrating how cursors operate with `conversation.sync()`:

![](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/cursor-flow.png)

By understanding cursors, you can better reason about the behavior of your app's synchronization logic and the data being transferred from the XMTP network.


## pages/network/run-a-node.mdx
# Run an XMTP network node

A [testnet of the decentralized XMTP network](/network/network-nodes) was launched in early December 2024. The XMTP testnet is powered by registered node operators running [xmtpd](https://github.com/xmtp/xmtpd), XMTP daemon software. xmtpd will also power mainnet.

To learn more about the decentralized network, see [Decentralizing XMTP](https://xmtp.org/docs/concepts/decentralizing-xmtp).

## Interested in becoming a registered XMTP node operator?

1. Review [XIP-54: XMTP network node operator qualification criteria](https://community.xmtp.org/t/xip-54-xmtp-network-node-operator-qualification-criteria/868).
2. [Submit an application](https://docs.google.com/forms/d/e/1FAIpQLScBpJ0i962xBPpZZeI6q7-UMo5Bc2JkhvHR_v2rliLDoBkzXQ/viewform?usp=sharing) to become a registered node operator.

## Already a registered node operator?

To get started, see the [xmtpd-infrastructure](https://github.com/xmtp/xmtpd-infrastructure) repository, which provides infrastructure-as-code examples and tooling to help node operators deploy and manage xmtpd nodes.

## FAQ about the XMTP network

To follow and provide feedback on the engineering work covered in this FAQ, see the [Replication tracking task](https://github.com/xmtp/xmtpd/issues/118) in the [xmtpd repo](https://github.com/xmtp/xmtpd).

### Is the XMTP network decentralized?

A testnet of the decentralized XMTP network was launched in early December 2024.

All of the nodes in the `dev` and `production` XMTP network environments are still operated by [Ephemera](https://ephemerahq.com/) (the company) and powered by [xmtp-node-go](https://github.com/xmtp/xmtp-node-go).

These nodes in the `dev` and `production` XMTP network environments operate in US jurisdiction in compliance with Office of Foreign Assets Control (OFAC) sanctions and Committee on Foreign Investment in the United States (CFIUS) export compliance regulations. Accordingly, IP-based geoblocking is in place for the following countries/territories:

- Cuba
- Iran
- North Korea
- Syria
- The Crimea, Donetsk People's Republic, and Luhansk People's Republic regions of Ukraine

### Is XMTP a blockchain?

The testnet of the decentralized XMTP network includes two distributed systems:

- The XMTP broadcast network
- The XMTP appchain, which is an L3 blockchain securing all metadata that require strict ordering.

To learn more, see [Decentralizing XMTP](https://xmtp.org/docs/concepts/decentralizing-xmtp).

The `dev` and `production` XMTP network environments do not use a blockchain. Nodes in these networks run software to store and transfer messages between blockchain accounts. For secure and reliable delivery of messages, the nodes participate in a consensus mechanism.

### Will I be able to run my own XMTP node?

At this time, not everyone will be able to run an XMTP node in the production decentralized XMTP network.

To learn more, see [XIP-54: XMTP network node operator qualification criteria](https://community.xmtp.org/t/xip-54-xmtp-network-node-operator-qualification-criteria/868).

### Does XMTP have a token?

XMTP does not currently have a token. Disregard any information regarding airdrops or token sales. If and when an official token is introduced, announcements will be made exclusively through XMTP's official channels.


## pages/network/network-nodes.mdx
# XMTP testnet nodes

For real-time statuses of nodes in the XMTP testnet, see [XMTP Node Status](https://status.testnet.xmtp-partners.xyz/).
The following table lists the nodes currently registered to power the XMTP testnet.

|  | Node operator | Node address |
|-----|---------------|--------------|
| 1 | Artifact Capital | xmtp.artifact.systems:443 |
| 2 | Crystal One | xmtp.node-op.com:443 |
| 3 | Emerald Onion | xmtp.disobey.net:443 |
| 4 | Encapsulate | lb.validator.xmtp.testnet.encapsulate.xyz:443 |
| 5 | Ethereum Name Service (ENS) | grpc.ens-xmtp.com:443 |
| 6 | Laminated Labs | xmtp.validators.laminatedlabs.net:443 |
| 7 | Next.id | xmtp.nextnext.id:443 |
| 8 | Nodle | xmtpd.nodleprotocol.io:443 |
| 9 | Ephemera | grpc.testnet.xmtp.network:443 |
| 10 | Ephemera | grpc2.testnet.xmtp.network:443 |

Here is a map of node locations:

<div style={{ position: "relative", paddingBottom: "56.25%", height: 0, overflow: "hidden" }}>
  <iframe
    src="https://www.google.com/maps/d/embed?mid=18y4nFTXQKdgiSJCQbEGl5dojPoHL3LQ&ehbc=2E312F&noprof=1"
    style={{ position: "absolute", top: 0, left: 0, width: "100%", height: "100%", border: 0 }}
    allowFullScreen=""
    loading="lazy"
  ></iframe>
</div>

A purple pin indicates that the node is operated by a non-profit organization.


## pages/chat-apps/debug-your-app.mdx
# Debug your chat app

This document covers tools and features available for debugging building with XMTP, including stress testing, group chat diagnostics, logging, and network monitoring capabilities.

## XMTP Debug

You can use the XMTP Debug tool to stress and burn-in test your chat app on the `local` and `dev` XMTP environments.

To learn more, see [XMTP Debug](https://github.com/xmtp/libxmtp/blob/main/xmtp_debug/README.md).

## Forked group debugging tool

:::tip[Preventing forks is XMTP's responsibility]

This tool helps you identify forked groups in your app, but preventing forks in the first place is XMTP's responsibility. This diagnostic tool is just an aid and not a shift in responsibility to your app.

:::

A conversation has `getDebugInformation`. You can use this to see:

- The MLS epoch of a group chat conversation for a member
- The local commit log for expert analysis
- Whether a group chat is forked (no false positives) via:
  - `isCommitLogForked` for Browser and Node SDKs
  - `commitLogForkStatus` for React Native, Android and iOS SDKs

The `isCommitLogForked`/`commitLogForkStatus` field provides definitive fork detection without false positives. To minimize the negative effects of spam, fork detection is active only for groups that a user has actively consented to, which is automatically true for groups/DMs they created or groups/DMs they've sent a message in. To learn more about consent, see [Support user consent](/chat-apps/user-consent/support-user-consent).

:::code-group

```typescript [Browser, Node]
// Get detailed debug information for a conversation
const debugInfo = await conversation?.debugInfo();

console.log('Epoch:', debugInfo.epoch);
console.log('Cursor:', debugInfo.cursor);
console.log('Fork Status:', debugInfo.isCommitLogForked); // true, false, or undefined
console.log('Local Commit Log:', debugInfo.localCommitLog);
console.log('Remote Commit Log:', debugInfo.remoteCommitLog);
console.log('Fork Details:', debugInfo.forkDetails);
```

```typescript [React Native, Kotlin, Swift]
// Get detailed debug information for a conversation
const debugInfo = await conversation?.getDebugInformation();

console.log('Epoch:', debugInfo.epoch);
console.log('Fork Status:', debugInfo.commitLogForkStatus); // 'forked', 'notForked', or 'unknown'
console.log('Local Commit Log:', debugInfo.localCommitLog);
console.log('Remote Commit Log:', debugInfo.remoteCommitLog);
console.log('Fork Details:', debugInfo.forkDetails);
```

:::

You can also check fork status directly from conversation lists:

:::code-group

```typescript [Browser, Node]
// Check fork status when listing conversations
const conversations = await client.conversations.list();

conversations.forEach(conversation => {
  if (conversation.isCommitLogForked) {
    console.log(`Conversation ${conversation.id} is forked`);
  }
});
```

```typescript [React Native, Kotlin, Swift]
// Check fork status when listing conversations
const conversations = await client.conversations.list();

conversations.forEach(conversation => {
  if (conversation.commitLogForkStatus === 'forked') {
    console.log(`Conversation ${conversation.id} is forked`);
  }
});
```

:::

To learn about group chat forks, see [MLS Group State Forks: What, Why, How](https://cryspen.com/post/mls-fork-resolution/).

If you believe you are experiencing a forked group, please [open an issue](https://github.com/xmtp/libxmtp/issues) in the LibXMTP repo to get support. Please include logs, the epoch, and other fork details.

Forked groups are not recoverable. Your options are to:

- Remove all members from the forked group and then re-add them to the group.
- Start a new group.

## File logging

These file logging functions enable the XMTP rust process to write directly to persistent log files that roll during every hour of active usage and provide a 6-hour window of logs. This can be especially helpful when debugging group chat errors and other complex issues.

The file logs complement Android and iOS system logs, which rely on memory buffer constraints, but often don't go back far enough to help catch when an issue occurs.

To use file logging, call the following static functions:

- `Client.activatePersistentLibXMTPLogWriter()`: Use to activate the file logging feature.
  - We recommend using `LogLevel.Debug`, `LogRotation.Hourly`, and a `logMaxFiles` value of 5-10. Log files can grow to ~100mb each with active clients on debug level in an hour of usage.
- `Client.getXMTPLogFilePaths()`: Use to get the full paths of log files written so far. This is useful for passing to iOS or Android Share functions.
- Here are additional helper static functions in the XMTP Client object:
  - `deactivatePersistentLibXMTPLogWriter()`
  - `isLogWriterActive()`
  - `readXMTPLogFile()`
  - `clearXMTPLogs()`

For an example UI implementation, see PR to [add new persistent log debug menu options](https://github.com/ephemeraHQ/convos-app/pull/6) to the Convos app, built with XMTP.

## Network statistics

You can use these statistics to see which and how many API, identity, and streaming calls are going across the network, which can help you better manage network usage and debug potential rate limiting issues.

These statistics are maintained per client instance, so each app installation has its own separate counter. Each one is a rolling counter for the entire session since the gRPC client was created. To get a snapshot of statistics at a moment in time, you can check the counter, run the action, get the counter again, and then diff the counter with the original counter.

### Get aggregated statistics

To return aggregated statistics, run:

- For Browser, Node, iOS, and Android SDKs: `client.debugInformation.apiAggregateStatistics()`
- For React Native SDK: `client.debugInformation.aggregateStatistics`

```text
Aggregate Stats:
============ Api Stats ============
UploadKeyPackage        1
FetchKeyPackage         2
SendGroupMessages       5
SendWelcomeMessages     1
QueryGroupMessages      7
QueryWelcomeMessages    0
============ Identity ============
PublishIdentityUpdate    1
GetIdentityUpdatesV2     4
GetInboxIds             2
VerifySCWSignatures     0
============ Stream ============
SubscribeMessages        0
SubscribeWelcomes       0
```

### Get an individual statistic

To return an individual statistic as a number, run:

- For Browser, Node, iOS, and Android SDKs:
  - `client.debugInformation.apiStatistics.uploadKeyPackage` to track `uploadKeyPackage` only, for example
  - `client.debugInformation.apiIdentityStatistics.publishIdentityUpdate` to track `publishIdentityUpdate` only, for example

- For React Native SDK:
  - `client.debugInformation.Statistics.uploadKeyPackage` to track `uploadKeyPackage` only, for example
  - `client.debugInformation.IdentityStatistics.publishIdentityUpdate` to track `publishIdentityUpdate` only, for example

For available individual statistics, see [Statistic descriptions](#statistic-descriptions).

### Clear statistics

To clear all API, identity, and stream statistics and set them to zero, run `client.debugInformation.clearAllStatistics()`.

This is useful when you want to get a clean baseline before running specific actions. It's also particularly helpful for managing memory usage on mobile devices where gRPC client caching can accumulate large statistics.

### Upload an archive of network statistics

With the Browser and Node SDKs, you can upload an archive of collected network statistics.

```tsx [TypeScript]
// Upload to default server (no serverUrl needed)
const result1 = await client.debugInformation.uploadDebugArchive();

// Upload to custom server (serverUrl provided)
const result2 = await client.debugInformation.uploadDebugArchive(
  "https://my-debug-server.com/api/upload"
);
```

### Statistic descriptions

#### API statistics

| Statistic | Description |
|-----------|-------------|
| UploadKeyPackage | Number of times key packages have been uploaded. |
| FetchKeyPackage | Number of times key packages have been fetched. |
| SendGroupMessages | Number of times messages have been sent to group chat and DM conversations. |
| SendWelcomeMessages | Number of times welcome messages have been sent. |
| QueryGroupMessages | Number of times queries have been made to fetch messages being sent to group chat and DM conversations. |
| QueryWelcomeMessages | Number of times queries have been made to fetch welcome messages. |

#### Identity statistics

| Statistic | Description |
|-----------|-------------|
| PublishIdentityUpdate | Number of times identity updates have been published. |
| GetIdentityUpdatesV2 | Number of times identity updates have been fetched. |
| GetInboxIds | Number of times inbox ID queries have been made. |
| VerifySCWSignatures | Number of times smart contract wallet signature verifications have been performed. |

#### Stream statistics

| Statistic | Description |
|-----------|-------------|
| SubscribeMessages | Number of times message subscription requests have been made. This is streaming messages in a conversation. |
| SubscribeWelcomes | Number of times welcome message subscription requests have been made. This is streaming conversations. |


## pages/chat-apps/use-signatures.mdx
# Use signatures with XMTP

With XMTP, you can use various types of signatures to sign and verify payloads.

## Sign with an external wallet

When a user creates, adds, removes, or revokes an XMTP inbox's identity or installation, a signature is required.

## Sign with an XMTP key

You can sign something with XMTP keys. For example, you can sign with XMTP keys to send a payload to a backend.

:::code-group

```js [Node]
const signature = client.signWithInstallationKey(signatureText);
```

```jsx [React Native]
const signature = await client.signWithInstallationKey(signatureText)
```

```kotlin [Kotlin]
val signature = client.signWithInstallationKey(signatureText)
```

```swift [Swift]
let signature = try client.signWithInstallationKey(message: signatureText)
```

:::

## Verify with the same installation that signed

 You can also sign with XMTP keys and verify that a payload was sent by the same client.

:::code-group

```js [Node]
const isValidSignature = client.verifySignedWithInstallationKey(signatureText, signature);
```

```jsx [React Native]
const isVerified = await client.verifySignature(signatureText, signature)
```

```kotlin [Kotlin]
val isVerified = client.verifySignature(signatureText, signature)
```

```swift [Swift]
let isVerified = try client.verifySignature(
            message: signatureText, 
            signature: signature
        )

```

:::

## Verify with the same inbox ID that signed

You can use an XMTP key's `installationId` to create a signature, then pass both the signature and `installationId` to another `installationId` with the same `inboxId` to verify that the signature came from a trusted sender.

:::code-group

```js [Node]
const isValidSignature = client.verifySignedWithPrivateKey(signatureText, signature, installationId);
```

```kotlin [Kotlin]
val isVerified = client.verifySignatureWithInstallationId(
            signatureText, 
            signature, 
            installationId
      )
```

```swift [Swift]
let isVerified = try client.verifySignatureWithInstallationId(
                message: signatureText,
                signature: signature,
                installationId: installationId
            )
```

:::


## pages/chat-apps/list-stream-sync/history-sync.mdx
# Enable history sync for apps built with XMTP

:::warning[This feature is in beta]

History sync is still in active development as we work on its reliability and performance. To provide feedback on this feature, please post to [Ideas & Improvements](https://community.xmtp.org/c/general/ideas/54) in the XMTP Community Forums.

:::

Enable the history sync feature to give your users a way to sync decrypted historical data from an existing app installation to a new app installation.

This historical data includes:

- Conversations
- Conversation messages
- Consent state
- HMAC keys (for push notifications)

History sync enables your users pick up conversations where they left off, regardless of the app installation they use. All they need is a pre-existing and online app installation to provide the data.

## 🎥 walkthrough: History sync

This video provides a walkthrough of history sync, covering the key ideas discussed in this doc. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/_FtNqtjk-ls?si=uZ_Mnh9phF6y2h-O" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

## Enable history sync

History sync is enabled by default and runs automatically. When [creating a client](/chat-apps/core-messaging/create-a-client), the `historySyncUrl` client option is dynamically set to a default history sync server URL based on your `env` client option setting.

- When `env` is set to `dev`, the `historySyncUrl` is set to `https://message-history.dev.ephemera.network/`
- When `env` is set to `production`, the `historySyncUrl` is set to `https://message-history.production.ephemera.network`

These default servers are managed and operated by [Ephemera](https://ephemerahq.com/), a steward of the development and adoption of XMTP.

You can choose to [run your own server](https://github.com/xmtp/xmtp-message-history-server) and set the `historySyncUrl` to your server's URL.

If needed, you can turn off history sync by setting the `historySyncUrl` client option to an empty string.

## How history sync works

When your app initializes an XMTP client and a `historySyncUrl` client option is present, history sync automatically triggers an initial sync request and creates an encrypted payload.

<div>
    <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/history-sync-step1.png" width="600px" />
</div>

History sync then uploads the payload, sends a sync reply, and pulls all conversation state history into the new app installation, merging it with the existing app installations in the sync group.

<div>
    <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/history-sync-step2.png" width="600px" />
</div>

Ongoing updates to history are streamed automatically. Updates, whether for user consent preferences or messages, are sent across the sync group, ensuring all app installations have up-to-date information.

History syncs are accomplished using these components:

- Sync group
- Sync worker
- History server

### Sync group

A sync group is a special [Messaging Layer Security](/protocol/security) group that includes all of the user's devices. The sync group is used to send serialized sync messages across the user's devices. The sync group is filtered out of most queries by default so they don't appear in the user's inbox.

### Sync worker

A sync worker is a spawned background worker that listens for sync events, and processes them accordingly. This worker:

- Emits and updates consent
- Creates and consumes archive payloads for and from other devices
- Keeps preferences synced across devices

### History server

A history server acts as a bucket that holds encrypted sync payloads. The URL location of these payloads and the password (cipher encryption key) to decrypt these payloads is sent over the sync group for the recipient to decrypt.

## FAQ

### A user logged into a new app installation and doesn't see their conversations. What's going on?

A debounce feature checks for new app installations, at most, once every 30 minutes. To circumvent the cool-down timer, send a message using a pre-existing app installation.

Once [this issue](https://github.com/xmtp/libxmtp/issues/1309) is resolved, conversations will appear almost instantly.

### A user logged into a new app installation and sees their conversations, but no messages. What's going on?

Ensure that you've initiated a call to [sync messages](/chat-apps/list-stream-sync/sync-and-syncall#sync-all-new-welcomes-conversations-messages-and-preferences) and that the pre-existing app installation is online to receive the sync request, process and encrypt the payload, upload it to the history server, and send a sync reply message to the new app installation.

### I called a sync method (messages, consent state, or conversations), but nothing is happening. What's going on?

After requesting a sync for one app installation, ensure that the pre-existing app installation is online to receive the sync request.


## pages/chat-apps/list-stream-sync/sync-and-syncall.mdx
# Sync conversations and messages

:::tip[Note]
Syncing does not refetch existing conversations and messages. It also does not fetch messages for group chats you are no longer a part of.
:::

## 🎥 walkthrough: Syncing

This video provides a walkthrough of key concepts required to implement syncing correctly.

<iframe width="560" height="315" src="https://www.youtube.com/embed/jl7P0onApxw?si=YNafIHebx9Kxycos" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

## Sync a specific conversation

Get all new messages and group updates (name, description, etc.) for a specific conversation from the network.

:::code-group

```js [Browser]
await client.conversation.sync();
```

```js [Node]
await client.conversation.sync();
```

```tsx [React Native]
await client.conversation.sync();
```

```kotlin [Kotlin]
client.conversation.sync()
```

```swift [Swift]
try await client.conversation.sync()
```

:::

## Sync new conversations

Get any new group chat or DM conversations from the network.

:::code-group

```js [Browser]
await client.conversations.sync();
```

```js [Node]
await client.conversations.sync();
```

```tsx [React Native]
await client.conversations.sync();
```

```kotlin [Kotlin]
client.conversations.sync()
```

```swift [Swift]
try await client.conversations.sync()
```

:::

## Sync all new welcomes, conversations, messages, and preferences

Sync all new welcomes, group chat and DM conversations, messages, and [preference updates](/chat-apps/list-stream-sync/sync-preferences) from the network.

By default, `syncAll` streams only conversations with a [consent state](/chat-apps/user-consent/user-consent#how-user-consent-preferences-are-set) of allowed or unknown.

We recommend streaming messages for allowed conversations only. This ensures that spammy conversations with a consent state of unknown don't take up networking resources. This also ensures that unwanted spam messages aren't stored in the user's local database.

To sync all conversations regardless of consent state, pass `[ALLOWED, UNKNOWN, DENIED]`.

To sync preferences only, you can call [`preferences.sync`](/chat-apps/list-stream-sync/sync-preferences). Note that `preferences.sync` will also sync welcomes to ensure that you have all potential new installations before syncing.

:::code-group

```js [Browser]
await client.conversations.syncAll(["allowed"]);
```

```js [Node]
await client.conversations.syncAll(["allowed"]);
```

```tsx [React Native]
await client.conversations.syncAllConversations(["allowed"]);
```

```kotlin [Kotlin]
client.conversations.syncAllConversations(consentState = listOf(ConsentState.ALLOWED))
```

```swift [Swift]
try await client.conversations.syncAllConversations(consentState: [.allowed])
```

:::


## pages/chat-apps/list-stream-sync/archive-backups.md
# Support archive-based backups

Support archive-based backups to give your users an easy and durable way to back up their XMTP conversations, messages, and consent preferences from one app installation and import them into another.

For example, a user can set up an archive-based backup for an app installation on their device. If they lose their device and get a new one, they can download and import their archive-based backup onto their new device.

When an archive-based backup is imported into an installation, **all imported conversations start off as inactive, with history visible and in read-only mode**. This is as intended by Messaging Layer Security (MLS), which ensures that there is no way to join a conversation without the permission of an existing member. As such, imported conversations will be inactive until the new installation is added to the conversation by an active member. This process happens invisibly and automatically as other members of the group come online and send or receive messages.

To learn more, see [4. Handle post-import conversation statuses](#4-handle-post-import-conversation-statuses).

This feature includes three core methods:

- `createArchive(path, encryptionKey, options?)`
- `archiveMetadata(path, encryptionKey)`
- `importArchive(path, encryptionKey)`

## 1. Create the archive

To enable a user to create an archive:

1. Specify the archive file path (e.g., iCloud, Google Cloud, or your server). Ensure the parent folder already exists.
2. Generate a 32-byte array encryption key to protect the archive contents. This ensures that other apps and devices cannot access the contents without the key. Securely store the key in a location that is secure, independent of the archive file, and will persist after your app has been uninstalled. A common place to store this encryption key is the iCloud Keychain.
3. Call `createArchive(path, encryptionKey, options?)` with the archive file path and the encryption key. Optionally, you can pass in the following:

   - Archive start and end time. If left blank, the archive will include all time.
   - Archive contents, which can be `Consent` or `Messages`. If left blank, the archive will include both.

   :::code-group

   ```tsx [React Native]
   createArchive(path: string, encryptionKey: string | Uint8Array, options?: {
     startTime?: Date,
     endTime?: Date,
     elements?: ("Consent" | "Messages")[]
   })
   ```

   ```kotlin [Kotlin]
   // Create an archive backup
   XMTPClient.createArchive(
       path = "/path/to/archive.xmtp",
       encryptionKey = encryptionKey,
       options = ArchiveOptions(
           startTime = startTime,
           endTime = endTime,
           elements = listOf(ArchiveElement.CONSENT, ArchiveElement.MESSAGES)
       )
   )
   ```

   ```swift [Swift]
   // Create an archive backup
   try await xmtp.createArchive(
       path: "/path/to/archive.xmtp",
       encryptionKey: encryptionKey,
       options: ArchiveOptions(
           startTime: startTime,
           endTime: endTime,
           elements: [.consent, .messages]
       )
   )
   ```

   :::

   This writes the selected content into the specified file location and encrypts it using the provided key.

If the user tries to close the app before `createArchive` is complete, you can do a check to see if the file on the server is empty. If empty, display a warning to the user letting them know that exiting the app will cancel archive creation.

## 2. Check archive metadata

To enable a user to view information about their archive(s) before importing it to an app installation:

:::code-group

```tsx [React Native]
archiveMetadata(path: string, encryptionKey: string)
```

```kotlin [Kotlin]
// Get archive metadata
val metadata = XMTPClient.archiveMetadata(
    path = "/path/to/archive.xmtp",
    encryptionKey = encryptionKey
)
// metadata.startTime, metadata.endTime, metadata.elements, metadata.createdAt
```

```swift [Swift]
// Get archive metadata
let metadata = try await xmtp.archiveMetadata(
    path: "/path/to/archive.xmtp",
    encryptionKey: encryptionKey
)
// metadata.startTime, metadata.endTime, metadata.elements, metadata.createdAt
```

:::

This will return information that enables the user to better understand the archive(s) they want to import:

- Start and end time of archived data
- Archived elements (messages and/or consent)
- Archive creation date

You can get the archive file size from the file system.

## 3. Import the archive

To enable a user to import a selected archive to an installation:

:::code-group

```tsx [React Native]
importArchive(path: string, encryptionKey: string)
```

```kotlin [Kotlin]
// Import an archive backup
XMTPClient.importArchive(
    path = "/path/to/archive.xmtp",
    encryptionKey = encryptionKey
)
```

```swift [Swift]
// Import an archive backup
try await xmtp.importArchive(
    path: "/path/to/archive.xmtp",
    encryptionKey: encryptionKey
)
```

:::

This downloads and integrates the archive data into the app installation’s local database. The archive import is **additive**, not destructive: existing messages are preserved, and duplicate messages are ignored.

If the user tries to close the app before `importArchive` is complete, display a warning to the user letting them know that exiting the app will cancel the archive import.

## 4. Handle post-import conversation statuses

After importing the archive to an app installation, **all imported conversations will be inactive, with history visible and in read-only mode**, as intended by MLS as described earlier.

You should gray out UI functionality that involves writing to or modifying inactive conversations.

Attempting to send or sync on inactive conversations will throw a `Group is inactive` error.

To check conversation status before initiating a network action:

:::code-group

```tsx [React Native]
conversation.isActive();
```

```kotlin [Kotlin]
// Check if the conversation is active
if (conversation.isActive()) {
    // Conversation is active, safe to send or sync
} else {
    // Conversation is inactive, show read-only UI
}
```

```swift [Swift]
// Check if the conversation is active
if conversation.isActive() {
    // Conversation is active, safe to send or sync
} else {
    // Conversation is inactive, show read-only UI
}
```

:::

This will check to see if the installation is actively in the conversation yet.

To reactivate a DM or group conversation:

- A participant, or a preexisting installation belonging to the user who ran the import, will automatically add the new installation when sending a message to the conversation or calling `conversation.sync`. In some cases, it may take up to 30 minutes for other devices to recognize the new installation.
- For DM conversations, you may choose to programmatically create a duplicate DM for every inactive DM to trigger [stitching](/chat-apps/push-notifs/understand-push-notifs#dm-stitching-considerations-for-push-notifications). This will activate the DM conversations.

Inactive conversations in which participants frequently send messages may seem to activate immediately.

## Archive-based backups vs History Sync

Archive-based backups and History Sync serve similar purposes: helping you restore messages on new devices. When should you use one or the other?

- If your users sign in using wallets or passkeys shared by multiple chat apps provided by different developers, use [History Sync](/chat-apps/list-stream-sync/history-sync) to allow them to synchronize their messages when they install a new app.
- If your goal is to synchronize a user's message history across multiple devices that will be used at the same time, [History Sync](/chat-apps/list-stream-sync/history-sync) may be a better fit. Especially if those devices are on different platforms (an Android tablet and an iOS app).
- If your goal is to maintain message history when a user upgrades or replaces their device, use archive-based backups.
- If your goal is to allow users to export their data into the storage platform of their choosing, use archive-based backups.

## FAQ about archive-based backups

### What backup frequency options should I offer users?

Consider providing backup frequency options based on patterns in common chat apps:

- **Never** - For users who prefer manual control
- **Daily** - For active users (automatically at a quiet time like 2 AM)
- **Weekly** - For moderate users (for example, every Sunday)
- **Monthly** - For light users (for example, first day of each month)

You might also offer **manual backup** that enables users to create backups on demand

### How often should users create backups?

The frequency of archive creation depends on your users' messaging patterns and risk tolerance:

For most users:

- Weekly or monthly automated backups work well for regular message activity
- Consider creating archives after important conversations or when users receive many messages

For power users:

- Daily automated backups for users who send/receive many messages
- Allow manual backup creation before important events (travel, device changes)

Backup triggers to consider:

- Time-based: Daily, weekly, or monthly schedules
- Activity-based: After a certain number of new messages (for example, every 100 messages)
- Event-based: Before OS updates, app updates, or when users plan to switch devices

### Should users keep multiple backups?

Consider enabling users to maintain multiple backups:

- Keep the last 3-5 archives to provide recovery options if one archive becomes corrupted
- Implement automatic cleanup of old archives to manage storage space
- Allow users to name archives (for example, "Before iOS update" or "Monthly backup - Jan 2024") for easier identification

### How should I handle archive storage locations?

Follow patterns established by common chat apps:

- iCloud
- Google Drive
- User's preferred cloud service
- Your servers

### Should I automatically prompt users to create archives?

Consider gentle prompts similar to common chat apps:

- After app installation: Suggest setting up automated backups during onboarding
- Periodic reminders: Monthly prompts for users who haven't created recent archives (avoid being pushy)
- Before major events: Prompt before app updates or when users haven't backed up in a while
- Smart detection: Suggest backups when users have many new active conversations

### How do I help users understand archive limitations?

Be transparent about the post-import experience:

- Explain read-only mode: Let users know that imported conversations start as read-only
- Set expectations: Explain the reactivation process and that reactivation happens automatically but may take time
- Provide progress indicators: Show users when conversations become active again


## pages/chat-apps/list-stream-sync/list.mdx
# List conversations

## List existing conversations

Get a list of existing group chat and DM conversations in the local database.

By default, `list` returns only conversations with a [consent state](/chat-apps/user-consent/user-consent#how-user-consent-preferences-are-set) of allowed or unknown.

We recommend listing allowed conversations only. This ensures that spammy conversations with a consent state of unknown don't degrade the user experience.

To list all conversations regardless of consent state, use the `consentStates` option and pass all three consent states.

Conversations are listed in descending order by their `lastMessage` created at value. If a conversation has no messages, the conversation is ordered by its `createdAt` value.

:::code-group

```js [Browser]
const allConversations = await client.conversations.list({ consentStates: [ConsentState.Allowed] });
const allGroups = await client.conversations.listGroups({ consentStates: [ConsentState.Allowed] });
const allDms = await client.conversations.listDms({ consentStates: [ConsentState.Allowed] });
```

```js [Node]
const allConversations = await client.conversations.list({ consentStates: [ConsentState.Allowed] });
const allGroups = await client.conversations.listGroups({ consentStates: [ConsentState.Allowed] });
const allDms = await client.conversations.listDms({ consentStates: [ConsentState.Allowed] });
```

```tsx [React Native]
// List Conversation items
await alix.conversations.list(["allowed"]);

// List Conversation items and return only the fields set to true. Optimize data transfer
// by requesting only the fields the app needs.
await alix.conversations.list(
  {
    members: false,
    consentState: false,
    description: false,
    creatorInboxId: false,
    addedByInboxId: false,
    isActive: false,
    lastMessage: true,
  },
);
```

```kotlin [Kotlin]
// List conversations (both groups and dms)
val conversations = alix.conversations.list()
val filteredConversations = client.conversations.list(consentState = ConsentState.ALLOWED)

// List just dms
val dms = alix.conversations.listDms()
val filteredDms = client.conversations.listDms(consentState = ConsentState.ALLOWED)

//List just groups
val groups = alix.conversations.listGroups()
val filteredGroups = client.conversations.listGroups(consentState = ConsentState.ALLOWED)

```

```swift [Swift]
// List conversations (both groups and dms)
let conversations = try await alix.conversations.list()
let orderFilteredConversations = try await client.conversations.list(consentState: .allowed)

// List just dms
let conversations = try await alix.conversations.listDms()
let orderFilteredConversations = try await client.conversations.listDms(consentState: .allowed)

//List just groups
let conversations = try await alix.conversations.listGroups()
let orderFilteredConversations = try await client.conversations.listGroups(consentState: .allowed)
```

:::

## List a user's active conversations

The `isActive()` method determines whether the current user is still an active member of a group conversation. For example:

- When a user is added to a group, `isActive()` returns `true` for that user
- When a user is removed from a group, `isActive()` returns `false` for that user

You can use a user's `isActive: true` value as a filter parameter when listing conversations. You can potentially have a separate section for "archived" or "inactive" conversations where you could use `isActive: false`.


## pages/chat-apps/list-stream-sync/sync-preferences.mdx
# Sync preferences

You can sync the following preference-related information across multiple existing app installations:

- Conversation [consent preferences](/chat-apps/user-consent/user-consent#how-user-consent-preferences-are-set)
- Conversation HMAC keys (for [push notifications](/chat-apps/push-notifs/understand-push-notifs))

## Databases used by preferences sync

Each XMTP node contains:

- A **welcomes database**: Keeps a ledger of all groups an inbox ID is a part of.
- A **group messages database**: Keeps a ledger of all messages in the groups an inbox ID is a part of.

<div>
  <img alt="databases in each xmtpd node" src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/xmtpd-dbs.png" width="300px" />
</div>

In the welcomes database, the groups are of these types:

- **1:1 chat**: A group that handles conversations between an inbox ID and one other user.
- **Group chat**: A group that handles conversations between an inbox ID and multiple other users.
- **Preferences**: A group that handles syncing preferences between an inbox ID's existing app installations.

One-to-one chat, group chat, and preferences groups in the welcome database are updated by apps as follows:

- 1:1 chats
  - `conversations.list`
  - `syncAll`
  - `streamAll`
- Group chats
  - `conversations.list`
  - `syncAll`
  - `streamAll`
- Preferences
  - `preferences.sync`
  - `syncAll`

<div>
  <img alt="groups in the welcome database" src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/welcomes-db-3.png" width="500px" />
</div>

## Preferences group

To describe preference sync, let's first focus on how the preferences group works.

1. A preferences group has one member, which is one inbox ID.

2. Let's say Inbox ID Alix has an Installation A of App A on their phone. At this time, Inbox ID Alix has a preferences group that looks like this:

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/pg-1.png" width="300px" />
   </div>

3. Inbox ID Alix then logs in to an Installation B of App B on their phone. The next time Installation A runs `preferences.sync` or `syncAll`, it updates the preferences group as follows:

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/pg-2.png" width="300px" />
   </div>

4. Then let's say Inbox ID Alix logs in to an Installation C of App A on their tablet. The next time Installation A or B runs `preferences.sync` or `syncAll`, it updates the preferences group as follows:

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/pg-3.png" width="300px" />
   </div>

## Preferences sync worker

Now, let's describe how the preferences sync worker helps keep user consent preferences in sync across existing app installations.

1. Let's say Inbox ID Alix uses Installation A to block Inbox ID Bo.

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/a-block-bo.png" width="200px" />
   </div>

2. This sends a message to the preferences group in the group message database. This is not an actual chat message, but a serialized proto message that is not shown to app users.

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/gm-pg.png" width="300px" />
   </div>

3. When Installation B calls `preferences.sync` or `syncAll`, it gets the message from the preferences group. The sync worker listens for these preferences group messages and processes the message to block Inbox ID Bo in Installation B.

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/b-block-bo.png" width="200px" />
   </div>

4. Likewise, when Installation C calls `preferences.sync` or `syncAll`, it gets the message from the preferences group, and the sync worker ensures Inbox ID Bo is blocked there as well.

   <div>
      <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/c-block-bo.png" width="200px" />
   </div>

Preferences sync handles HMAC keys in the same way.

For example, it will handle syncing an HMAC key shared by Installation B to other installations. When Installation A and C call `preferences.sync` or `syncAll`, the sync worker gets Installation B's HMAC key message from the preferences group and ensures that Installation A and C get the HMAC key for Installation B.

## Sync preferences

Use this call to sync preferences (consent preferences and HMAC keys) across app installations in a preferences group. This will also sync welcomes to ensure that you have all potential new installations before syncing.

This is a lighter-weight alternative to syncing preferences using [`syncAll`](/chat-apps/list-stream-sync/sync-and-syncall).

:::code-group

```js [Browser]
await client.preferences.sync();
```

```js [Node]
await client.preferences.sync();
```

```tsx [React Native]
await client.preferences.sync()
```

```kotlin [Kotlin]
client.preferences.sync()
```

```swift [Swift]
try await client.preferences.sync()
```

:::


## pages/chat-apps/list-stream-sync/stream.mdx
# Stream conversations and messages

## Stream new group chat and DM conversations

Listens to the network for new group chats and DMs. Whenever a new conversation starts, it triggers the provided callback function with a [`ConversationContainer` object](/chat-apps/core-messaging/create-conversations#conversation-union-type). This allows the client to immediately respond to any new group chats or DMs initiated by other users.

:::code-group

```js [Browser]
const stream = await client.conversations.stream({
  onValue: (conversation) => {
    // Received a conversation
    console.log("New conversation:", conversation);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});

// Or use for-await loop
for await (const conversation of stream) {
  // Received a conversation
  console.log("New conversation:", conversation);
}
```

```js [Node]
const stream = await client.conversations.stream({
  onValue: (conversation) => {
    // Received a conversation
    console.log("New conversation:", conversation);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});

// To stream only groups
const groupStream = await client.conversations.streamGroups({
  onValue: (conversation) => {
    console.log("New group:", conversation);
  }
});

// To stream only DMs
const dmStream = await client.conversations.streamDms({
  onValue: (conversation) => {
    console.log("New DM:", conversation);
  }
});

// Or use for-await loop
for await (const conversation of stream) {
  // Received a conversation
  console.log("New conversation:", conversation);
}
```

```tsx [React Native]
await alix.conversations.stream(async (conversation: Conversation<any>) => {
  // Received a conversation
});
```

```kotlin [Kotlin]
alix.conversations.stream(type: /* OPTIONAL DMS, GROUPS, ALL */).collect {
  // Received a conversation
}
```

```swift [Swift]
for await convo in try await alix.conversations.stream(type: /* OPTIONAL .dms, .groups, .all */) {
  // Received a conversation
}
```

:::

## Stream new group chat and DM messages

This function listens to the network for new messages within all active group chats and DMs.

Whenever a new message is sent to any of these conversations, the callback is triggered with a `DecodedMessage` object. This keeps the inbox up to date by streaming in messages as they arrive.

By default, `streamAll` streams only conversations with a [consent state](/chat-apps/user-consent/user-consent#how-user-consent-preferences-are-set) of allowed or unknown.

We recommend streaming messages for allowed conversations only. This ensures that spammy conversations with a consent state of unknown don't take up networking resources. This also ensures that unwanted spam messages aren't stored in the user's local database.

To stream all conversations regardless of consent state, pass `[Allowed, Unknown, Denied]`.

:::warning[Important]

The stream is infinite. Therefore, any looping construct used with the stream won't terminate unless you explicitly initiate the termination. You can initiate the termination by breaking the loop or by making an external call to `return`.

:::

:::code-group

```js [Browser]
// stream all messages from conversations with a consent state of allowed
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    // Received a message
    console.log("New message:", message);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});
 
// Or use for-await loop
for await (const message of stream) {
  // Received a message
  console.log("New message:", message);
}
```

```js [Node]
// stream all messages from conversations with a consent state of allowed
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    // Received a message
    console.log("New message:", message);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Stream failed");
  }
});
 
// stream only group messages
const groupMessageStream = await client.conversations.streamAllGroupMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    console.log("New group message:", message);
  }
});
 
// stream only dm messages
const dmMessageStream = await client.conversations.streamAllDmMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    console.log("New DM message:", message);
  }
});
 
// Or use for-await loop
for await (const message of stream) {
  // Received a message
  console.log("New message:", message);
}
```

```tsx [React Native]
await alix.conversations.streamAllMessages(
  async (message: DecodedMessage<any>) => {
    // Received a message
  },
  { consentState: ["allowed"] }
);
```

```kotlin [Kotlin]
alix.conversations.streamAllMessages(type: /* OPTIONAL DMS, GROUPS, ALL */, consentState: listOf(ConsentState.ALLOWED)).collect {
  // Received a message
}
```

```swift [Swift]
for await message in try await alix.conversations.streamAllMessages(type: /* OPTIONAL .dms, .groups, .all */, consentState: [.allowed]) {
  // Received a message
}
```

:::

## Handle stream failures

:::warning
**Browser and Node SDK**

Streams will automatically attempt to reconnect if they fail. By default, a stream will attempt to reconnect up to 6 times with a 10 second delay between each retry. To change these defaults, use the `retryAttempts` and `retryDelay` options. To disable this feature, set the `retryOnFail` option to `false`. During the retry process, the `onRetry` and `onRestart` callbacks can be used to monitor progress.
:::

:::code-group

```ts [Node]
// disable automatic reconnects
const stream = await client.conversations.streamAllMessages({
  retryOnFail: false,
  onValue: (message) => {
    console.log("New message:", message);
  }
});

// use stream options with retry configuration
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  retryAttempts: 10,
  retryDelay: 20000, // 20 seconds
  onValue: (message) => {
    console.log("New message:", message);
  },
  onError: (error) => {
    console.error("Stream error:", error);
  },
  onFail: () => {
    console.log("Stream failed after retries");
  },
  onRestart: () => {
    console.log("Stream restarted");
  },
  onRetry: (attempt, maxAttempts) => {
    console.log(`Stream retry attempt ${attempt} of ${maxAttempts}`);
  },
});
```

```tsx [Browser]
// Browser SDK also supports stream retry options
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  retryAttempts: 5,
  retryDelay: 15000, // 15 seconds
  onValue: (message) => {
    console.log("New message:", message);
  },
  onError: (error) => {
    console.error("Stream error:", error);
  },
  onFail: () => {
    console.log("Stream failed after retries");
  },
  onRestart: () => {
    console.log("Stream restarted");
  },
  onRetry: (attempt, maxAttempts) => {
    console.log(`Stream retry attempt ${attempt} of ${maxAttempts}`);
  },
});
```

```tsx [React Native]
const [messages, setMessages] = useState<DecodedMessage[]>([]); 
 
  const messageCallback = async (message: DecodedMessage<any>) => { 
    setMessages(prev => [...prev, message]); 
  }
  const conversationFilterType: ConversationFilterType = 'all'
  const consentStates: ConsentState[] = ['allowed']
  const onCloseCallback = () => {
    console.log("Message stream closed, handle retries here")
  }

  const startMessageStream = async () => { 
    await alix.conversations.streamAllMessages( 
      messageCallback, 
      conversationFilterType, 
      consentStates, 
      onCloseCallback 
    ); 
  };
```

```kotlin [Kotlin]
    private val _messages = MutableStateFlow<List<DecodedMessage>>(emptyList())
    val messages: StateFlow<List<DecodedMessage>> = _messages.asStateFlow()

    fun startMessageStream() {
        viewModelScope.launch {
            streamMessages(onClose = {
                Log.d("XMTP ViewModel", "Message stream closed.")
            }).collect { decodedMessage ->
                _messages.update { current ->
                    current + decodedMessage
                }
            }
        }
}
```

```swift [Swift]
    @Published private(set) var messages: [DecodedMessage] = []

    private var streamTask: Task<Void, Never>? = nil

    func startMessageStream(from conversation: XMTPConversation) {
        streamTask?.cancel()

        streamTask = Task {
            do {
                for try await message in conversation.streamMessages(onClose: {
                    print("XMTP ViewModel: Message stream closed.")
                }) {
                    messages.append(message)
                }
            } catch {
                print("XMTP ViewModel: Stream failed with error \(error)")
            }
        }
    }

    func stopMessageStream() {
        streamTask?.cancel()
        streamTask = nil
    }
```

:::


## pages/chat-apps/push-notifs/android-pn.mdx
# Try push notifications with the Android example XMTP app

This guide describes how to set up push notifications for the [XMTP Android example app](https://github.com/xmtp/xmtp-android/tree/main/example) built with the [xmtp-android SDK](https://github.com/xmtp/xmtp-android) using Firebase Cloud Messaging (FCM) and a custom notification server.

Perform this setup to understand how you can enable push notifications for your own app built with the `xmtp-android` SDK.

## Set up a Firebase Cloud Messaging server

For this tutorial, we'll use [Firebase Cloud Messaging](https://console.firebase.google.com/) (FCM) as a convenient way to set up a messaging server.

1. Create an FCM project.

2. Add the example app to the FCM project. This generates a `google-services.json` file that you need in subsequent steps.

3. Add the `google-services.json` file to the example app's project as described in the FCM project creation process.

4. Generate FCM credentials, which you need to run the example notification server. To do this, from the FCM dashboard, click the gear icon next to **Project Overview** and select **Project settings**. Select **Service accounts**. Select **Go** and click **Generate new private key**.

## Run an example notification server

Now that you have an FCM server set up, take a look at the `kotlin` folder in the `example-notifications-server-go` repo.

These files can serve as the basis for what you might want to provide for your own notification server. This proto code from the example notification server has already been generated and added to the `xmtp-android` example app if you use the example notification server as-is.

**To run an example notification server:**

1. Clone the [example-notification-server-go](https://github.com/xmtp/example-notification-server-go) repo.

2. Complete the steps in [Local Setup](https://github.com/xmtp/example-notification-server-go/blob/np/export-kotlin-proto-code/README.md#local-setup).

3. Get the FCM project ID and the FCM credentials you created in step 4 of setting up FCM and run:

   ```bash [Bash]
   YOURFCMJSON=$(cat /path/to/FCMCredentials.json)
   ```

   ```bash [Bash]
   dev/run \
   --xmtp-listener-tls \
   --xmtp-listener \
   --api \
   -x "grpc.production.xmtp.network:443" \
   -d "postgres://postgres:xmtp@localhost:25432/postgres?sslmode=disable" \
   --fcm-enabled \
   --fcm-credentials-json=$YOURFCMJSON \
   --fcm-project-id="YOURFCMPROJECTID"
   ```

4. You should now be able to see push notifications coming across the local network.

## Update the example app to send push notifications

1. Add your `google-services.json` file to the `example` folder, if you haven't already done it as a part of the FCM project creation process.

2. Uncomment `id 'com.google.gms.google-services'` in the example app's `build.gradle` file.

3. Uncomment the following code in the top level of the example app's `build.gradle` file:

   ```groovy [Groovy]
   buildscript {
       repositories {
           google()
           mavenCentral()
       }
       dependencies {
           classpath 'com.google.gms:google-services:4.3.15'
       }
   }
   ```

4. Sync the Gradle project.

5. Add the example notification server address to the example app's `MainActivity`. In this case, it should be `PushNotificationTokenManager.init(this, "10.0.2.2:8080")`.

6. Change the example app's environment to `XMTPEnvironment.PRODUCTION` in `ClientManager.kt`.

7. Set up the example app to register the FCM token with the network and then subscribe each conversation to push notifications. For example:

   ```kotlin [Kotlin]
   XMTPPush(context, "10.0.2.2:8080").register(token)
   ```

   ```kotlin [Kotlin]
   val hmacKeysResult = ClientManager.client.conversations.getHmacKeys()
   val subscriptions = conversations.map {
       val hmacKeys = hmacKeysResult.hmacKeysMap
       val result = hmacKeys[it.topic]?.valuesList?.map { hmacKey ->
           Service.Subscription.HmacKey.newBuilder().also { sub_key ->
               sub_key.key = hmacKey.hmacKey
               sub_key.thirtyDayPeriodsSinceEpoch = hmacKey.thirtyDayPeriodsSinceEpoch
           }.build()
       }

       Service.Subscription.newBuilder().also { sub ->
           sub.addAllHmacKeys(result)
           sub.topic = it.topic
           sub.isSilent = it.version == Conversation.Version.V1
       }.build()
   }

   XMTPPush(context, "10.0.2.2:8080").subscribeWithMetadata(subscriptions)
   ```

   ```kotlin [Kotlin]
   XMTPPush(context, "10.0.2.2:8080").unsubscribe(conversations.map { it.topic })
   ```

## Decode a notification envelope

You can decode a single `Envelope` from XMTP using the `decode` method:

```kotlin [Kotlin]
val conversation =
    client.conversations.newConversation("0x3F11b27F323b62B159D2642964fa27C46C841897")

// Assume this function returns an Envelope that contains a message for the above conversation
val envelope = getEnvelopeFromXMTP()

val decodedMessage = conversation.decode(envelope)
```


## pages/chat-apps/push-notifs/pn-server.mdx
# Run a push notification server for an app built with XMTP

This guide supplements the [core instructions](https://github.com/xmtp/example-notification-server-go/blob/np/export-kotlin-proto-code/README.md#local-setup) provided in the `example-notification-server-go` repository. The guide aims to address some common setup misconceptions and issues.

This guide is for macOS users, but the steps should be similar for Linux users.

## Useful resources

- [Notification server example implementation](https://github.com/xmtp/example-notification-server-go)
- [Notification server integration test suite](https://github.com/xmtp/example-notification-server-go/blob/main/integration/README.md)

## Install Docker

1. Install Docker Desktop:

   - [Mac](https://docs.docker.com/docker-for-mac/install/)
   - [Windows](https://docs.docker.com/docker-for-windows/install/)
   - [Linux](https://docs.docker.com/desktop/install/linux-install/)

2. You must also have Docker and Docker Compose installed on your system. You can install them using Homebrew:

   ```bash [Bash]
   brew install docker docker-compose docker-credential-desktop
   ```

3. Make sure Docker Desktop is running by searching for Docker in Spotlight and opening the application. You don't need to interact with the Docker UI. We're going to use terminal commands only.

## Install Go

If you need to upgrade Go on your system, you can do it via Homebrew:

```bash [Bash]
brew install go
```

If you encounter an error like `Error: go 1.17.2 is already installed`, you already have Go installed on your system.

You can check the version of Go installed on your system using:

```bash [Bash]
brew update
brew upgrade go
```

After following these steps, you can update Homebrew and upgrade Go without issues.

## Set up the server

1. To start the XMTP service and database, navigate to the project terminal and run:

   ```bash [Bash]
   ./dev/up
   ```

   ![set up the server](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/cmd1.png)

   If you encounter an error like `error getting credentials - err: docker-credential-desktop resolves to executable in current directory (./docker-credential-desktop), out:`, it's likely because Docker is not running. Make sure Docker Desktop is running and try the command again.

2. Build the server using:

   ```bash [Bash]
   ./dev/build
   ```

   During the build, if you encounter any Go-related errors like missing `go.sum` entries, use the suggested `go get` or `go mod download` commands in the error messages to resolve them. For example, if you see `missing go.sum entry; to add it: go mod download golang.org/x/sys`, run:

   ```bash [Bash]
   go mod download golang.org/x/sys
   ```

   If you encounter errors related to Go build comments like `//go:build comment without // +build comment`, you can ignore them as they are warnings about future deprecations and won't prevent your code from running.

## Run the server

Run the server using the `./dev/run` script with the `--xmtp-listener` and `--api` flags:

```bash [Bash]
./dev/up
```

![./dev/up in CLI](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/cmd2.png)

```bash [Bash]
source .env
./dev/run --xmtp-listener --api
```

This starts both the `worker` and `api` services. The `worker` listens for new messages on the XMTP network and sends push notifications. The `api` service handles HTTP/GRPC requests.

![./dev/run --xmtp-listener --api in CLI](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/cmd3.png)

You can now send notifications to your device using an [XMTP push notification client](https://github.com/xmtp/example-notification-server-go/blob/main/docs/notifications-client-guide.md).

![dev/run in CLI](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/cmd4.png)

## Troubleshooting

- If Docker or Docker Compose commands aren't recognized, it might mean that they aren't installed or their executable paths aren't included in your system's PATH variable. Make sure Docker and Docker Compose are installed and their paths are included in your system's PATH.

- If you encounter Go-related errors during the build, it's often due to missing packages or outdated versions. Make sure your Go is up to date and use the `go get` or `go mod download` commands to fetch the necessary dependencies.

- If you encounter any error like `./dev/up: line 3: docker-compose: command not found`, it's because you don't have Docker Compose installed on your system. Use the above command to install it.

- If you see warnings about `//go:build comment without // +build comment`, these are warnings about future deprecations in Go. They won't prevent your code from running and can be ignored.

- If `brew update` gives errors, it might be due to changes in Homebrew's repository. Homebrew switched to using `main` as its default branch. The steps provided in the "Upgrading Go" section should help resolve this issue.

- If you encounter any errors during `brew update`, such as `fatal: couldn't find remote ref refs/heads/master`, Homebrew is having trouble updating its repositories. To fix this, run:

  ```bash [Bash]
  cd $(brew --repository)
  git checkout main
  git reset --hard origin/main
  ```

- Here is a piece of code that points to the ports and network. Be sure to use TLS like this `./dev/run --xmtp-listener-tls --api`.

   :::code-group

   ```tsx [Browser]
   export const ApiUrls = {
   local: "http://localhost:5555",
   dev: "https://dev.xmtp.network",
   production: "https://production.xmtp.network",
   } as const;

   export const HistorySyncUrls = {
   local: "http://localhost:5558",
   dev: "https://message-history.dev.ephemera.network",
   production: "https://message-history.production.ephemera.network",
   } as const;
   ```

   ```tsx [Node]
   export const ApiUrls = {
   local: "http://localhost:5556",
   dev: "https://grpc.dev.xmtp.network:443",
   production: "https://grpc.production.xmtp.network:443",
   } as const;
   ```

   ```tsx [React Native]
   const ApiUrls = {
   local: 'http://localhost:5556',
   dev: 'https://grpc.dev.xmtp.network:443',
   production: 'https://grpc.production.xmtp.network:443'
   }
   ```

   ```kotlin [Kotlin]
   enum ApiUrls {
      static let local = "http://localhost:5556"
      static let dev = "https://grpc.dev.xmtp.network:443"
      static let production = "https://grpc.production.xmtp.network:443"
   }
   ```

   ```swift [Swift]
   object ApiUrls {
      const val local = "http://localhost:5556"
      const val dev = "https://grpc.dev.xmtp.network:443"
      const val production = "https://grpc.production.xmtp.network:443"
   }
   ```

   :::


## pages/chat-apps/push-notifs/ios-pn.mdx
# Try push notifications with the iOS example XMTP app

This guide describes how to set up push notifications for the [XMTP iOS example app](https://github.com/xmtp/xmtp-ios/tree/main/XMTPiOSExample) built with the [xmtp-ios SDK](https://github.com/xmtp/xmtp-ios) using Firebase Cloud Messaging (FCM) and a custom notification server.

Perform this setup to understand how you can enable push notifications for your own app built with the `xmtp-ios` SDK.

## Prerequisites

- An iOS device for testing. Push notifications don't work on simulators
- A Firebase account and a project set up in the Firebase console

## Set up Firebase Cloud Messaging

For this tutorial, we'll use [Firebase Cloud Messaging](https://console.firebase.google.com/) (FCM) as a convenient way to set up a messaging server.

1. Create an FCM project  
Go to the [Firebase Console](https://console.firebase.google.com/), create a new project, and follow the setup instructions.

2. Add your app to the FCM project  
Add your iOS app to the project by following the Firebase setup workflow. You'll need your app's bundle ID.

3. Download `GoogleService-Info.plist`  
At the end of the setup, download the `GoogleService-Info.plist` file and add it to your Xcode project.

4. Generate FCM credentials  
In the Firebase console, navigate to your project settings, select the **Cloud Messaging** tab, and note your server key and sender ID. You'll need these for your notification server.

## Configure the iOS example app for push notifications

1. Enable push notifications  
In Xcode, go to your project's target capabilities and enable push notifications.

2. Register for notifications  
Modify the `AppDelegate` to register for remote notifications and handle the device token.

3. Handle incoming notifications  
Implement the necessary delegate methods to handle incoming notifications and foreground notification display.

## Run the notification server

1. Clone and configure the notification server  
If you're using the example notification server, clone the repository and follow the setup instructions. Make sure to configure it with your FCM server key.

2. Run the server  
Start the server locally or deploy it to a hosting service.

- Subscribe to push notifications in the app  
  When initializing the XMTP client in your app, subscribe to push notifications using the device token obtained during registration.

- Decode a notification envelope  
When you receive a push notification, you may want to decode the notification envelope to display a message preview or other information.


## pages/chat-apps/push-notifs/push-notifs.mdx
# Support push notifications

With XMTP, you can enable real-time push notifications to keep users updated on new conversations and messages.

## Get a Welcome message topic ID

Get the topic identifier for an app installation. This topic ID tells your app where to listen on the network for push notifications about any new group chat or DM conversations.

:::code-group

```tsx [React Native]
// Request
alix.welcomeTopic()

// Response
/xmtp/mls/1/w-$installationId/proto
```

```kotlin [Kotlin]
// Request
Topic.userWelcome(client.installationId).description

// Response
/xmtp/mls/1/w-$installationId/proto
```

```swift [Swift]
// Request
Topic.userWelcome(client.installationId).description

// Response
/xmtp/mls/1/w-$installationId/proto
```

:::

## Get a message topic ID

Get the topic identifier for a group chat or DM conversation that's already in progress. This topic ID tells your app where to listen on the network for push notifications about any new messages in a specific group chat or DM conversation.

:::code-group

```tsx [React Native]
// Request
conversation.topic

// Response
/xmtp/mls/1/g-$conversationId/proto
```

```kotlin [Kotlin]
// Request
conversation.topic

// Response
/xmtp/mls/1/g-$conversationId/proto
```

```swift [Swift]
// Request
conversation.topic

// Response
/xmtp/mls/1/g-$conversationId/proto
```

:::

## List push topics for a DM conversation

Lists topics for a specific DM conversation.

:::code-group

```tsx [React Native]
conversation.getPushTopics()
```

```kotlin [Kotlin]
conversation.getPushTopics()
```

```swift [Swift]
conversation.getPushTopics()
```

:::

## List push topics for all conversations

Lists topics for all group chat and DM conversations, including duplicate DM conversations.

Duplicate DM conversations can occur when a user creates new conversations with the same contact from different installations or devices. While DM stitching automatically combines these conversations into a single view for users, each duplicate conversation maintains its own push notification topic. Ensure that users receive push notifications for messages sent through any of the stitched conversations, even as the system gradually consolidates them into a single conversation.

To learn more, see [Understand DM stitching and push notifications](/chat-apps/push-notifs/understand-push-notifs#understand-dm-stitching-and-push-notifications).

:::code-group

```tsx [React Native]
conversations.allPushTopics()
```

```kotlin [Kotlin]
conversations.allPushTopics()
```

```swift [Swift]
conversations.allPushTopics()
```

:::

## Subscribe to topics

Subscribe to all relevant topics, allowing your app to monitor for push notifications about both new and ongoing conversations.

This code sample retrieves all topics associated with `alix`'s conversations, for example, enabling the app to receive push notifications only for conversations in which `alix` is a part of.

:::code-group

```tsx [React Native]
const conversations = await alix.conversations.list();
const topics = conversations.map((conv: any) => conv.topic);

await subscribeAll([alix.welcomeTopic(), ...topics]);
```

```kotlin [Kotlin]
val conversations = alix.conversations.list()
val topics = conversations.map { it.topic }.toMutableList()

subscribeAll(topics.push(Topic.userWelcome(client.installationId).description))
```

```swift [Swift]
let conversations = try await alix.conversations.list()
var topics = conversations.map { $0.topic }

subscribeAll(topics.append(Topic.userWelcome(client.installationId).description))```

:::

## Receive push notifications

On receipt of a push notification, decode it:

:::code-group

```tsx [React Native]
const receivedBytes = Buffer.from(received.message, "base64").toString("utf-8");
```

```kotlin [Kotlin]
val encryptedMessage = remoteMessage.data["encryptedMessage"]
val encryptedMessageData = Base64.decode(encryptedMessage, Base64.NO_WRAP)
```

```swift [Swift]
let encryptedMessage = remoteMessage.data["encryptedMessage"]
let encryptedMessageData =  Data(base64Encoded: encryptedMessage)
```

:::

Then determine whether it's for a new conversation or an existing one.

- **If it's a Welcome message for a new conversation** (`alix.welcomeTopic() == received.topic`), initiate the conversation with `fromWelcome`:

  :::code-group

  ```tsx [React Native]
  const conversation = await alix.conversations.fromWelcome(
    receivedBytes
  );
  ```

  ```kotlin [Kotlin]
  val conversation = alix.conversations.fromWelcome(receivedBytes)
  ```

  ```swift [Swift]
  let conversation = try await alix.conversations.fromWelcome(receivedBytes)
  ```

  :::

- **If it's a message for an existing conversation**, find the corresponding topic, sync the conversation, and process the new message:

  :::code-group

  ```tsx [React Native]
  const conversation = await alix.findConversationByTopic(received.topic);
  await conversation.sync();
  const message = await conversation.processMessage(receivedBytes);
  ```

  ```kotlin [Kotlin]
  val conversation = alix.findConversationByTopic(received.topic)
  conversation.sync()
  val message = conversation.processMessage(receivedBytes)
  ```

  ```swift [Swift]
  let conversation = try alix.findConversationByTopic(received.topic)
  try await conversation.sync()
  let message = try await conversation.processMessage(receivedBytes)
  ```

  :::

## Stream HMAC key update events

Use `preferences.stream` to listen for events that indicate when a new HMAC key has been added, typically due to a new installation joining the network. This stream does not provide the actual HMAC keys but notifies you to refresh your HMAC keys accordingly by resubscribing to topics.

This is particularly useful for ensuring that push notifications work correctly across all installations by not missing updates from new installations.

:::code-group

```tsx [React Native]
await alix.preferences.stream((event: any) => {
  // Received a preference update event
  // Check if it indicates a new HMAC key and resubscribe if necessary
});
```

```kotlin [Kotlin]
alix.preferences.stream().collect { event ->
  // Received a preference update event
}
```

```swift [Swift]
for await event in try await alix.preferences.stream() {
  // Received a preference update event
}
```

:::

## Resubscribe to topics to get new HMAC keys

As soon as your app receives a user preference update event from [preferences.sync](/chat-apps/list-stream-sync/sync-preferences) or [preferences.stream](#stream-hmac-key-update-events) indicating new HMAC keys for a user, resubscribe to topics to get the new HMAC keys. For example:

```kotlin [Kotlin]
conversations.allTopics.forEach { -> topic
val hmacKeysResult = conversations.getHmacKeys()
val hmacKeys = hmacKeysResult.hmacKeysMap
val result = hmacKeys[topic]?.valuesList?.map { hmacKey ->
    Service.Subscription.HmacKey.newBuilder().also { sub_key ->
        sub_key.key = hmacKey.hmacKey
        sub_key.thirtyDayPeriodsSinceEpoch = hmacKey.thirtyDayPeriodsSinceEpoch
    }.build()
}

val subscription = Service.Subscription.newBuilder().also { sub ->
    sub.addAllHmacKeys(result)
    sub.topic = topic
    sub.isSilent = false
}.build()
}

PushNotificationTokenManager.xmtpPush.subscribeWithMetadata(subscription)
```

This ensures that older installations (or your XMTP push notification server code) now know about and resubscribe to all conversations for all of the new HMAC keys.

## Get HMAC keys for a conversation

Gets the HMAC keys for a specific group chat or DM conversation.

For DM conversations, the response includes HMAC keys for all topics associated with the conversation. This is necessary because a single DM conversation can have multiple underlying topics due to DM stitching, where multiple conversations between the same participants are combined into one view.

For example, if Alix and Bo have a conversation that was created from two different installations, there might be two topics (`topic1` and `topic2`) for what appears as a single conversation to the user. The response will include HMAC keys for both topics to ensure push notifications work correctly regardless of which topic the message was sent through.

To learn more, see [Understand DM stitching and push notifications](/chat-apps/push-notifs/understand-push-notifs#understand-dm-stitching-and-push-notifications).

:::code-group

```tsx [React Native]
conversation.getHmacKeys()
```

```kotlin [Kotlin]
conversation.getHmacKeys()
```

```swift [Swift]
conversation.getHmacKeys()
```

:::

## Run a push notification server

To implement push notifications in your app, you must run a push notification server. This server acts as an intermediary between the XMTP network and your app's push notification service, ensuring that users receive timely and relevant notifications.

### Why is a push notification server required?

- **Continuous monitoring**: The XMTP network operates on a decentralized protocol, where messages are exchanged directly between clients. However, for push notifications, your app needs a dedicated server to continuously listen for new messages or events on the XMTP network, even when the user's device is offline or the app is not running.
- **Message processing**: Upon detecting new messages or events, the server processes them to determine their relevance and formats them appropriately for push notifications. This includes extracting necessary information, such as the sender's identity and message content, to craft meaningful notifications.
- **Integration with push notification services**: The server interfaces with platform-specific push notification services, like [Apple Push Notification Service](/chat-apps/push-notifs/understand-push-notifs#best-practices-for-apple-push-notifications) (APNs) for iOS or Firebase Cloud Messaging (FCM) for Android. It sends the processed notifications to these services, which then deliver them to the user's device.

To learn more about running a push notification server, see [Understand push notifications with XMTP](/chat-apps/push-notifs/understand-push-notifs).

Then you can:

- [Set up a Go push notification server](/chat-apps/push-notifs/pn-server)
- [Try push notifications with the Android example XMTP app](/chat-apps/push-notifs/android-pn)
- [Try push notifications with the iOS example XMTP app](/chat-apps/push-notifs/ios-pn)


## pages/chat-apps/push-notifs/understand-push-notifs.mdx
# Understand push notifications with XMTP

With XMTP, you can enable real-time push notifications to keep users updated on new conversations and messages.

At the highest level, push notifications with XMTP require these three elements:

1. An **XMTP push notification server** that listens for all messages sent on the XMTP network. You set the server to listen to the`production`, `dev`, or `local` environment, and every message sent using that environment flows through the server. The server filters the messages accordingly and sends only the desired push notifications to a push notification service.

2. A **push notification service**, such as Apple Push Notification service (APNs), Firebase Cloud Messaging (FCM), or W3C Web Push protocol, receives push notifications from the XMTP push notification server.

3. An **app** that displays the push notifications.

![Push notifications framework](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/pn-framework.png)

## Understand message filtering

Let's dive deeper into how the XMTP push notification server filters messages to determine which ones to send to the push notification service.

![XMTP push notification server filtering flow](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/pn-server-filtering.png)

1. **Check if the server is subscribed to the message's topic**
    - A topic is a way to organize messages, and each message has a topic. To support push notifications, your app must [subscribe the server to the topics](https://docs.xmtp.org/chat-apps/push-notifs/push-notifs#subscribe-to-topics) that are relevant to your users. For example, for a user Alix, you must subscribe to all topics associated with Alix's conversations. The XMTP push notification server has a list of these subscriptions. Your push notification server should expose functions to post the subscriptions to. The SDKs use protobufs as a universal language that allows the creation of these functions in any language. For example, [here are bufs](https://github.com/xmtp/xmtp-android/tree/main/library/src/main/java/org/xmtp/android/library/push) generated from the [XMTP example push notification server](/chat-apps/push-notifs/pn-server). You can use these directly if you clone and use the example server.
    - If the arriving message's topic is **not on the list**, the server ignores it.
    - If the arriving message's topic is **on the list**, the server proceeds to check the message with the next filter.
2. **Check the `shouldPush` field value**
    - Each [content type](/chat-apps/content-types/content-types), such as text, attachment, or reply, can have
    - A `shouldPush` boolean value is set at the content type level for each content type, such as text, attachment, or reply, so it can't be overwritten on send. By default, this value is set to ***true*** for all content types except read receipts and reactions.
    - If the message's content type `shouldPush` value is ***false***, the server ignores the message.
    - If the message's content type `shouldPush` value is ***true***, the server proceeds to check the message with the next filter.
3. **Check the message's HMAC key**
    - Each message sent with XMTP carries a single HMAC key. This key is updated with the encrypted message payload before being sent out.
    - If the message is signed by an HMAC key that **matches** the user's HMAC key, the push notification server ignores the message. This match means that the message was sent by the user themself, and they should not receive a push notification about a message they sent.
    - If the message is signed by an HMAC key that **does not match** the user's HMAC key, this means someone else sent the message and the user should be notified about it. At this point, the push notification server will send a notification.
4. **Send to the push notification service**
    - The server sends the message to the push notification service.
    - Once the push notification service has the message, it can format it appropriately for the push notification. This includes extracting necessary information, such as the sender's identity and message content, to craft meaningful notifications. This is only possible with the push notifications service inside the app and not with the push notification server because the server doesn't have the notion of a client and, therefore, can't decrypt the message.

XMTP provides an example XMTP push notification server that implements the filtering described here. To learn more, see [Run a push notification server for an app built with XMTP](/chat-apps/push-notifs/pn-server).

## Understand sending push notifications

The XMTP push notification server sends qualified messages to the appropriate push notification service:

- Apple Push Notification service (APNs) for iOS apps
- Firebase Cloud Messaging (FCM) for Android apps
- W3C Web Push protocol for web apps

### Best practices for Apple push notifications

While we recommend that you do message filtering at the XMTP push notification server level, if you build an iOS app with XMTP, you can choose to use the [com.apple.developer.usernotifications.filtering](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_usernotifications_filtering) entitlement instead. This entitlement enables you to run a Notification Service Extension in your app that can decrypt and modify a notification before displaying it to a user.

To use this entitlement, you must obtain permission from Apple. Submit the application using the app owner's Apple developer account via [https://developer.apple.com/contact/request/notification-service](https://developer.apple.com/contact/request/notification-service).

:::warning

Keep in mind that it may be difficult to obtain permission for the `com.apple.developer.usernotifications.filtering` entitlement from Apple if your app handles cryptocurrency or could be perceived—even loosely—as a crypto wallet. While Apple hasn't publicly stated an explicit policy, developers have anecdotally reported challenges in this area. If you don't receive the entitlement, you can always perform the message filtering using the XMTP push notification server.

:::

**Submit your application early**
The approval process can take 2-3 weeks or longer.

Here are some sample answers to help you complete the application:

- **App name:** [Your app name]
- **App Store URL:** [Your app store URL]
- **Apple ID of App:** [Your app ID]
- **App Type:** Messaging
- **Does your app provide end-to-end encryption?:** Yes
- **Explain why existing APIs are not adequate for your app:** The existing APIs always show some sort of notification when a push comes in. We don't want to show a notification for a user's own messages.
- **Explain why your app doesn't show a visible notification each time a push notification is received:** The server delivering notifications only knows of the existence of a conversation. It does not know who the sender or recipient is. That data is decoded on the device in the extension. As a result, it sends a push notification for every message that occurs in the conversation. We want to filter out notifications for notifications that the user themself sent.
- **When your extension runs, what system and network resources does it need:** We might need to make a gRPC request to load additional information about a conversation. This is only necessary when we haven't stored the conversation details locally, which is expected to be less common than being able to just decrypt the conversation locally. For example, we might have a scenario in which a welcome message is pushed before it's streamed.
- **How often does your extension run? What can trigger it to run:** The extension will run whenever a message is sent or received in a conversation. The frequency will depend on how active a user is.

## Understand displaying push notifications

After the push notification service sends the notification, the app must [receive it](/chat-apps/push-notifs/push-notifs#receive-push-notifications).

There are some nuances to how push notifications can be handled once received by the app. While it is useful for all of these app types to use the XMTP push notification server filtering capabilities, it is especially important for an iOS app without the user notification entitlement.

|  | Can decrypt before displaying? |
| --- | --- |
| Android and web apps | Yes |
| iOS app with user notification entitlement | Yes |
| iOS app without user notification entitlement | No |

- If the app **can** **decrypt** the push notification before displaying it to the user, it can perform additional logic (should I display this?) before displaying the push notification. For example, the app can decrypt the push notification, see the topic type, and process it accordingly:
  - Is the message in a welcome topic?
    - `conversations.processWelcomeMessage`
  - Is the message in a conversation topic?
    - `conversation.processMessage`
- If the app **cannot** **decrypt** the push notification before displaying it to the user, it can't perform additional logic (should I display this?) before displaying the push notification.

    For example, without the user notification entitlement, the app cannot decrypt and modify the push notification before displaying it to the user. The notification arrives on the device, and iOS handles displaying it automatically. You can decrypt the content after the notification is shown, but you cannot intercept it before display and decide not to show it, for example.

## Understand HMAC keys and push notifications

XMTP uses Hash-based Message Authentication Code (HMAC) keys for push notifications. A user holds the HMAC keys for any conversation they join, but an outside observer only sees the keys without knowing who owns them. For instance, suppose Alix has HMAC key #1, and we also see HMAC keys #2 and #3. If Alix discloses that they hold key #1, then we know key #1 belongs to them. However, we have no way of knowing who holds keys #2 or #3 unless those individuals reveal that information. This design preserves privacy while enabling secure communication.

The HMAC key is derived from a generated root HMAC key, the message's group ID, and the number of 30-day periods since the Unix epoch, along with some salt. Anytime a user gets a new installation, they get new HMAC keys for it. In this case, how do the user's older installations learn about the user's new installation HMAC key so they can properly decrypt and route certain messages and push notifications for that newly added installation?

This is one of the jobs of the [history sync](/chat-apps/list-stream-sync/history-sync) feature. It listens for `preferences.streamAllPreferenceUpdates()`, which are user preferences that may include an enum with HMAC keys for new installations. When a user's new installation publishes updated HMAC info, older installations can see that update and must [resubscribe to topics](/chat-apps/push-notifs/push-notifs#resubscribe-to-topics-to-get-new-hmac-keys) to get the new HMAC keys.

## Understand DM stitching and push notifications

🎥 walkthrough: DM stitching

This video provides a walkthrough of direct message (DM) stitching, covering the key ideas discussed in this section. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/YF5m_mTY6mw?si=EH0S4eP0GPEAafIw" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

Consider a scenario where `alix.id` using an existing installation #1 to create a conversation with `bo.id` and sends them a DM. And then `alix.id` creates a new installation #2, and instead of waiting for [history sync](https://docs.xmtp.org/chat-apps/list-stream-sync/history-sync) to bring in their existing conversations, `alix.id` creates a new conversation with `bo.id` and sends them a DM. Under the hood, this results in two DM conversations (or two MLS groups) with the same pair of identities, `alix.id` and `bo.id`, resulting in a confusing DM UX like this one:

![No DM stitching](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/no-dm-stitching.png)

XMTP implements DM stitching to ensure that even if there are multiple DMs with the same pair of identities under the hood, your users see only one DM conversation with messages displayed appropriately.

For example, with DM stitching, instead of seeing two separate DM conversations between `alix.id` and `bo.id` with one message each, `alix.id` sees one DM conversation between `alix.id` and `bo.id` with two messages in both installations #1 and #2

![With DM stitching](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/with-dm-stitching.png)

### How DM stitching works

1. When fetching messages from any of the MLS groups associated with a DM conversation, the XMTP SDK responds with messages from all of the groups associated with the DM conversation.
    - For example, let's say you have three MLS groups associated with a DM conversation:
        - alix-bo-1
        - alix-bo-2
        - alix-bo-3

        Any messages sent in any of these DM conversations will display in all of these DM conversations.

        For example, `alix.id` sends a message in alix-bo-1. `bo.id` is on alix-bo-3, but can still see messages sent in alix-bo-1.

2. When sending messages in a DM conversation, all installations in that DM will eventually converge to sending them to the same MLS group, even if they originally start off using different ones.
    - For example, `bo.id` sends a message in alix-bo-3. `alix.id` is on alix-bo-1, but can still see messages from alix-bo-3. When `alix.id` sends a reply to `bo.id`, it uses the most recently used DM conversation, alix-bo-3. In this way, all messaging will eventually move to alix-bo-3, and 1 and 2 will slowly fade away due to non-use.

### DM stitching considerations for push notifications

DM stitching provides a unified UX in the app. However, the multiple DM conversations under the hood must still be addressed for push notifications.

Let's take DM conversations alix-bo-1 and alix-bo-3 between `alix.id` and `bo.id`. With DM stitching, these two conversations display as one conversation. However, we must remember that they have two different conversation IDs, and thus two different topics.

Therefore, when subscribing a DM conversations to push notifications, you should subscribe to a list of topics because every DM conversation can potentially have multiple topics. You will miss push notifications for messages if you are not listening to every potential topic for a DM conversation that messages could potentially be sent on.

For example, you must consider that with DM stitching, the conversation is moving from alix-bo-1 and alix-bo-3, for example, and [resubscribe appropriately](/chat-apps/push-notifs/push-notifs#resubscribe-to-topics-to-get-new-hmac-keys).

Also, you must consider that a welcome message will be sent when a DM conversation is added to the stitched DMs, and you should not send a push for the welcome message because the user already has a conversation with the person. It is just a different DM conversation in the set of DM conversations that are stitched together. These welcome messages are filtered out of streams, but they are not filtered out for the XMTP push notification server, so you must handle these duplicate DM welcomes at the push notification service.


## pages/chat-apps/sdks/node.mdx
# Get started with the XMTP Node SDK

Use the [XMTP Node SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/node-sdk) to build agents and other server-side applications that interact with the XMTP network.

:::tip[🤖 Building an agent?]

For building AI agents, use the [Build an agent with XMTP](/agents/get-started/build-an-agent) tutorial tailored to this use case.

:::

For all other server-side applications, including backends for chat apps, follow the get started guide below, which provides some quickstart code, as well as a map to building a [secure chat app](/protocol/security) with XMTP, including support for:

- End-to-end encrypted direct message and group chat conversations
- Rich content types (attachments, reactions, replies, and more)
- Spam-free chats using user consent preferences

## Quickstart

```tsx [Node]
// 1. Create an EOA or SCW signer.
// Details depend on your app's wallet implementation.
import type { Signer, Identifier, IdentifierKind } from "@xmtp/node-sdk";

const signer: Signer = {
  type: "EOA",
  getIdentifier: () => ({
    identifier: "0x...", // Ethereum address as the identifier
    identifierKind: IdentifierKind.Ethereum
  }),
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};

// 2. Create the XMTP client
import { Client } from "@xmtp/node-sdk";
import { getRandomValues } from "node:crypto";

const dbEncryptionKey = getRandomValues(new Uint8Array(32));
const client = await Client.create(signer, { dbEncryptionKey });

// 3. Start a new conversation
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);

// 4. Send messages
await group.send("Hello everyone");

// 5. List, stream, and sync
// List existing conversations
const allConversations = await client.conversations.list({ consentStates: [ConsentState.Allowed] });
// Stream new messages
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    console.log("New message:", message);
  },
  onError: (error) => {
    console.error(error);
  }
});

// Or use for-await loop
for await (const message of stream) {
  // Received a message
  console.log("New message:", message);
}
// Sync all new welcomes, preference updates, conversations,
// and messages from allowed conversations 
await client.conversations.syncAll(["allowed"]);
```


## pages/chat-apps/sdks/browser.mdx
# Get started with the XMTP Browser SDK

Use the [XMTP Browser SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/browser-sdk) to build web-based apps, tools, and experiences with secure, private, and decentralized messaging.

The guide provides some quickstart code, as well as a map to building a [secure chat app](/protocol/security) with XMTP, including support for:

- End-to-end encrypted direct message and group chat conversations
- Rich content types (attachments, reactions, replies, and more)
- Spam-free chats using user consent preferences

## Quickstart

```tsx [Browser]
// 1. Create an EOA or SCW signer.
// Details depend on your app's wallet implementation.
import type { Signer, Identifier } from "@xmtp/browser-sdk";

const signer: Signer = {
  type: "EOA",
  getIdentifier: () => ({
    identifier: "0x...", // Ethereum address as the identifier
    identifierKind: "Ethereum"
  }),
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  }
};

// 2. Create the XMTP client
import { Client } from "@xmtp/browser-sdk";
const client = await Client.create(signer, {
  // Note: dbEncryptionKey is not used for encryption in browser environments
});

// 3. Start conversations
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);

// 4. Send messages
await group.send("Hello everyone");

// 5. List, stream, and sync
// List existing conversations
const allConversations = await client.conversations.list({ consentStates: [ConsentState.Allowed] });
const allGroups = await client.conversations.listGroups({ consentStates: [ConsentState.Allowed] });
const allDms = await client.conversations.listDms({ consentStates: [ConsentState.Allowed] });
// Stream new messages
const stream = await client.conversations.streamAllMessages({
  consentStates: [ConsentState.Allowed],
  onValue: (message) => {
    console.log("New message:", message);
  },
  onError: (error) => {
    console.error(error);
  }
});

// Or use for-await loop
for await (const message of stream) {
  console.log("New message:", message);
}
// Sync all new welcomes, preference updates, conversations,
// and messages from allowed conversations 
await client.conversations.syncAll(["allowed"]);
```


## pages/chat-apps/sdks/ios.mdx
# Get started with the XMTP iOS SDK

Use the [XMTP iOS SDK](https://github.com/xmtp/xmtp-ios) to build secure, private, and decentralized messaging into your iOS app.

The guide provides some quickstart code, as well as a map to building a [secure chat app](/protocol/security) with XMTP, including support for:

- End-to-end encrypted direct message and group chat conversations
- Rich content types (attachments, reactions, replies, and more)
- Spam-free chats using user consent preferences

## Quickstart

```swift [Swift]
// 1. Create an EOA or SCW signer
// Details depend on your app's wallet implementation.
public struct EOAWallet: SigningKey {
    public var identity: PublicIdentity {
        return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
    }
    public var type: SignerType { .EOA }
    public func sign(message: String) async throws -> SignedData {
        return SignedData(try await key.sign(message: message))
    }
}

// 2. Create the XMTP client
let client = try await Client.create(
    account: SigningKey,
    options: ClientOptions.init(
        api: .init(env: .production, isSecure: true),
        dbEncryptionKey: keyBytes // 32 bytes
    )
)

// 3. Start conversations
let group = try await client.conversations.newGroup([bo.inboxId, caro.inboxId])
let groupWithMeta = try await client.conversations.newGroup([bo.inboxId, caro.inboxId],
    permissionLevel: .admin_only,
    name: "The Group Name",
    imageUrl: "www.groupImage.com",
    description: "The description of the group"
)

// 4. Send messages
let dm = try await client.conversations.findOrCreateDm(with: recipientInboxId)
try await dm.send(content: "Hello world")
try await group.send(content: "Hello everyone")

// 5. List, stream, and sync
// List existing conversations
let conversations = try await client.conversations.list()
let filteredConversations = try await client.conversations.list(consentState: .allowed)
// Stream new messages
for await message in try await client.conversations.streamAllMessages(type: /* OPTIONAL .dms, .groups, .all */, consentState: [.allowed]) {
    // Received a message
}
// Sync all new welcomes, preference updates, conversations,
// and messages from allowed conversations 
try await client.conversations.syncAllConversations(consentState: [.allowed])
```


## pages/chat-apps/sdks/android.mdx
# Get started with the XMTP Android SDK

Use the [XMTP Android SDK](https://github.com/xmtp/xmtp-android) to build secure, private, and decentralized messaging into your Android app.

The guide provides some quickstart code, as well as a map to building a [secure chat app](/protocol/security) with XMTP, including support for:

- End-to-end encrypted direct message and group chat conversations
- Rich content types (attachments, reactions, replies, and more)
- Spam-free chats using user consent preferences

## Quickstart

```kotlin [Kotlin]
// 1. Create an EOA or SCW signer.
// Details depend on your app's wallet implementation.
class EOAWallet : SigningKey {
    override val publicIdentity: PublicIdentity
        get() = PublicIdentity(IdentityKind.ETHEREUM, key.publicAddress)
    override val type: SignerType
        get() = SignerType.EOA
    override suspend fun sign(message: String): SignedData {
        return SignedData(key.sign(message = message))
    }
}

// 2. Create the XMTP client
val client = Client.create(
    account = SigningKey,
    options = ClientOptions(
        ClientOptions.Api(XMTPEnvironment.PRODUCTION, true),
        appContext = ApplicationContext(),
        dbEncryptionKey = keyBytes // 32 bytes
    )
)

// 3. Start conversations
val group = client.conversations.newGroup(inboxIds = listOf(bo.inboxId, caro.inboxId))
val groupWithMeta = client.conversations.newGroup(
    inboxIds = listOf(bo.inboxId, caro.inboxId),
    permissionLevel = GroupPermissionPreconfiguration.ALL_MEMBERS,
    name = "The Group Name",
    imageUrl = "www.groupImage.com",
    description = "The description of the group"
)

// 4. Send messages
val dm = client.conversations.findOrCreateDm(recipientInboxId)
dm.send(text = "Hello world")
group.send(text = "Hello everyone")

// 5. List, stream, and sync
// List existing conversations
val conversations = client.conversations.list()
val filteredConversations = client.conversations.list(consentState = ConsentState.ALLOWED)
// Stream all new conversations and new messages from allowed conversations
client.conversations.streamAllMessages(consentStates = listOf(ConsentState.ALLOWED)).collect {
    // Received a message
}
// Sync all new welcomes, preference updates, conversations,
// and messages from allowed conversations 
client.conversations.syncAll(consentStates = ConsentState.ALLOWED)
```


## pages/chat-apps/sdks/react-native.mdx
# Get started with the XMTP React Native SDK

Use the [XMTP React Native SDK](https://github.com/xmtp/xmtp-react-native) to build secure, private, and decentralized messaging into your cross-platform mobile app.

The guide provides some quickstart code, as well as a map to building a [secure chat app](/protocol/security) with XMTP, including support for:

- End-to-end encrypted direct message and group chat conversations
- Rich content types (attachments, reactions, replies, and more)
- Spam-free chats using user consent preferences

## Quickstart

```tsx [React Native]
// 1. Create an EOA or SCW signer.
// Details depend on your app's wallet implementation.
export function convertEOAToSigner(eoaAccount: EOAAccount): Signer {
  return {
    getIdentifier: async () => new PublicIdentity(eoaAccount.address, "ETHEREUM"),
    getChainId: () => undefined,
    getBlockNumber: () => undefined,
    signerType: () => "EOA",
    signMessage: async (message: string) => ({ signature: await eoaAccount.signMessage(message) }),
  };
}

// 2. Create the XMTP client
const client = Client.create(signer, {
  env: "production",
  dbEncryptionKey: keyBytes, // 32 bytes
});

// 3. Start conversations
const group = await client.conversations.newGroup([bo.inboxId, caro.inboxId]);
const groupWithMeta = await client.conversations.newGroup([bo.inboxId, caro.inboxId], {
  name: "The Group Name",
  imageUrl: "www.groupImage.com",
  description: "The description of the group",
  permissionLevel: "admin_only",
});

// 4. Send messages
const dm = await client.conversations.findOrCreateDm(recipientInboxId);
await dm.send("Hello world");
await group.send("Hello everyone");

// 5. List, stream, and sync
// List existing conversations
await client.conversations.list(["allowed"]);
// Stream new messages
await client.conversations.streamAllMessages(
  async (message: DecodedMessage<any>) => {
    // Received a message
  },
  { consentState: ["allowed"] }
);
// Sync all new welcomes, preference updates, conversations,
// and messages from allowed conversations 
await client.conversations.syncAllConversations(["allowed"]);
```


## pages/chat-apps/core-messaging/create-a-signer.mdx
# Create a EOA or SCW signer

XMTP SDKs support message signing with 2 different types of Ethereum accounts: Externally Owned Accounts (EOAs) and Smart Contract Wallets (SCWs). All SDK clients accept a signer object (or instance), which provides a method for signing messages.

## Create an Externally Owned Account signer

The EOA signer must have 3 properties: the account type, a function that returns the account identifier, and a function that signs messages.

:::code-group

```tsx [Browser]
import type { Signer, Identifier } from "@xmtp/browser-sdk";

const accountIdentifier: Identifier = {
  identifier: "0x...", // Ethereum address as the identifier
  identifierKind: "Ethereum", // Specifies the identity type
};

const signer: Signer = {
  type: "EOA",
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};
```

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from "@xmtp/node-sdk";

const accountIdentifier: Identifier = {
  identifier: "0x...", // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: "EOA",
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};
```

```tsx [React Native]
// Example EOA Signer
export function convertEOAToSigner(eoaAccount: EOAAccount): Signer {
  return {
    getIdentifier: async () =>
      new PublicIdentity(eoaAccount.address, "ETHEREUM"),
    getChainId: () => undefined, // Provide a chain ID if available or return undefined
    getBlockNumber: () => undefined, // Block number is typically not available in Wallet, return undefined
    signerType: () => "EOA", // "EOA" indicates an externally owned account
    signMessage: async (message: string) => {
      const signature = await eoaAccount.signMessage(message);

      return {
        signature,
      };
    },
  };
}
```

```kotlin [Kotlin]
class EOAWallet : SigningKey {
    override val publicIdentity: PublicIdentity
      get() = PublicIdentity(
          IdentityKind.ETHEREUM,
          key.publicAddress
      )
    override val type: SignerType
      get() = SignerType.EOA

    override suspend fun sign(message: String): SignedData {
        val signature = key.sign(message = message)
        return SignedData(signature)
    }
}
```

```swift [Swift]
public struct EOAWallet: SigningKey {
    public var identity: PublicIdentity {
      return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
    }

    public var type: SignerType { .EOA }

    public func sign(message: String) async throws -> SignedData {
        let signature = try await key.sign(message: message)
        return SignedData(signature)
    }
}
```

:::

## Create a Smart Contract Wallet signer

The SCW signer has the same 3 required properties as the EOA signer, but also requires a function that returns the chain ID of the blockchain being used and an optional function that returns the block number to verify signatures against. If a function is not provided to retrieve the block number, the latest block number will be used.

Here is a list of supported chain IDs:

- chain_rpc_1     = string
- chain_rpc_8453  = string
- chain_rpc_42161 = string
- chain_rpc_10    = string
- chain_rpc_137   = string
- chain_rpc_324   = string
- chain_rpc_59144 = string
- chain_rpc_480   = string

Need support for a different chain ID? Please post your request to the [XMTP Community Forums](https://community.xmtp.org/c/general/ideas/54).

The details of creating an SCW signer are highly dependent on the wallet provider and the library you're using to interact with it. Here are some general guidelines to consider:

- **Wallet provider integration**: Different wallet providers (Safe, Argent, Rainbow, etc.) have different methods for signing messages. See the wallet provider documentation for more details.

- **Library selection**: Choose a library that supports your wallet provider (e.g., viem, ethers.js, web3.js). Each library has its own API for interacting with wallets. See the library documentation for more details.

- **Add an Ethereum-specific prefix**: Before signing, Ethereum requires a specific prefix to be added to the message. To learn more, see [ERC-191: Signed Data Standard](https://eips.ethereum.org/EIPS/eip-191). Libraries and wallet providers might add the prefix for you, so make sure you don't add the prefix twice.

- **Hash the prefixed message with Keccak-256**: The prefixed message is hashed using the Keccak-256 algorithm, which is Ethereum's standard hashing algorithm. This step creates a fixed-length representation of the message, ensuring consistency and security. Note that some wallet providers might handle this hashing internally.

- **Sign the replay-safe hash**: The replay-safe hash is signed using the private key of the SCW. This generates a cryptographic signature that proves ownership of the wallet and ensures the integrity of the message.

- **Convert the signature to a Uint8Array**: The resulting signature is converted to a `Uint8Array` format, which is required by the XMTP SDK for compatibility and further processing.

The code snippets below are examples only and will need to be adapted based on your specific wallet provider and library.

:::code-group

```tsx [Browser]
export const createSCWSigner = (
  address: `0x${string}`,
  walletClient: WalletClient,
  chainId: bigint,
): Signer => {
  return {
    type: "SCW",
    getIdentifier: () => ({
      identifier: address.toLowerCase(),
      identifierKind: "Ethereum",
    }),
    signMessage: async (message: string) => {
      const signature = await walletClient.signMessage({
        account: address,
        message,
      });
      return toBytes(signature);
    },
    getChainId: () => {
      return chainId;
    },
  };
```

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from "@xmtp/node-sdk";

const accountIdentifier: Identifier = {
  identifier: "0x...", // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: "SCW",
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
  getChainId: () => BigInt(8453), // Example: Base chain ID
};
```

```tsx [React Native]
// Example SCW Signer
export function convertSCWToSigner(scwAccount: SCWAccount): Signer {
  return {
    getIdentifier: async () =>
      new PublicIdentity(scwAccount.address, "ETHEREUM"),
    getChainId: () => 8453, // https://chainlist.org/
    getBlockNumber: () => undefined, // Optional: will be computed at runtime
    signerType: () => "SCW", // "SCW" indicates smart contract wallet account
    signMessage: async (message: string) => {
      const byteArray = await scwAccount.signMessage(message);
      const signature = ethers.utils.hexlify(byteArray); // Convert to hex string

      return {
        signature,
      };
    },
  };
}
```

```kotlin [Kotlin]
  class SCWallet : SigningKey {
    override val publicIdentity: PublicIdentity
      get() = PublicIdentity(
          IdentityKind.ETHEREUM,
          key.publicAddress
      )
    override val type: SignerType
      get() = SignerType.SCW

    override var chainId: Long? = 8453 // https://chainlist.org/
    override var blockNumber: Long? = null // Optional: will be computed at runtime

    override suspend fun sign(message: String): SignedData {
        val signature = key.sign(message = message)
        return SignedData(signature)
    }
}
```

```swift [Swift]
public struct SCWallet: SigningKey {
    public var identity: PublicIdentity {
      return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
    }

    public var chainId: Int64? {
        8453
    }

    public var blockNumber: Int64? {
        nil
    }

    public var type: SignerType { .SCW }

    public func sign(message: String) async throws -> SignedData {
        let signature = try await key.sign(message: message)
        return SignedData(signature.hexStringToByteArray )
    }
}
```

:::


## pages/chat-apps/core-messaging/rate-limits.mdx
# Observe rate limits

XMTP enforces separate rate limits for read and write operations per client per rolling 5-minute window:

- **Read operations**: 20,000 requests per 5-minute window
- **Write operations**: 3,000 messages published per 5-minute window

When you reach either rate limit, your API calls will be rejected with a 429 (Too Many Requests) error.

**Read operations** include actions like:

- Fetching conversations
- Retrieving messages
- Getting inbox state
- Listing installations

**Write operations** include actions like:

- Sending chat messages
- Adding and removing wallets
- Adding and revoking installations
- Adding and removing group members
- Updating group metadata


## pages/chat-apps/core-messaging/create-a-client.mdx
# Create an XMTP client

Create an XMTP client that can use the signing capabilities provided by the [signer](/chat-apps/core-messaging/create-a-signer). This signer links the client to the appropriate EOA or SCW.

## Understand creating and building a client

This video provides a walkthrough of creating and building a client.

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/kdUP1ZaauNI?si=ETuEbvwbKx4bjtwc"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowFullScreen
></iframe>

### How it works

When you call `Client.create()`, the following steps happen under the hood:

1. Extracts the `signer` and retrieves the wallet address from it.
2. Checks the XMTP identity ledger to find an inbox ID associated with the signer address. The inbox ID serves as the user's identity on the XMTP network.
   1. If it doesn't find an existing inbox ID, it requests a wallet signature to register the identity and create an inbox ID.
   2. If it finds an existing inbox ID, it uses the existing inbox ID.
3. Checks if a local SQLite database exists. This database contains the identity's installation state and message data.
   1. If it doesn't find an existing local database, it creates one. On non-web platforms, it encrypts the database with the provided `dbEncryptionKey`.
   2. If it finds an existing local database:
      - **For the Node, React Native, Android, and iOS SDKs**: It checks if the provided `dbEncryptionKey` matches. If it matches, it uses the existing database. If not, it creates a new database encrypted with the provided key.
      - **For the Browser SDK**: A `dbEncryptionKey` is not used for encryption due to technical limitations in web environments. Be aware that the database is not encrypted.
4. Returns the XMTP client, ready to send and receive messages.

### Keep the database encryption key safe

The `dbEncryptionKey` client option is used by the Node, React Native, Android, and Swift SDKs only.

The encryption key is critical to the stability and continuity of an XMTP client. It encrypts the local SQLite database created when you call `Client.create()`, and must be provided every time you create or build a client.

As long as the local database and encryption key remain intact, you can use [`Client.build()`](#build-an-existing-client) to rehydrate the same client without re-signing.

This encryption key is not stored or persisted by the XMTP SDK, so it's your responsibility as the app developer to store it securely and consistently.

If the encryption key is lost, rotated, or passed incorrectly during a subsequent `Client.create()` or `Client.build()` call (on non-web platforms), the app will be unable to access the local database. Likewise, if you initially provided the `dbPath` option, you must always provide it with every subsequent call or the client may be unable to access the database. The client will assume that the database can't be decrypted or doesn't exist, and will fall back to creating a new installation.

Creating a new installation requires a new identity registration and signature—and most importantly, **results in loss of access to all previously stored messages** unless the user has done a [history sync](/chat-apps/list-stream-sync/history-sync).

To ensure seamless app experiences persist the `dbEncryptionKey` securely, and make sure it's available and correctly passed on each app launch

The `dbEncryptionKey` client option is not used by the Browser SDK for due to technical limitations in web environments. In this case, be aware that the database is not encrypted.

To learn more about database operations, see the [XMTP MLS protocol spec](https://github.com/xmtp/libxmtp/blob/main/xmtp_mls/README.md).

### View an encrypted database

For debugging, it can be useful to decrypt a locally stored database. When a `dbEncryptionKey` is used, the XMTP client creates a [SQLCipher database](https://www.zetetic.net/sqlcipher/) which applies transparent 256-bit AES encryption. A `.sqlitecipher_salt` file is also generated alongside the database.

To open this database, you need to construct the password by prefixing `0x` (to indicate hexadecimal numbers), then appending the encryption key (64 hex characters, 32 bytes) and the salt (32 hex characters, 16 bytes). For example, if your encryption key is `A` and your salt is `B`, the resulting password would be `0xAB`.

The database also uses a [plaintext header size](https://www.zetetic.net/sqlcipher/sqlcipher-api/#cipher_plaintext_header_size) of 32 bytes.

If you want to inspect the database visually, you can use [DB Browser for SQLite](https://sqlitebrowser.org/), an open source tool that supports SQLite and SQLCipher. In its **Custom** encryption settings, set the **Plaintext Header Size** to **_32_**, and use the full **Password** as a **Raw key**:

![DB Browser for SQLite](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/db-browser-sqlite.png)

## Create a client

To call `Client.create()`, you must pass in a required `signer` and can also pass in any of the optional parameters covered in [Configure an XMTP client](#configure-an-xmtp-client).

:::code-group

```tsx [Browser]
import { Client, type Signer } from "@xmtp/browser-sdk";

// create a signer
const signer: Signer = { /* ... */ };

const client = await Client.create(
  signer,
  // client options
  {
  // Note: dbEncryptionKey is not used for encryption in browser environments
  },
);
```

```tsx [Node]
import { Client, type Signer } from "@xmtp/node-sdk";
import { getRandomValues } from "node:crypto";

// create a signer
const signer: Signer = { /* ... */ };

/**
 * The database encryption key is optional but strongly recommended for
 * secure local storage of the database.
 *
 * This value must be consistent when creating a client with an existing
 * database.
 */
const dbEncryptionKey = getRandomValues(new Uint8Array(32));

const client = await Client.create(
  signer,
  // client options
  {
    dbEncryptionKey,
  },
);
```

```tsx [React Native]
Client.create(signer, {
  env: "production", // 'local' | 'dev' | 'production'
  dbEncryptionKey: keyBytes, // 32 bytes
});
```

```kotlin [Kotlin]
val options = ClientOptions(
    ClientOptions.Api(XMTPEnvironment.PRODUCTION, true),
    appContext = ApplicationContext(),
    dbEncryptionKey = keyBytes // 32 bytes
)
val client = Client().create(
        account = SigningKey,
        options = options
    )
```

```swift [Swift]
let options = ClientOptions.init(
  api: .init(env: .production, isSecure: true),
  dbEncryptionKey: keyBytes // 32 bytes
)
let client = try await Client.create(
  account: SigningKey,
  options: options
)
```

:::

### Configure an XMTP client

You can configure an XMTP client with these options passed to `Client.create`:

:::code-group

```tsx [Browser]
import type { ContentCodec } from "@xmtp/content-type-primitives";

type ClientOptions = {
  /**
   * Specify which XMTP environment to connect to. (default: `dev`)
   */
  env?: "local" | "dev" | "production";
  /**
   * Add a client app version identifier that's included with API requests.
   * Production apps are strongly encouraged to set this value.
   *
   * You can use the following format: `appVersion: 'APP_NAME/APP_VERSION'`.
   *
   * For example: `appVersion: 'alix/2.x'`
   * 
   * If you have an app and an agent, it's best to distinguish them from each other by 
   * adding `-app` and `-agent` to the names. For example:
   * 
   * - App: `appVersion: 'alix-app/3.x'`
   * - Agent: `appVersion: 'alix-agent/2.x'`
   * 
   * Setting this value provides telemetry that shows which apps are using the
   * XMTP client SDK. This information can help XMTP core developers provide you with app
   * support, especially around communicating important SDK updates, deprecations,
   * and required upgrades.
   */
  appVersion?: string;
  /**
   * apiUrl can be used to override the `env` flag and connect to a
   * specific endpoint
   */
  apiUrl?: string;
  /**
   * historySyncUrl can be used to override the `env` flag and connect to a
   * specific endpoint for syncing history
   */
  historySyncUrl?: string | null;
  /**
   * Allow configuring codecs for additional content types
   */
  codecs?: ContentCodec[];
  /**
   * Path to the local DB
   *
   * There are 3 value types that can be used to specify the database path:
   *
   * - `undefined` (or excluded from the client options)
   *    The database will be created in the current working directory and is based on
   *    the XMTP environment and client inbox ID.
   *    Example: `xmtp-dev-<inbox-id>.db3`
   *
   * - `null`
   *    No database will be created and all data will be lost once the client disconnects.
   *
   * - `string`
   *    The given path will be used to create the database.
   *    Example: `./my-db.db3`
   */
  dbPath?: string | null;
  /**
   * Encryption key for the local DB
   */
  dbEncryptionKey?: Uint8Array;
  /**
   * Enable structured JSON logging
   */
  structuredLogging?: boolean;
  /**
   * Enable performance metrics
   */
  performanceLogging?: boolean;
  /**
   * Logging level
   */
  loggingLevel?: "off" | "error" | "warn" | "info" | "debug" | "trace";
  /**
   * Disable automatic registration when creating a client
   */
  disableAutoRegister?: boolean;
  /**
   * Disable device sync
   */
  disableDeviceSync?: boolean;
};

```

```tsx [Node]
import type { ContentCodec } from "@xmtp/content-type-primitives";
import type { LogLevel } from "@xmtp/node-bindings";

type ClientOptions = {
  /**
   * Specify which XMTP environment to connect to. (default: `dev`)
   */
  env?: "local" | "dev" | "production";
  /**
   * Add a client app version identifier that's included with API requests.
   * Production apps are strongly encouraged to set this value.
   *
   * You can use the following format: `appVersion: 'APP_NAME/APP_VERSION'`.
   *
   * For example: `appVersion: 'alix/2.x'`
   * 
   * If you have an app and an agent, it's best to distinguish them from each other by 
   * adding `-app` and `-agent` to the names. For example:
   * 
   * - App: `appVersion: 'alix-app/3.x'`
   * - Agent: `appVersion: 'alix-agent/2.x'`
   * 
   * Setting this value provides telemetry that shows which apps are using the
   * XMTP client SDK. This information can help XMTP core developers provide you with app
   * support, especially around communicating important SDK updates, deprecations,
   * and required upgrades.
   */
  appVersion?: string;
  /**
   * apiUrl can be used to override the `env` flag and connect to a
   * specific endpoint
   */
  apiUrl?: string;
  /**
   * historySyncUrl can be used to override the `env` flag and connect to a
   * specific endpoint for syncing history
   */
  historySyncUrl?: string | null;
  /**
   * Path to the local DB
   *
   * There are 3 value types that can be used to specify the database path:
   *
   * - `undefined` (or excluded from the client options)
   *    The database will be created in the current working directory and is based on
   *    the XMTP environment and client inbox ID.
   *    Example: `xmtp-dev-<inbox-id>.db3`
   *
   * - `null`
   *    No database will be created and all data will be lost once the client disconnects.
   *
   * - `string`
   *    The given path will be used to create the database.
   *    Example: `./my-db.db3`
   */
  dbPath?: string | null;
  /**
   * Encryption key for the local DB
   */
  dbEncryptionKey?: Uint8Array;
  /**
   * Allow configuring codecs for additional content types
   */
  codecs?: ContentCodec[];
  /**
   * Enable structured JSON logging
   */
  structuredLogging?: boolean;
  /**
   * Logging level
   */
  loggingLevel?: LogLevel;
  /**
   * Disable automatic registration when creating a client
   */
  disableAutoRegister?: boolean;
  /**
   * Disable device sync
   */
  disableDeviceSync?: boolean;
};
```

```tsx [React Native]
import type { ContentCodec } from "@xmtp/react-native-sdk";

type ClientOptions = {
  /**
   * Specify which XMTP environment to connect to. (default: `dev`)
   */
  env: 'local' | 'dev' | 'production'
  /**
   * Add a client app version identifier that's included with API requests.
   * Production apps are strongly encouraged to set this value.
   *
   * You can use the following format: `appVersion: 'APP_NAME/APP_VERSION'`.
   *
   * For example: `appVersion: 'alix/2.x'`
   * 
   * If you have an app and an agent, it's best to distinguish them from each other by 
   * adding `-app` and `-agent` to the names. For example:
   * 
   * - App: `appVersion: 'alix-app/3.x'`
   * - Agent: `appVersion: 'alix-agent/2.x'`
   * 
   * Setting this value provides telemetry that shows which apps are using the
   * XMTP client SDK. This information can help XMTP core developers provide you with app
   * support, especially around communicating important SDK updates, deprecations,
   * and required upgrades.
   */
  appVersion?: string;
  /**
   * REQUIRED specify the encryption key for the database. The encryption key must be exactly 32 bytes.
   */
  dbEncryptionKey: Uint8Array
  /**
   * Set optional callbacks for handling identity setup
   */
  preAuthenticateToInboxCallback?: () => Promise<void> | void
  /**
   * OPTIONAL specify the XMTP managed database directory
   */
  dbDirectory?: string
  /**
   * OPTIONAL specify a url to sync message history from
   */
  historySyncUrl?: string
  /**
   * OPTIONAL specify a custom local host for testing on physical devices for example `localhost`
   */
  customLocalHost?: string
  /**
   * Allow configuring codecs for additional content types
   */
  codecs?: ContentCodec[]
}
```

```kotlin [Kotlin]
import android.content.Context

typealias PreEventCallback = suspend () -> Unit

data class ClientOptions(
    val api: Api = Api(),
    val preAuthenticateToInboxCallback: PreEventCallback? = null,
    val appContext: Context,
    val dbEncryptionKey: ByteArray,
    val historySyncUrl: String? = when (api.env) {
        XMTPEnvironment.PRODUCTION -> "https://message-history.production.ephemera.network/"
        XMTPEnvironment.LOCAL -> "http://0.0.0.0:5558"
        else -> "https://message-history.dev.ephemera.network/"
    },
    val dbDirectory: String? = null,
) {
    data class Api(
        val env: XMTPEnvironment = XMTPEnvironment.DEV,
        val isSecure: Boolean = true,
        /**
         * Add a client app version identifier that's included with API requests.
         * Production apps are strongly encouraged to set this value.
         *
         * You can use the following format: `appVersion: "APP_NAME/APP_VERSION"`.
         *
         * For example: `appVersion: 'alix/2.x'`
         *
         * If you have an app and an agent, it's best to distinguish them from each other by 
         * adding `-app` and `-agent` to the names. For example:
         *
         * - App: `appVersion: 'alix-app/3.x'`
         * - Agent: `appVersion: 'alix-agent/2.x'`
         *
         * Setting this value provides telemetry that shows which apps are using the
         * XMTP client SDK. This information can help XMTP core developers provide you
         * with app support, especially around communicating important SDK updates, 
         * deprecations, and required upgrades.
         */
        val appVersion: String? = null,
    )
}
```

```swift [Swift]
import LibXMTP

public struct ClientOptions {
 // Specify network options
 public struct Api {
  /// Specify which XMTP network to connect to. Defaults to ``.dev``
  public var env: XMTPEnvironment = .dev

  /// Specify whether the API client should use TLS security. In general this should only be false when using the `.local` environment.
  public var isSecure: Bool = true

  /// Add a client app version identifier that's included with API requests.
  /// Production apps are strongly encouraged to set this value.
  ///
  /// You can use the following format: `appVersion: "APP_NAME/APP_VERSION"`.
  ///
  /// For example: `appVersion: 'alix/2.x'`
  /// 
  /// If you have an app and an agent, it's best to distinguish them from each other by 
  /// adding `-app` and `-agent` to the names. For example:
  /// - App: `appVersion: 'alix-app/3.x'`
  /// - Agent: `appVersion: 'alix-agent/2.x'`
  ///
  /// Setting this value provides telemetry that shows which apps are using the
  /// XMTP client SDK. This information can help XMTP core developers provide you
  //  with app support, especially around communicating important SDK updates,
  /// deprecations, and required upgrades.
  public var appVersion: String?
 }

 public var api = Api()
 public var codecs: [any ContentCodec] = []

 /// `preAuthenticateToInboxCallback` will be called immediately before an Auth Inbox signature is requested from the user
 public var preAuthenticateToInboxCallback: PreEventCallback?

 public var dbEncryptionKey: Data
 public var dbDirectory: String?
 public var historySyncUrl: String?
}
```

:::

### Set the `appVersion` client option

Be sure to set the `appVersion` client option for your production app.

You can use the following format: `appVersion: 'APP_NAME/APP_VERSION'`.

For example: `appVersion: 'alix/2.x'`

If you have an app and an agent, it's best to distinguish them from each other by adding `-app` and `-agent` to the names. For example:

- App: `appVersion: 'alix-app/3.x'`
- Agent: `appVersion: 'alix-agent/2.x'`

The `appVersion` value is included with API requests to provide telemetry that shows which apps are using the XMTP client SDK. This information can help XMTP core developers provide you with app support, especially around communicating important SDK updates, deprecations, and required upgrades.

### XMTP network environments

XMTP provides `dev` and `production` network environments. These networks are completely separate and not interchangeable.

For example, an XMTP identity on the `dev` network is completely distinct from the XMTP identity on the `production` network, as are the messages associated with these identities. In addition, XMTP identities and messages created on the `dev` network can't be accessed from or moved to the `production` network, and vice versa.

:::tip
When you create a client, it connects to the XMTP `dev` network by default. Set your client's network environment using the appropriate [client option](#configure-an-xmtp-client).
:::

The `production` network is configured to store messages indefinitely. XMTP may occasionally delete messages and identities from the `dev` network, and will provide advance notice in the [XMTP Community Forums](https://community.xmtp.org/).

You can use a `local` network environment to have a client communicate with an XMTP node you are running locally. During development, using `local` is a great option for speed and reliability. Use the [xmtp-local-node](https://github.com/xmtp/xmtp-local-node/tree/main) repo to easily run a local XMTP node.

## Build an existing client

Build, or resume, an existing client (created using [`Client.create()`](#create-a-client)) that's logged in and has an existing local database.

For React Native, Android, and iOS SDKs, when building a client with an existing `inboxId`, the client automatically operates in offline mode since no network request is needed to check the identity ledger. In offline mode, the client:

- Skips all network requests (preference syncing between installations, validating inbox, etc.)
- Works entirely from the local database
- Can be synchronized later with `syncAllConversations()` or by recreating the client without the offline flag.

:::code-group

```tsx [Browser]
import { Client, type Identifier } from "@xmtp/browser-sdk";

const identifier: Identifier = {
  identifier: "0x1234567890abcdef1234567890abcdef12345678",
  identifierKind: "Ethereum",
};
const client = await Client.build(identifier, options);
```

```tsx [Node]
import { Client, IdentifierKind, type Identifier } from "@xmtp/node-sdk";

const identifier: Identifier = {
  identifier: "0x1234567890abcdef1234567890abcdef12345678",
  identifierKind: IdentifierKind.Ethereum,
};
const client = await Client.build(identifier, options);
```

```tsx [React Native]
Client.build(identity, {
  env: "production", // 'local' | 'dev' | 'production'
  dbEncryptionKey: keyBytes, // 32 bytes
});
```

```kotlin [Kotlin]
val options = ClientOptions(
    ClientOptions.Api(XMTPEnvironment.PRODUCTION, true),
    appContext = ApplicationContext(),
    dbEncryptionKey = keyBytes
)
val client = Client().build(
        identity = identity,
        options = options
    )
```

```swift [Swift]
let options = ClientOptions.init(
  api: .init(env: .production, isSecure: true),
  dbEncryptionKey: keyBytes // 32 bytes
)
let client = try await Client.build(
  identity: identity,
  options: options
)
```

:::

## Log out a client

When you log a user out of your app, you can give them the option to delete their local database.

:::tip[Important]
If the user chooses to delete their local database, they will lose all of their messages and will have to create a new installation the next time they log in.
:::

:::code-group

```tsx [Browser]
/**
 * The Browser SDK client does not currently support deleting the local database.
 */

// this method only terminates the client's associated web worker
client.close();
```

```tsx [Node]
/**
 * The Node SDK client does not have a method to delete the local database.
 * Simply delete the local database file from the file system.
 */
```

```tsx [React Native]
await client.deleteLocalDatabase();
await Client.dropClient(client.installationId);
```

```kotlin [Kotlin]
client.deleteLocalDatabase()
```

```swift [Swift]
try await client.deleteLocalDatabase()
```

:::


## pages/chat-apps/core-messaging/group-permissions.mdx
# Manage group permissions

Robust group chat permissions are key to providing users with a friendly and safe group chat experience.

## Understand the group permissions system

### Member statuses

Member statuses are the roles that can be assigned to each participant (inbox ID) in a group chat. These are the available member statuses:

- Member
  - Everyone in a group chat is a member. A member can be granted admin or super admin status. If a member's admin or super admin status is removed, they are still a member of the group.
- Admin
- Super admin

### Options

Use options to assign a role to a permission. These are the available options:

- All members
- Admin only
  - Includes super admins
- Super admin only

### Permissions

Permissions are the actions a group chat participant can be allowed to take. These are the available permissions:

- Grant admin status to a member
- Remove admin status from a member
- Add a member to the group
- Remove a member from the group
- Update [group metadata](/chat-apps/core-messaging/group-metadata), such as group name, description, and image
- Update group permissions on an item-by-item basis, such as calling `updateNamePermission` or `updateAddMemberPermission` . To learn more, see [Group.kt](https://github.com/xmtp/xmtp-android/blob/main/library/src/main/java/org/xmtp/android/library/Group.kt#L251-L313) in the xmtp-android SDK repo.

The following permissions can be assigned by super admins only. This helps ensure that a “regular” admin cannot remove the super admin or otherwise destroy a group.

- Grant super admin status to a member
- Remove super admin status from a member
- Update group permissions

## How the group permissions system works

When a group is created, all groups have the same initial member "roles" set:

- There is one super admin, and it is the group creator
- There are no admins
- Each user added to the group starts out as a member

The super admin has all of the [available permissions](#permissions) and can use them to adjust the group's permissions and options.

As the app developer, you can provide a UI that enables group participants to make further adjustments. For example, you can give the super admin the following permission options for group members when creating the group:

- Add members
- Update group metadata

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/group-perm-toggles.png" width="300px" />
</div>

You can use member statuses, options, and permissions to create a custom policy set. The following table represents the valid policy options for each of the permissions:

| Permission | Allow all | Deny all  | Admin only | Super admin only |
| --- | --- | --- | --- | --- |
| Add member | ✅ | ✅ | ✅ | ✅ |
| Remove member | ✅ | ✅ | ✅ | ✅ |
| Add admin | ❌ | ✅ | ✅ | ✅ |
| Remove admin | ❌ | ✅ | ✅ | ✅ |
| Update group permissions | ❌ | ❌ | ❌ | ✅ |
| Update group metadata | ✅ | ✅ | ✅ | ✅ |

If you aren't opinionated and don't set any permissions and options, groups will default to using the delivered `All_Members` policy set, which applies the following permissions and options:

- Add member - All members
- Remove member - Admin only
- Add admin - Super admin only
- Remove admin - Super admin only
- Update group permissions - Super admin only
- Update group metadata - All members

To learn more about the `All_Members` and `Admin_Only` policy sets, see [group_permissions.rs](https://github.com/xmtp/libxmtp/blob/85dd6d36f46db1ed74fe98273eea6871fea2e078/xmtp_mls/src/groups/group_permissions.rs#L1192-L1226) in the LibXMTP repo.

## Manage group chat admins

### Check if inbox ID is an admin

:::code-group

```js [Browser]
const isAdmin = group.isAdmin(inboxId);
```

```js [Node]
const isAdmin = group.isAdmin(inboxId);
```

```tsx [React Native]
// Assume group is an existing group chat object for client
const isAdmin = await group.isAdmin(adminClient.inboxID);
```

```kotlin [Kotlin]
//Assume group is an existing group chat object for client
val isInboxIDAdmin = group.isAdmin(inboxId)
```

```swift [Swift]
// Assume group is an existing group chat object for client
try group.isAdmin(client.inboxID)
```

:::

### Check if inbox ID is a super admin

:::code-group

```js [Browser]
const isSuperAdmin = group.isSuperAdmin(inboxId);
```

```js [Node]
const isSuperAdmin = group.isSuperAdmin(inboxId);
```

```tsx [React Native]
//Assume group is an existing group chat object for client
const isSuperAdmin = await group.isSuperAdmin(client.inboxID);
```

```kotlin [Kotlin]
//Assume group is an existing group chat object for client
val isInboxIDSuperAdmin = group.isSuperAdmin(inboxId)
```

```swift [Swift]
try group.isSuperAdmin(inboxid: inboxID)
```

:::

### List admins

:::code-group

```js [Browser]
const admins = group.admins;
```

```js [Node]
const admins = group.admins;
```

```tsx [React Native]
await group.listAdmins();
```

```kotlin [Kotlin]
// Returns a list of inboxIds of Admins
group.listAdmins()
```

```swift [Swift]
try group.listAdmins()
```

:::

### List super admins

:::code-group

```js [Browser]
const superAdmins = group.superAdmins;
```

```js [Node]
const superAdmins = group.superAdmins;
```

```tsx [React Native]
await group.listSuperAdmins();
```

```kotlin [Kotlin]
// Returns a list of inboxIds of Super Admins
group.listSuperAdmins()
```

```swift [Swift]
try group.listSuperAdmins()
```

:::

### Add admin status to inbox ID

:::code-group

```js [Browser]
await group.addAdmin(inboxId);
```

```js [Node]
await group.addAdmin(inboxId);
```

```tsx [React Native]
await group.addAdmin(client.inboxID);
```

```kotlin [Kotlin]
group.addAdmin(inboxId)
```

```swift [Swift]
try await group.addAdmin(inboxid: inboxID)
```

:::

### Add super admin status to inbox ID

:::code-group

```js [Browser]
await group.addSuperAdmin(inboxId);
```

```js [Node]
await group.addSuperAdmin(inboxId);
```

```tsx [React Native]
await group.addSuperAdmin(client.inboxID);
```

```kotlin [Kotlin]
group.addSuperAdmin(inboxId)
```

```swift [Swift]
try await group.addSuperAdmin(inboxid: inboxID)
```

:::

### Remove admin status from inbox ID

:::code-group

```js [Browser]
await group.removeAdmin(inboxId);
```

```js [Node]
await group.removeAdmin(inboxId);
```

```tsx [React Native]
await group.removeAdmin(client.inboxID);
```

```kotlin [Kotlin]
group.removeAdmin(inboxId)
```

```swift [Swift]
try await group.removeAdmin(inboxid: inboxid)
```

:::

### Remove super admin status from inbox ID

:::code-group

```js [Browser]
await group.removeSuperAdmin(inboxId);
```

```js [Node]
await group.removeSuperAdmin(inboxId);
```

```tsx [React Native]
await group.removeSuperAdmin(client.inboxId);
```

```kotlin [Kotlin]
group.removeSuperAdmin(inboxId)
```

```swift [Swift]
try await group.removeSuperAdmin(inboxid: inboxID)
```

:::

## Manage group chat membership

### Add members by inbox ID

The maximum group chat size is 250 members.

:::code-group

```js [Browser]
await group.addMembers([inboxId]);
```

```js [Node]
await group.addMembers([inboxId]);
```

```tsx [React Native]
await group.addMembers([inboxId]);
```

```kotlin [Kotlin]
group.addMembers(listOf(client.inboxId))
```

```swift [Swift]
try await group.addMembers(inboxIds: [inboxId])
```

:::

### Remove member by inbox ID

:::code-group

```js [Browser]
await group.removeMembers([inboxId]);
```

```js [Node]
await group.removeMembers([inboxId]);
```

```tsx [React Native]
await group.removeMembers([inboxId]);
```

```kotlin [Kotlin]
group.removeMembers(listOf(inboxId))
```

```swift [Swift]
try await group.removeMembers(inboxIds: [inboxId])
```

:::

### Get inbox IDs for members

:::code-group

```js [Browser]
const inboxId = await client.findInboxIdByIdentities([bo.identity, caro.identity]);
```

```js [Node]
const inboxId = await client.getInboxIdByIdentities([bo.identity, caro.identity]);
```

```tsx [React Native]
await group.memberInboxIds();
```

```kotlin [Kotlin]
val members = group.members()
val inboxIds = members.map { it.inboxId }

OR

val inboxId = client.inboxIdFromIdentity(peerIdentity)
```

```swift [Swift]
let members = try group.members.map(\.inboxId).sorted()

OR

try await client.inboxIdFromIdentity(identity: peerIdentity)
```

:::

### Get identities for members

:::code-group

```js [Browser]
// sync group first
await group.sync();

// get group members
const members = await group.members();

// map inbox ID to account identity
const inboxIdIdentityMap = new Map(
  members.map((member) => [member.inboxId, member.accountIdentity])
);
```

```js [Node]
// sync group first
await group.sync();

// get group members
const members = group.members;

// map inbox ID to account identity
const inboxIdIdentityMap = new Map(
  members.map((member) => [member.inboxId, member.accountIdentity])
);
```

```tsx [React Native]
const members = await group.members();
const identities = members.map((member) => member.identities);
```

```kotlin [Kotlin]
val members = group.members()
val identities = members.map { it.identities }
```

```swift [Swift]
let peerMembers = try Conversation.group(group).peerInboxIds.sorted()
```

:::

### Get the inbox ID that added the current member

:::code-group

```js [Browser]
const addedByInboxId = group.addedByInboxId;
```

```js [Node]
const addedByInboxId = group.addedByInboxId;
```

```tsx [React Native]
// this API is experimental and may change in the future

const addedByInboxId = await group.addedByInboxId();
```

```kotlin [Kotlin]
val addedByInboxId = group.addedByInboxId();
```

```swift [Swift]
try await group.addedByInboxId();
```

:::


## pages/chat-apps/core-messaging/send-messages.mdx
# Send messages

Once you have the group chat or DM conversation, you can send messages in the conversation.

:::code-group

```tsx [Browser]
// For a DM conversation
await dm.send("Hello world");

// OR for a group chat
await group.send("Hello everyone");
```

```tsx [Node]
// For a DM conversation
await dm.send("Hello world");

// OR for a group chat
await group.send("Hello everyone");
```

```tsx [React Native]
// For a DM conversation
const dm = await client.conversations.findOrCreateDm(recipientInboxId);
await dm.send("Hello world");

// OR for a group chat
const group = await client.conversations.newGroup([recipientInboxId1, recipientInboxId2]);
await group.send("Hello everyone");
```

```kotlin [Kotlin]
// For a DM conversation
val dm = client.conversations.findOrCreateDm(recipientInboxId)
dm.send(text = "Hello world")

// OR for a group chat
val group = client.conversations.newGroup(listOf(recipientInboxId1, recipientInboxId2))
group.send(text = "Hello everyone")
```

```swift [Swift]
// For a DM conversation
let dm = try await client.conversations.findOrCreateDm(with: recipientInboxId)
try await dm.send(content: "Hello world")

// OR for a group chat
let group = try await client.conversations.newGroup([recipientInboxId1, recipientInboxId2])
try await group.send(content: "Hello everyone")
```

:::

## Optimistically send messages

When a user sends a message with XMTP, they might experience a slight delay between sending the message and seeing their sent message display in their app UI.

Typically, the slight delay is caused by the app needing to wait for the XMTP network to finish processing the message before the app can display the message in its UI.

Messaging without optimistic sending:

![Messaging without optimistic sending. Note the slight delay after clicking Send.](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/without-opt-sending.gif)

Note the slight delay after clicking **Send**.

Implement optimistic sending to be able to immediately display the sent message in the sender's UI while processing the message in the background. This provides the user with immediate feedback and enables them to continue messaging without waiting for their previous message to finish processing.

Messaging with optimistic sending:

![Messaging with optimistic sending. The message displays immediately for the sender, with a checkmark indicator displaying once the message has been successfully sent.](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/with-opt-sending.gif)

The message displays immediately for the sender, with a checkmark indicator displaying once the message has been successfully sent.

### How it works

There are two steps to optimistically send a message:

1. Send the message to the local database so you can display it immediately in the sender's UI.
2. Publish the message to the XMTP network so it can be delivered to the recipient.

### 1. Optimistically send a message locally

Send the message to the local database. This ensures that the message will be there when you query for messages and can immediately display the message in the sender's UI.

:::code-group

```tsx [Browser]
// Optimistically send the message to the local database
conversation.sendOptimistic("Hello world");

// For custom content types, specify the content type
const customContent = { foo: "bar" };
const contentType = { authorityId: "example", typeId: "test", versionMajor: 1, versionMinor: 0 };
conversation.sendOptimistic(customContent, contentType);
```

```tsx [Node]
// Optimistically send the message to the local database
conversation.sendOptimistic("Hello world");

// For custom content types, specify the content type
const customContent = { foo: "bar" };
const contentType = { authorityId: "example", typeId: "test", versionMajor: 1, versionMinor: 0 };
conversation.sendOptimistic(customContent, contentType);
```

```tsx [React Native]
// Optimistically send the message to the local database
await conversation.prepareMessage("Hello world");

// For custom content types, specify the content type
const customContent = { foo: "bar" };
const contentType = new ContentTypeId({
  authorityId: "example",
  typeId: "test",
  versionMajor: 1,
  versionMinor: 0
});
await conversation.prepareMessage(customContent, contentType);
```

```kotlin [Kotlin]
// Optimistically send the message to the local database
conversation.prepareMessage("Hello world")

// For custom content types, specify the content type
val customContent = mapOf("foo" to "bar")
val contentType = ContentTypeId(
    authorityId = "example",
    typeId = "test",
    versionMajor = 1,
    versionMinor = 0
)
conversation.prepareMessage(customContent, contentType)
```

```swift [Swift]
// Optimistically send the message to the local database
try await conversation.prepareMessage("Hello world")

// For custom content types, specify the content type
let customContent = ["foo": "bar"]
let contentType = ContentTypeId(
    authorityId: "example",
    typeId: "test",
    versionMajor: 1,
    versionMinor: 0
)
try await conversation.prepareMessage(customContent, contentType: contentType)
```

:::

### 2. Publish an optimistically sent message to the network

After optimistically sending a message, use `publishMessages` to publish the message to the XMTP network so it can be delivered to recipients.

:::code-group

```tsx [Browser]
// Publish all pending optimistically sent messages to the network
// Call this only after using sendOptimistic to send a message locally
async function sendMessageWithOptimisticUI(conversation, messageText) {
  try {
    // Add message to UI immediately
    conversation.sendOptimistic(messageText);
    
    // Actually send the message to the network
    await conversation.publishMessages();
    return true;
  } catch (error) {
    console.error("Failed to send message:", error);
    return false;
  }
}
```

```tsx [Node]
// Publish all pending optimistically sent messages to the network
// Call this only after using sendOptimistic to send a message locally
async function sendMessageWithOptimisticUI(conversation, messageText) {
  try {
    // Add message to UI immediately
    conversation.sendOptimistic(messageText);
    
    // Actually send the message to the network
    await conversation.publishMessages();
    return true;
  } catch (error) {
    console.error("Failed to send message:", error);
    return false;
  }
}
```

```tsx [React Native]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
async function sendMessageWithOptimisticUI(conversation: Conversation, messageText: string): Promise<boolean> {
  try {
    // Add message to UI immediately
    await conversation.prepareMessage(messageText);
    
    // Actually send the message to the network
    await conversation.publishMessages();
    return true;
  } catch (error) {
    console.error("Failed to send message:", error);
    return false;
  }
}
```

```kotlin [Kotlin]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
suspend fun sendMessageWithOptimisticUI(conversation: Conversation, messageText: String): Boolean {
    return try {
        // Add message to UI immediately
        conversation.prepareMessage(messageText)
        
        // Actually send the message to the network
        conversation.publishMessages()
        true
    } catch (error: Exception) {
        Log.e("XMTP", "Failed to send message: ${error.message}", error)
        false
    }
}
```

```swift [Swift]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
func sendMessageWithOptimisticUI(conversation: Conversation, messageText: String) async throws -> Bool {
    do {
        // Add message to UI immediately
        try await conversation.prepareMessage(messageText)
        
        // Actually send the message to the network
        try await conversation.publishMessages()
        return true
    } catch {
        print("Failed to send message: \(error)")
        return false
    }
}
```

:::

### Key UX considerations for optimistically sent messages

- After optimistically sending a message, show the user an indicator that the message is still being processed. After successfully sending the message, show the user a success indicator.
  - An optimistically sent message initially has an `unpublished` status. Once published to the network, it has a `published` status. You can use this status to determine which indicator to display in the UI.
- If an optimistically sent message fails to send it will have a `failed` status. In this case, be sure to give the user an option to retry sending the message or cancel sending. Use a try/catch block to intercept errors and allow the user to retry or cancel.

## Handle unsupported content types

As more [custom](/chat-apps/content-types/custom) and [standards-track](/chat-apps/content-types/content-types#standards-track-content-types) content types are introduced into the XMTP ecosystem, your app may encounter content types it does not support. This situation, if not handled properly, could lead to app crashes.

Each message is accompanied by a `fallback` property, which offers a descriptive string representing the content type's expected value. It's important to note that fallbacks are immutable and are predefined in the content type specification. In instances where `fallback` is `undefined`, such as read receipts, it indicates that the content is not intended to be rendered. If you're venturing into creating custom content types, you're provided with the flexibility to specify a custom fallback string. For a deeper dive into this, see [Build custom content types](/chat-apps/content-types/custom).

:::code-group

```js [Browser]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```js [Node]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```jsx [React Native]
//contentTypeID has the following structure `${contentType.authorityId}/${contentType.typeId}:${contentType.versionMajor}.${contentType.versionMinor}`;
const isRegistered = message.contentTypeID in client.codecRegistry;
if (!isRegistered) {
  // Not supported content type
  if (message?.fallback != null) {
    return message?.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```kotlin [Kotlin]
val codec = client.codecRegistry.find(options?.contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```swift [Swift]
let codec = client.codecRegistry.find(for: contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

:::

## Support disappearing messages

Disappearing messages are messages that are intended to be visible to users for only a short period of time. After the message expiration time passes, the messages are removed from the UI and deleted from local storage so the messages are no longer accessible to conversation participants.

### App-level disappearing messages vs. network-level message expiration

Disappearing message behavior is enforced by apps, meaning that apps are responsible for removing messages from their UIs and local storage based on conditions set at the conversation level. As a feature, disappearing messages doesn't delete messages from the XMTP network.

Starting with XMTP mainnet, the network will enforce message expiration to delete messages from the network after a retention period currently targeted at 6 months. This message expiration is a general condition of the network and is not related to the disappearing messages feature.

To learn more, see [Message expiry](https://community.xmtp.org/t/xip-49-decentralized-backend-for-mls-messages/856) in XIP-49: Decentralized backend for MLS messages.

Disappearing messages can be understood as app-level privacy that helps avoid leaving an easily accessible record in a messaging UI, while XMTP mainnet message expiration is the mechanism by which messages are deleted from the network.

### Enable disappearing messages for a conversation

Conversation participants using apps that support disappearing messages will have a UX that honors the message expiration conditions. Conversation participants using apps that don't support disappearing messages won't experience disappearing message behavior.

Messages abide by the disappearing message settings for the conversation.

When creating or updating a conversation, only group admins and DM participants can set disappearing message expiration conditions.

This includes setting the following conditions expressed in nanoseconds (ns):

- `disappearStartingAtNs`: Starting timestamp from which the message lifespan is calculated
- `retentionDurationInNs`: Duration of time during which the message should remain visible to conversation participants

For example:

1. Set `disappearStartingAtNs` to the current time, such as `1738620126404999936` (nanoseconds since the Unix epoch of January 1, 1970).
2. Set `retentionDurationInNs` to the message lifespan, such as 1800000000000000 (30 minutes).
3. Use `disappearStartingAtNs` and `retentionDurationInNs` to calculate the message expiration time of `1738620126404999936 + 1800000000000000 = 1740420126404999936`.

To learn more see [conversation.rs](https://github.com/xmtp/libxmtp/blob/main/bindings_node/src/conversation.rs#L49).

### Set disappearing message settings on conversation create

For example:

:::code-group

```js [Browser]
// DM
await client.conversations.newDm(
  inboxId,
  {
    messageDisappearingSettings: {
      fromNs: 1738620126404999936n,
      inNs: 1800000000000000n
    }
  }
)

// Group
await client.conversations.newGroup(
  [inboxId],
  { 
    messageDisappearingSettings: {
      fromNs: 1738620126404999936n,
      inNs: 1800000000000000n
    }
  }
)
```

```js [Node]
// DM
await client.conversations.newDm(
  inboxId,
  {
    messageDisappearingSettings: {
      fromNs: 1738620126404999936,
      inNs: 1800000000000000
    }
  }
)

// Group
await client.conversations.newGroup(
  [inboxId],
  { 
    messageDisappearingSettings: {
      fromNs: 1738620126404999936,
      inNs: 1800000000000000
    }
  }
)
```

```tsx [React Native]
// DM
await client.conversations.newConversation(
  inboxId,
  {
    disappearingMessageSettings: DisappearingMessageSettings(
      disappearStartingAtNs: 1738620126404999936,
      retentionDurationInNs: 1800000000000000
    )
  }
)

// Group
await client.conversations.newGroup(
  [inboxId],
  { 
    disappearingMessageSettings: DisappearingMessageSettings(
      disappearStartingAtNs: 1738620126404999936,
      retentionDurationInNs: 1800000000000000
    )
  }
)
```

```kotlin [Kotlin]
// DM
client.conversations.newConversation(
    inboxId,
    disappearingMessageSettings = DisappearingMessageSettings(
        disappearStartingAtNs = 1738620126404999936,
        retentionDurationInNs = 1800000000000000
    )
)

// Group
client.conversations.newGroup(
    [inboxId],
    disappearingMessageSettings = DisappearingMessageSettings(
        disappearStartingAtNs = 1738620126404999936,
        retentionDurationInNs = 1800000000000000
    )
)
```

```swift [Swift]
// DM
try await client.conversations.newConversation(
    with: inboxId,
    disappearingMessageSettings: DisappearingMessageSettings(
        disappearStartingAtNs: 1738620126404999936,
        retentionDurationInNs: 1800000000000000
    )
)

// Group
try await client.conversations.newGroup(
    with: [inboxId],
    disappearingMessageSettings: DisappearingMessageSettings(
        disappearStartingAtNs: 1738620126404999936,
        retentionDurationInNs: 1800000000000000
    )
)
```

:::

### Update disappearing message settings for an existing conversation

For example:

:::code-group

```tsx [Browser]
// Update disappearing message settings
await conversation.updateMessageDisappearingSettings(1738620126404999936n, 1800000000000000n)

// Clear disappearing message settings
await conversation.removeMessageDisappearingSettings()
```

```tsx [Node]
// Update disappearing message settings
await conversation.updateMessageDisappearingSettings(1738620126404999936, 1800000000000000)

// Clear disappearing message settings
await conversation.removeMessageDisappearingSettings()
```

```tsx [React Native]
await conversation.updateDisappearingMessageSettings(updatedSettings)
await conversation.clearDisappearingMessageSettings()
```

```kotlin [Kotlin]
conversation.updateDisappearingMessageSettings(updatedSettings)
conversation.clearDisappearingMessageSettings()
```

```swift [Swift]
try await conversation.updateDisappearingMessageSettings(updatedSettings)
try await conversation.clearDisappearingMessageSettings()
```

:::

### Get the disappearing message settings for a conversation

For example:

:::code-group

```tsx [Browser]
// Get the disappearing message settings
const settings = await conversation.messageDisappearingSettings()

// Check if disappearing messages are enabled
const isEnabled = await conversation.isDisappearingMessagesEnabled()
```

```tsx [Node]
// Get the disappearing message settings
const settings = conversation.messageDisappearingSettings()

const isEnabled = conversation.isDisappearingMessagesEnabled()
```

```tsx [React Native]
conversation.disappearingMessageSettings
conversation.isDisappearingMessagesEnabled()
```

```kotlin [Kotlin]
conversation.disappearingMessageSettings
conversation.isDisappearingMessagesEnabled
```

```swift [Swift]
conversation.disappearingMessageSettings
try conversation.isDisappearingMessagesEnabled()
```

:::

### Automatic deletion from local storage

A background worker runs every one second to clean up expired disappearing messages. The worker automatically deletes expired messages from local storage. No additional action is required by integrators.

To learn more about the background worker, see [disappearing_messages.rs](https://github.com/xmtp/libxmtp/blob/main/xmtp_mls/src/groups/disappearing_messages.rs#L68).

### Automatic removal from UI

Expired messages don't require manual removal from the UI. If your app UI updates when the local storage changes, expired messages will disappear automatically when the background worker deletes them from local storage.

### Receive a disappearing message

On the receiving side, your app doesn't need to check expiration conditions manually. Receive and process messages as usual, and the background worker handles message expiration cleanup.

### UX tips for disappearing messages

To ensure that users understand which messages are disappearing messages and their behavior, consider implementing:

- A distinct visual style: Style disappearing messages differently from regular messages (e.g., a different background color or icon) to indicate their temporary nature.
- A clear indication of the message's temporary nature: Use a visual cue, such as a timestamp or a countdown, to inform users that the message will disappear after a certain period.


## pages/chat-apps/core-messaging/group-metadata.mdx
# Manage group chat metadata

Group chats can have metadata, like names, descriptions, and images. Metadata can help users more easily identify their group chats. You can set group chat metadata when [creating a group chat](/chat-apps/core-messaging/create-conversations), and get and update metadata using these methods.

## Updatable group chat metadata

The following group chat metadata can be updated:

- `group_name`: The name of the group chat
- `description`: A description of the group chat
- `image_url`: A URL pointing to an image for the group chat
- `disappearing_message_settings`: Settings for disappearing messages in the group chat. To learn more about disappearing messages, see [Support disappearing messages](/chat-apps/core-messaging/send-messages#support-disappearing-messages)

## Get a group chat name

:::code-group

```js [Browser]
const groupName = group.name;
```

```js [Node]
const groupName = group.name;
```

```tsx [React Native]
const groupName = await group.groupName();
```

```kotlin [Kotlin]
group.name
```

```swift [Swift]
try group.groupname()
```

:::

## Update a group chat name

:::code-group

```js [Browser]
await group.updateName("New Group Name");
```

```js [Node]
await group.updateName("New Group Name");
```

```tsx [React Native]
await group.updateName("New Group Name");
```

```kotlin [Kotlin]
group.updateName("New Group Name")
```

```swift [Swift]
try await group.updateName(groupname: "New Group Name")
```

:::

## Get a group chat description

:::code-group

```js [Browser]
const groupDescription = group.description;
```

```js [Node]
const groupDescription = group.description;
```

```tsx [React Native]
const groupDescription = await group.groupDescription();
```

```kotlin [Kotlin]
group.description
```

```swift [Swift]
try group.groupDescription()
```

:::

## Update a group chat description

:::code-group

```js [Browser]
await group.updateDescription("New Group Description");
```

```js [Node]
await group.updateDescription("New Group Description");
```

```tsx [React Native]
await group.updateDescription("New Group Description");
```

```kotlin [Kotlin]
group.updateDescription("New Group Description")
```

```swift [Swift]
try await group.updateDescription(Description: "New Group Description")
```

:::

## Get a group chat image URL

:::code-group

```js [Browser]
const groupImageUrl = group.imageUrl;
```

```js [Node]
const groupImageUrl = group.imageUrl;
```

```tsx [React Native]
const groupName = await group.imageUrl();
```

```kotlin [Kotlin]
group.imageURL
```

```swift [Swift]
try group.imageUrl()
```

:::

## Update a group chat image URL

:::code-group

```js [Browser]
await group.updateImageUrl("newurl.com");
```

```js [Node]
await group.updateImageUrl("newurl.com");
```

```tsx [React Native]
await group.updateImageUrl("ImageURL");
```

```kotlin [Kotlin]
group.updateImageUrl("newurl.com")
```

```swift [Swift]
try await group.updateImageUrl(imageUrl: "newurl.com")
```

:::


## pages/chat-apps/core-messaging/support-group-invite-links.mdx
# Support group chat invite links

This document provides suggested paths you might take to provide XMTP group chat invite links in your app. These are just proposals and the actual implementation direction and details are specific to your app and your goals.

## Possible user experience flows

1. A group member with permission to add group members [creates an invite link](#create-a-group-invite-link).
2. An non-member clicks the invite link to [request to join the group](#generate-an-invite-landing-page).
3. The non-member is granted access to the group in one of the following ways:
    - [Automatic join via silent push notification to the link creator](#automatic-join-via-silent-push-notification-to-link-creator)
    - [Automatic join via silent push notification to all group members](#automatic-join-via-silent-push-notification-to-all-group-members)
    - [Manual join via push notification to the link creator](#manual-join-via-push-notification-to-link-creator)
4. [Add the invitee to the group](#add-the-member-to-the-group)
5. [Check and manage the invite status](#check-the-invite-status)

### Sequence diagrams

These diagrams help illustrate the sequence of interactions between users and participating systems for the suggested options for granting group access to an invitee.

#### Option 1: Automatic join via silent push notification to the link creator

<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/Automatic-Join-via-Silent-Push-to-Link-Creator.png" alt="Sequence diagram for Automatic join via silent push notification to the link creator" />

#### Option 2: Automatic join via silent push notification to all group members

<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/Automatic-Join-via-Silent-Push-to-All-Group-Members.png" alt="Sequence diagram for Automatic join via silent push notification to all group members" />

#### Option 3: Manual join via push notification to the link creator

<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/Manual-Join-via-Push-Notification-to-Link-Creator.png" alt="Sequence diagram for Manual join via push notification to the link creator" />

## Create a group invite link

You can provide a UI that enables a group member with permission to add members to create an invite link.

Create the group invite by making a `POST` to a `/groupInvite` endpoint with any metadata your app wants to show on an invite landing page that will be displayed when an invitee clicks the invite link.

### `POST /groupInvite`

**Example request**

```json
{
 groupName: "XMTP Builders",
 groupImage: "https://...",
// Inviter can be inferred from the request auth token.
// Backend doesn't need the actual group ID, since the client can keep track in their DB
}
```

**Example response**

The backend returns a new invite link with a unique URL.

Save the `linkUrl` to the client's local database (alongside the XMTP `group_id`) so the link can be surfaced in the UI for copy/paste later and used in push notification handlers.

```json
{
 id: "abcdefg",
 linkUrl: "https://converse.xyz/invite/abcdefg"
}
```

## Generate an invite landing page

When a user clicks the invite link, the link can display a group invite landing page at `app.xyz`, for example.

To get the information to generate the invite landing page, you can make a `GET` to a `/groupInvite/:id` endpoint.

For example, the invite landing page can display the group name, the invite link creator's profile, any other group metadata the app wants to show, and a Join button.

When a user clicks the Join button on the invite landing page:

- If the user doesn't have the app installed, the link can take them to an app store where they can be prompted to install the app. Once installed, the user can be returned to the invite landing page, where they can click Join again.
- If the user does have the app installed, the link can open the app. The app can display the conversation list view with the new group grayed out to indicate a pending status.

### `GET /groupInvite/:id`

**Example request**

```html
GET /groupInvite/abcdefg
```

**Example response**

```json
{
 id: "abcdefg",
 linkUrl: "https://app.xyz/invite/abcdefg",
 groupName: "XMTP Builders",
 groupImage: "https://...",
 createdBy: <InboxId>
}
```

### `POST /groupJoinRequest`

Can be used by the invitee to request to join the group.

**Example request**

```json
{
 inviteId: "abcdefg", // User info implied from auth token
}
```

**Example response**

```json
{
 id: "hijklmn", // The id of the join request
 status: "pending"
}
```

## Handle the request to join the group

When the invitee clicks the invite link to request to join the group, consider granting them access to the group in one of the following ways.

### Automatic join via silent push notification to link creator

As soon as the link creator is detected as being online, they can receive a silent push notification that automatically adds the invitee to the group. This can make the join appear automatic.

**Example request**

```json
{
  "inviteId": "abcdefg",
  "joinRequestId": "hijklmn",
  "recipientId": "user123",
  "groupName": "XMTP Builders",
  "type": "auto_join_creator"
}
```

**Example response**

```json
{
  "success": true,
  "status": "processing",
  "message": "Silent push notification sent to link creator"
}
```

### Automatic join via silent push notification to all group members

If the group permits all members to add members, consider sending a silent background push notification to all group members.

The first member detected as being online can receive a silent push notification that automatically adds the invitee to the group. This can make the join appear automatic.

This setup can take the dependency off the sole link creator being online and spreads it across the group, which can allow the group join to happen faster.

**Example request**

```json
{
  "inviteId": "abcdefg",
  "joinRequestId": "hijklmn",
  "recipientId": "user123",
  "groupName": "XMTP Builders",
  "type": "auto_join_members",
  "groupMembers": ["member1", "member2", "member3"]
}
```

**Example response**

```json
{
  "success": true,
  "status": "processing",
  "message": "Silent push notifications sent to all group members",
  "notificationsSent": 3
}
```

### Manual join via push notification to link creator

Consider having the link creator receive a push notification about a specific invitee requesting to join the group using their invite link. Enable the link creator to approve or reject the request.

For example, you can send a push notification to the invite link creator saying, "User X has requested to join Group Y through your invite link." Give the link creator a way to approve or reject the request.

**Example request**

```json
{
  "inviteId": "abcdefg",
  "joinRequestId": "hijklmn",
  "recipientId": "user123",
  "groupName": "XMTP Builders",
  "type": "manual_approval",
  "requesterName": "Alix A",
  "requesterAvatar": "https://example.com/avatar.jpg"
}
```

**Example response**

```json
{
  "success": true,
  "status": "pending_approval",
  "message": "Push notification sent to link creator for manual approval"
}
```

### Handle push notification delivery failure

To handle cases where the push notification fails to deliver (maybe the user is offline for a while), XMTP can provide an API that enables clients to check for any pending joins.

Want XMTP to build this API? [Open an issue](https://github.com/xmtp/libxmtp/issues) in the LibXMTP repo to request it.

**Example request**

```json
{
  "userId": "user123",
  "lastCheckTimestamp": "2024-03-20T10:00:00Z"
}
```

**Example response**

```json
{
  "pendingJoins": [
    {
      "inviteId": "abcdefg",
      "joinRequestId": "hijklmn",
      "groupName": "XMTP Builders",
      "status": "pending",
      "requestedAt": "2024-03-20T09:30:00Z"
    }
  ],
  "lastCheckTimestamp": "2024-03-20T10:00:00Z"
}
```

## Add the member to the group

If the invite link creator approves the request, in the background, you can call LibXMTP to load the group and add the member.

**Example request**

```json
{
 inviteId: "abcdefg", // User info implied from auth token
}
```

**Example response**

```json
{
 id: "hijklmn" // id of the join request
 status: 'pending'
}
```

## Check the invite status

### `/groups/joinFromInvite`

You can poll a `/groups/joinFromInvite` endpoint to check the invite status and know when the invite link creator has marked it as approved or rejected.

### `GET /groupJoinRequest/:id`

You can provide this endpoint as a way for an invitee to check the status of their request to join a group.

**Example request**

```html
GET /groupJoinRequest/hijklmn
```

**Example response**

```json
{
 id: "hijklmn",
 status: "approved"// Possible statuses ("approved", "rejected", "pending")
 reason: null // Allow the system to pass a reason back to the client
}
```

## Mark the invite request as complete

Once the invite link creator has approved or rejected the request, you can make a `PUT` to a `/groupJoinRequest/:id` endpoint to mark the request as completed.

### `PUT /groupJoinRequest/:id`

**Example request**

You can have the invite link creator mark an invite as approved or rejected. For basic invite links, approval can happen as soon as the push notification has been received.

```json
{
 status: "approved"
}
```

**Example response**

```json
{
 id: "hijklmn",
 status: "approved",
 reason: null // Allow the system to pass a reason back to the client
}
```


## pages/chat-apps/core-messaging/manage-inboxes.mdx
# Manage XMTP inboxes, identities, and installations

With XMTP, a user can have one or more **inboxes** they use to access their messages. An inbox ID is a stable identifier for a user's messaging identity and is used as the destination for messages in direct message and group conversations. It is derived from the public key material in their key package.

An inbox can have multiple **identities** associated with it. An identity has a kind, such as EOA or SCW, and a string, which in the case of an EOA or SCW, is an Ethereum address. However, this extensible inbox-based identity model means that support for additional kinds of identities, such as Passkey or Bitcoin, can be added in the future.

All messages associated with these identities flow through the one inbox ID and are accessible in any XMTP app.

The first time someone uses your app with an identity they've never used with any app built with XMTP, your app creates an inbox ID and **installation** associated with the identity. To do this, you [create a client](/chat-apps/core-messaging/create-a-client) for their identity.

:::tip[Note for agent developers]

The installation concepts described in this document apply to both inbox apps and agents. However, the context differs. **Inbox apps** typically have installations across different devices and apps (phone, laptop, different XMTP apps), while **agents** typically have installations across different deployment environments (local development, Railway, production servers).

For more agent-specific guidance, see [Manage agent installations](/agents/core-messaging/agent-installations).
:::

The client creates an inbox ID and installation ID associated with the identity. By default, this identity is designated as the recovery identity. A recovery identity will always have the same inbox ID and cannot be reassigned to a different inbox ID.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/create-inbox-install.png" width="250px" />
</div>

When you make subsequent calls to create a client for the same identity and a local database is not present, the client uses the same inbox ID, but creates a new installation ID.

An inbox ID can have up to 10 app installations before it needs to [revoke installations](#revoke-installations).

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/add-installation.png" width="250px" />
</div>

You can enable a user to add multiple identities to their inbox. Added identities use the same inbox ID and the installation ID of the installation used to add the identity.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/add-id.png" width="350px" />
</div>

You can enable a user to remove an identity from their inbox. You cannot remove the recovery identity.

## Inbox update and installation limits

### 🎥 walkthrough: Installation limits and static revocation

This video provides a walkthrough of the idea behind the XMTP installation limit (10) and how to use [static installation revocation](#revoke-installations-for-a-user-who-cant-log-in). After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/66bHc_MBQKo?si=5ZuqFBrQm885ILSk" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

An inbox ID is limited to 256 inbox updates. Inbox updates include actions like:

- Add a wallet
- Remove a wallet
- Add an installation
- Revoke an installation

This means that one inbox ID can have up to 256 installations. When you add an inbox ID to a group, you are adding every installation as a member of the group. This means a group with an inbox that has 200+ installations can very quickly make a group size very large, which can have downstream performance implications.

If an inbox is allowed to reach its limit of 256 inbox updates, the user will need to [rotate their inbox](#rotate-an-inbox-id) to continue using their identity with XMTP. Rotating their inbox will cause the user to lose of their existing conversations, but will enable them to continue using their identity with new XMTP conversations.

To avoid this scenario altogether, inboxes are limited to having only 10 active installations. When an inbox has 10 active installations, the user must revoke 1 installation before they are able to add another. This helps keep groups to a reasonable size and also helps keep users from accidentally reaching the 256 limit. However, note that revoking a installation counts toward the 256 inbox update limit, so frequently revoking installations and adding new ones can still cause a user to quickly reach the inbox update limit.

Have feedback about the inbox update and installation limits? We'd love to hear it. Post to the [XMTP Community Forums](https://community.xmtp.org/).

### Rotate an inbox ID

When you create an inbox ID, there is a nonce on it that is used to create the ID. If an inbox reaches its inbox updates limit, you can increment the nonce and it will create a new inbox ID associated with the user's information.

## Help users manage installations

By default, your app stores the following information about installations:

- `id` (random byte array)
- `createdAt` (date)

To help users make informed decisions when managing and revoking their installations, you should aim to store additional useful information about installations, such as:

- Last date logged in
- Device make and model

Installation IDs that don't have this additional information can be treated as unknown installations, which can also provide helpful signals to users.

## Revoke installations

### 🎥 walkthrough: Revoking installations

This video provides a walkthrough of revoking installations, covering the key ideas discussed in this doc. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/MIw9x1Z4WXw?si=4bcbfkHTDvsM0uDG" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

### Revoke a specific installation

You can revoke one or more specific installations by ID, as long as it isn't the currently accessed installation.

An inbox ID can have up to 10 app installations before it needs to revoke an installation.

- If an inbox ID has 10 installations and the user wants to add another installation, use this function to enable them to revoke an installation before they can add the new one.

- If an inbox ID was created before this installation limit was implemented, the inbox ID might have more than 10 installations. If this is the case, the user will receive an error when they try to add another installation. Use this function to enable them to revoke the required number of installations before they can add the new one. For example, if an inbox ID has 20 installations, the user will need to revoke 11 installations before they can add the new one.

If preferred, you can use the [revoke all other installations](#revoke-all-other-installations) function to revoke all installations other than the currently accessed installation.

:::code-group

```tsx [Browser]
await client.revokeInstallations([installationId1, installationId2])
```

```tsx [Node]
await client.revokeInstallations([installationId1, installationId2])
```

```jsx [React Native]
await client.revokeInstallations(signingKey, [installationIds])
```

```kotlin [Kotlin]
client.revokeInstallations(signingKey, listOf(installationIds))
```

```swift [Swift]
try await client.revokeInstallations(signingKey, [installationIds])
```

:::

### Revoke all other installations

You can revoke all installations other than the currently accessed installation.

For example, consider a user using this current installation:

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/current-install-id.png" width="350px" />
</div>

When the user revokes all other installations, the action removes their identity's access to all installations other than the current installation:

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/revoke-install-id.png" width="350px" />
</div>

An inbox ID can have up to 10 app installations before it needs to revoke an installation.

If preferred, you can use the [revoke a specific installation](#revoke-a-specific-installation) function to revoke one or more specific installations by ID.

:::code-group

```tsx [Browser]
await client.revokeAllOtherInstallations()
```

```tsx [Node]
await client.revokeAllOtherInstallations()
```

```jsx [React Native]
await client.revokeAllOtherInstallations(signingKey)
```

```kotlin [Kotlin]
client.revokeAllOtherInstallations(signingKey)
```

```swift [Swift]
try await client.revokeAllOtherInstallations(signingKey)
```

:::

### Revoke installations for a user who can't log in

For a video walkthrough of this feature, see [🎥 walkthrough: Installation limits and static revocation](#-walkthrough-installation-limits-and-static-revocation).

Static installation revocation enables users to revoke installations without needing to log in or have access to their installations.

This feature is especially useful in the following scenarios:

- A user has reached the 10 installation limit and can't log in to revoke installations to make room for a new installation.
- A user logs out of an app installation and chooses the option to delete their local database. Choosing this option will cause them to permanently lose access to the installation. For this reason, you should revoke the installation.

In both scenarios, static revocation enables logged out users to revoke installations using only their recovery address signer.

Here is how static installation revocation works behind the scenes:

1. Determines which installation IDs to revoke
2. Generates a signature request for the revocation
3. Uses the recovery address signer to authorize the revocation
4. Submits the signed request to revoke the specified installations

:::code-group

```tsx [Browser]
const inboxStates = await Client.inboxStateFromInboxIds([inboxId], "production");

const toRevokeInstallationBytes = inboxStates[0].installations.map((i) => i.bytes);

await Client.revokeInstallations(
  signer,
  inboxId,
  toRevokeInstallationBytes,
  "production", // optional, defaults to "dev"
  enableLogging: true, // optional, defaults to false
);
```

```tsx [Node]
const inboxStates = await Client.inboxStateFromInboxIds([inboxId], "production");

const toRevokeInstallationBytes = inboxStates[0].installations.map((i) => i.bytes);

await Client.revokeInstallations(
  signer,
  inboxId,
  toRevokeInstallationBytes,
  "production", // optional, defaults to "dev"
);
```

```jsx [React Native]
const states = await Client.inboxStatesForInboxIds('production', [inboxId])

const toRevokeIds = states[0].installations.map((i) => i.id)

await Client.revokeInstallations(
  'production',
  recoveryWallet,
  inboxId,
  toRevokeIds as InstallationId[]
)
```

```kotlin [Kotlin]
        val states = Client.inboxStatesForInboxIds( listOf(inboxId), api)
  
 val toRevokeIds = states.first().installations.map { it.id }

 Client.revokeInstallations(
  api,
  recoveryWallet,
  inboxId,
  toRevokeIds
 )
```

```swift [Swift]
        let states = try await Client.inboxStatesForInboxIds(inboxIds: [inboxId], api)
  
 let toRevokeIds = states.first.installations.map { $0.id }

 try await Client.revokeInstallations(
  api: api,
  signingKey: recoveryWallet,
  inboxId: inboxId,
  installationIds: toRevokeIds
 )
```

:::

## View the inbox state

Find an `inboxId` for an identity:

:::code-group

```tsx [Browser]
const inboxState = await client.preferences.inboxState()
```

```tsx [Node]
const inboxState = await client.preferences.inboxState()
```

```jsx [React Native]
const inboxId = await client.inboxIdFromIdentity(identity)
```

```kotlin [Kotlin]
val inboxId = client.inboxIdFromIdentity(identity)
```

```swift [Swift]
let inboxId = try await client.inboxIdFromIdentity(identity: identity)
```

:::

View the state of any inbox to see the identities, installations, and other information associated with the `inboxId`.

**Sample request**

:::code-group

```tsx [Browser]
// the second argument is optional and refreshes the state from the network.
const states = await client.preferences.inboxStateFromInboxIds([inboxId, inboxId], true)
```

```tsx [Node]
// the second argument is optional and refreshes the state from the network.
const states = await client.preferences.inboxStateFromInboxIds([inboxId, inboxId], true)
```

```jsx [React Native]
const state = await client.inboxState(true)
const states = await client.inboxStates(true, [inboxId, inboxId])
```

```kotlin [Kotlin]
val state = client.inboxState(true) 
val states = client.inboxStatesForInboxIds(true, listOf(inboxID, inboxID))
```

```swift [Swift]
let state = try await client.inboxState(refreshFromNetwork: true)
let states = try await client.inboxStatesForInboxIds(
 refreshFromNetwork: true,
 inboxIds: [inboxID, inboxID]
)
```

:::

**Sample response**

```json
InboxState
{
  "recoveryIdentity": "string",
  "identities": [
    {
      "kind": "ETHEREUM",
      "identifier": "string",
      "relyingPartner": "string"
    },
    {
      "kind": "PASSKEY",  // not yet supported; provided as an example only.
      "identifier": "string",
      "relyingPartner": "string"
    }
  ],
  "installations": ["string"],
  "inboxId": "string"
}
```

## Add an identity to an inbox

:::warning[Warning]

This function is delicate and should be used with caution. Adding an identity to an inbox ID B when it's already associated with an inbox ID A will cause the identity to lose access to inbox ID A.

:::

:::code-group

```tsx [Browser]
await client.unsafe_addAccount(signer, true)
```

```tsx [Node]
await client.unsafe_addAccount(signer, true)
```

```jsx [React Native]
await client.addAccount(identityToAdd)
```

```kotlin [Kotlin]
client.addAccount(identityToAdd)
```

```swift [Swift]
try await client.addAccount(newAccount: identityToAdd)
```

:::

## Remove an identity from an inbox

:::tip[Note]
 A recovery identity cannot be removed. For example, if an inbox has only one associated identity, that identity serves as the recovery identity and cannot be removed.
:::

:::code-group

```tsx [Browser]
await client.removeAccount(identifier)
```

```tsx [Node]
await client.removeAccount(identifier)
```

```jsx [React Native]
await client.removeAccount(recoveryIdentity, identityToRemove)
```

```kotlin [Kotlin]
client.removeAccount(recoveryIdentity, identityToRemove)
```

```swift [Swift]
try await client.removeAccount(recoveryIdentity: recoveryIdentity, identityToRemove: identityToRemove)
```

:::

## Select the identity to display

When an inbox has multiple associated identities, the `identities` array is ordered by the `client_timestamp_ns` field, which sorts identities based on when they were added to the inbox, placing the earliest added identity first.

This provides consistent display ordering and helps establish norms for which identity should be used for UI display purposes.

For UI display purposes, you can use the following logic to select the most appropriate identity:

1. If there is only one identity in the `identities` array, use that as the display identity.
2. If there are two identities, use the one that does not match the `recoveryIdentity`. The first non-recovery identifier in the array is typically the preferred identity for display.
3. If there are more than two identities, the first non-recovery identity in the ordered array is typically the preferred identity for display.

## FAQ

### What happens when a user removes an identity?

Consider an inbox with three associated identities:

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/three-ids.png" width="650px" />
</div>

If the user removes an identity from the inbox, the identity no longer has access to the inbox it was removed from.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/removed-id.png" width="650px" />
</div>

The identity can no longer be added to or used to access conversations in that inbox. If someone sends a message to the identity, the message is not associated with the original inbox. If the user logs in to a new installation with the identity, this will create a new inbox ID.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/new-inbox-id.png" width="650px" />
</div>

### How is the recovery identity used?

The recovery identity and its signer can be used to sign transactions that remove identities and revoke installations.

For example, Alix can give Bo access to their inbox so Bo can see their groups and conversations and respond for Alix.

If Alix decides they no longer want Bo have access to their inbox, Alix can use their recovery identity signer to remove Bo.

However, while Bo has access to Alix's inbox, Bo cannot remove Alix from their own inbox because Bo does not have access to Alix's recovery identity signer.

### If a user created two inboxes using two identities, is there a way to combine the inboxes?

If a user logs in with an identity with address 0x62EE...309c and creates inbox 1 and then logs in with an identity with address 0xd0e4...DCe8 and creates inbox 2; there is no way to combine inbox 1 and 2.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/two-inboxes.png" width="350px" />
</div>

You can add an identity with address 0xd0e4...DCe8 to inbox 1, but both identities with addresses 0x62EE...309c and 0xd0e4...DCe8 would then have access to inbox 1 only. The identity with address 0xd0e4...DCe8 would no longer be able to access inbox 2.

<div>
  <img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/two-inbox-remap-id.png" width="350px" />
</div>

To help users avoid this state, ensure that your UX surfaces their ability to add multiple identities to a single inbox.

### What happens if I remove an identity from an inbox ID and then initiate a client with the private key of the removed identity?

**Does the client create a new inbox ID or does it match it with the original inbox ID the identity was removed from?**

The identity used to initiate a client should be matched to its original inbox ID.

You do have the ability to rotate inbox IDs if a user reaches the limit of 256 identity actions (adding, removing, or revoking identities or installations). Hopefully, users won't reach this limit, but if they do, inbox IDs have a nonce and can be created an infinite number of times.

However, anytime a new inbox ID is created for an identity, the conversations and messages in any existing inbox ID associated with the identity are lost.

### I have multiple identities associated with one inbox ID. If I log in with any one of these identities, does it access that inbox ID, or does it create a new inbox ID?

The identity accesses that inbox ID and does not create a new inbox ID.

For example, let's say that you create a client with an identity with address 0x62EE...309c. Inbox ID 1 is generated from that identity.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/inbox1-id1.png" width="150px" />
</div>

If you then add an identity with address 0xd0e4...DCe8 to inbox ID 1, the identity is also associated with inbox ID 1.

If you then log into a new app installation with the identity with address 0xd0e4...DCe8, it accesses inbox ID 1 and does not create a new inbox ID.

Once the identity with address 0xd0e4...DCe8 has been associated with inbox ID 1, it can then be used to log into inbox ID 1 using a new app installation.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/inbox1-id1-id2.png" width="350px" />
</div>

The inverse is also true. Let's say an identity with address 0xd0e4...DCe8 was previously used to create and log into inbox ID 2.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/inbox1-id1-inbox2-id2.png" width="350px" />
</div>

If the identity is then added as an associated identity to inbox ID 1, the identity will no longer be able to log into inbox ID 2.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/inbox1-id1-id2-inverse.png" width="350px" />
</div>

To enable the user of the identity with address 0xd0e4...DCe8 to log into inbox ID 2 again, you can use the recovery identity for inbox ID 2 to add a different identity to inbox ID 2 and have the user use that identity access it.

If you are interested in providing this functionality in your app and want some guidance, post to the [XMTP Community Forums](https://community.xmtp.org).


## pages/chat-apps/core-messaging/create-conversations.mdx
# Create conversations

## Check if an identity is reachable

The first step to creating a conversation is to verify that participants' identities are reachable on XMTP. The `canMessage` method checks each identity's compatibility, returning a response indicating whether each identity can receive messages.

Once you have the verified identities, you can create a new conversation, whether it's a group chat or direct message (DM).

:::code-group

```js [Browser]
import { Client, type Identifier } from "@xmtp/browser-sdk";

const identifiers: Identifier[] = [
  { identifier: "0xboAddress", identifierKind: "Ethereum" },
  { identifier: "0xcaroAddress", identifierKind: "Ethereum" }
];

// response is a Map of string (identifier) => boolean (is reachable)
const response = await Client.canMessage(identifiers);
```

```js [Node]
import { Client, IdentifierKind, type Identifier } from "@xmtp/node-sdk";

const identifiers: Identifier[] = [
  { identifier: "0xboAddress", identifierKind: IdentifierKind.Ethereum },
  { identifier: "0xcaroAddress", identifierKind: IdentifierKind.Ethereum }
];

// response is a Map of string (identifier) => boolean (is reachable)
const response = await Client.canMessage(identifiers);
```

```tsx [React Native]
// Request
const canMessage = await client.canMessage([
  boIdentity,
  v2OnlyIdentity,
  badIdentity,
])

// Response
{
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
}
```

```kotlin [Kotlin]
// Request
val boIdentity = Identity(ETHEREUM, '0xboAddress')
val v2Identity = Identity(ETHEREUM, '0xV2OnlyAddress')
val badIdentity = Identity(ETHEREUM, '0xBadAddress')

val canMessage = client.canMessage(listOf(boIdentity, v2Identity, badIdentity))

// Response
[
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
]
```

```swift [Swift]
// Request
let canMessage = try await client.canMessage([boIdentity, v2OnlyIdentity, badIdentity])

// Response
[
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
]
```

:::

## Create a new group chat

Once you have the verified identities, create a new group chat. The maximum group chat size is 250 members.

:::tip
If you want to provide faster and offline group creation, consider using [optimistic group chat creation](#optimistically-create-a-new-group-chat) instead. This approach enables instant group creation and message preparation before adding members and even when offline.
:::

:::code-group

```js [Browser]
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);
```

```js [Node]
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);
```

```tsx [React Native]
// New Group
const group = await alix.conversations.newGroup([bo.inboxId, caro.inboxId]);

// New Group with Metadata
const group = await alix.conversations.newGroup([bo.inboxId, caro.inboxId], {
  name: "The Group Name",
  imageUrl: "www.groupImage.com",
  description: "The description of the group",
  permissionLevel: "admin_only", // 'all_members' | 'admin_only'
});
```

```kotlin [Kotlin]
// New Group
val group = alix.conversations.newGroup(listOf(bo.inboxId, caro.inboxId))

// New Group with Metadata
val group = alix.conversations.newGroup(listOf(bo.inboxId, caro.inboxId),
  permissionLevel = GroupPermissionPreconfiguration.ALL_MEMBERS, // ALL_MEMBERS | ADMIN_ONLY
  name = "The Group Name",
  imageUrl = "www.groupImage.com",
  description = "The description of the group",
)
```

```swift [Swift]
// New Group
let group = try await alix.conversations.newGroup([bo.inboxId, caro.inboxId])

// New Group with Metadata
let group = try await alix.conversations.newGroup([bo.inboxId, caro.inboxId],
  permissionLevel: .admin_only, // .all_members | .admin_only
  name: "The Group Name",
  imageUrl: "www.groupImage.com",
  description: "The description of the group",
)
```

:::

## Optimistically create a new group chat

Optimistic group creation enables instant group chat creation and message preparation before adding members and even when offline. This approach prioritizes user experience by allowing immediate interaction with the group chat, while handling the network synchronization in the background when members are added.

Use this method to optimistically create a group chat, which enables a user to create a group chat now and add members later.

The group chat can be created with any number of [standard options](#create-a-new-group-chat), or no options. The group chat is stored only in the local storage of the app installation used to create it. In other words, the group chat is visible only to the creator and in the app installation they used to create it.

You can prepare messages for the optimistic group chat immediately using `prepareMessage()`. As with the group chat itself, these messages are stored locally only.

When you want to add members, you use [`addMembers()`](#optimistically-create-a-new-group-chat) with a list of inbox IDs.

Adding a member will automatically sync the group chat to the network. Once synced, the group chat becomes visible to the added members and across other app installations.

After adding members, you must explicitly call `publishMessages()` to send any prepared messages to the network.

To learn more about optimistically sending messages using `prepareMessage()` and `publishMessages()`, see [Optimistically send messages](/chat-apps/core-messaging/send-messages#optimistically-send-messages).

:::code-group

```tsx [Browser]
// create optimistic group (stays local)
const optimisticGroup = await alixClient.conversations.newGroupOptimistic();

// send optimistic message (stays local)
await optimisticGroup.sendOptimistic("gm");

// later, sync the group by adding members
await optimisticGroup.addMembers([boClient.inboxId]);
// or publishing messages
await optimisticGroup.publishMessages();
```

```ts [Node]
// create optimistic group (stays local)
const optimisticGroup = client.conversations.newGroupOptimistic();

// send optimistic message (stays local)
optimisticGroup.sendOptimistic("gm");

// later, sync the group by adding members
await optimisticGroup.addMembers([boClient.inboxId]);
// or publishing messages
await optimisticGroup.publishMessages();
```

```tsx [React Native]
const optimisticGroup = await boClient.conversations.newGroupOptimistic();

// Prepare a message (stays local)
await optimisticGroup.prepareMessage("Hello group!");

// Later, add members and sync
await optimisticGroup.addMembers([alixClient.inboxId]); // also syncs group to the network
await optimisticGroup.publishMessages(); // Publish prepared messages
```

```kotlin [Kotlin]
// Create optimistic group (stays local)
val optimisticGroup = boClient.conversations.newGroupOptimistic(groupName = "Testing")

// Prepare a message (stays local)
optimisticGroup.prepareMessage("Hello group!")

// Later, add members and sync
optimisticGroup.addMembers(listOf(alixClient.inboxId)) // also syncs group to the network
optimisticGroup.publishMessages() // Publish prepared messages
```

```swift [Swift]
// Create optimistic group (stays local)
let optimisticGroup = try await boClient.conversations.newGroupOptimistic(groupName: "Testing")

// Prepare a message (stays local)
try await optimisticGroup.prepareMessage("Hello group!")

// Later, add members and sync
try await  optimisticGroup.addMembers([alixClient.inboxId]) // also syncs group to the network
try await  optimisticGroup.publishMessages() // Publish prepared messages
```

:::

## Create a new DM

Once you have the verified identity, get its inbox ID and create a new DM:

:::code-group

```js [Browser]
const group = await client.conversations.newDm(bo.inboxId);
```

```js [Node]
const group = await client.conversations.newDm(bo.inboxId);
```

```tsx [React Native]
const dm = await alix.conversations.findOrCreateDm(bo.inboxId);
```

```kotlin [Kotlin]
val dm = alix.conversations.findOrCreateDm(bo.inboxId)

// calls the above function under the hood but returns a type conversation instead of a dm
val conversation = client.conversations.newConversation(inboxId)
```

```swift [Swift]
let dm = try await alix.conversations.findOrCreateDm(with: bo.inboxId)

// calls the above function under the hood but returns a type conversation instead of a dm
let conversation = try await client.conversations.newConversation(inboxId)
```

:::

## Conversation helper methods

Use these helper methods to quickly locate and access specific conversations—whether by conversation ID, topic, group ID, or DM identity—returning the appropriate ConversationContainer, group, or DM object.

:::code-group

```js [Browser]
// get a conversation by its ID
const conversationById = await client.conversations.getConversationById(
  conversationId
);

// get a message by its ID
const messageById = await client.conversations.getMessageById(messageId);

// get a 1:1 conversation by a peer's inbox ID
const dmByInboxId = await client.conversations.getDmByInboxId(peerInboxId);
```

```js [Node]
// get a conversation by its ID
const conversationById = await client.conversations.getConversationById(
  conversationId
);

// get a message by its ID
const messageById = await client.conversations.getMessageById(messageId);

// get a 1:1 conversation by a peer's inbox ID
const dmByInboxId = await client.conversations.getDmByInboxId(peerInboxId);
```

```tsx [React Native]
// Returns a ConversationContainer
await alix.conversations.findConversation(conversation.id);
await alix.conversations.findConversationByTopic(conversation.topic);
// Returns a Group
await alix.conversations.findGroup(group.id);
// Returns a DM
await alix.conversations.findDmByIdentity(bo.identity);
```

```kotlin [Kotlin]
// Returns a ConversationContainer
alix.conversations.findConversation(conversation.id)
alix.conversations.findConversationByTopic(conversation.topic)
// Returns a Group
alix.conversations.findGroup(group.id)
// Returns a DM
alix.conversations.findDmbyInboxId(bo.inboxId);
```

```swift [Swift]
// Returns a ConversationContainer
try alix.conversations.findConversation(conversation.id)
try alix.conversations.findConversationByTopic(conversation.topic)
// Returns a Group
try alix.conversations.findGroup(group.id)
// Returns a DM
try alix.conversations. findDmbyInboxId(bo.inboxId)
```

:::

## Conversation union type

Serves as a unified structure for managing both group chats and DMs. It provides a consistent set of properties and methods to seamlessly handle various conversation types.

- React Native: [Conversation.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Conversation.ts)

## Group class

Represents a group chat conversation, providing methods to manage group-specific functionalities such as sending messages, synchronizing state, and handling group membership.

- React Native: [Group.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Group.ts)

## Dm class

Represents a DM conversation, providing methods to manage one-on-one communications, such as sending messages, synchronizing state, and handling message streams.

- React Native: [Dm.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Dm.ts)


## pages/chat-apps/intro/why-xmtp.mdx
# Why build with XMTP?

Build with XMTP to:

- **Deliver secure and private messaging**

    Using the [Messaging Layer Security](/protocol/security) (MLS) standard, a ratified [IETF](https://www.ietf.org/about/introduction/) standard, XMTP provides end-to-end encrypted messaging with forward secrecy and post-compromise security.

- **Provide spam-free chats**

    In any open and permissionless messaging ecosystem, spam is an inevitable reality, and XMTP is no exception. However, with XMTP [user consent preferences](/chat-apps/user-consent/user-consent), developers can give their users spam-free chats displaying conversations with chosen contacts only.

- **Build on native crypto rails**

    Build with XMTP to tap into the capabilities of crypto and web3. Support decentralized identities, crypto transactions, and more, directly in a messaging experience.

- **Empower users to own and control their communications**

    With apps built with XMTP, users own their conversations, data, and identity. Combined with the interoperability that comes with protocols, this means users can access their end-to-end encrypted communications using any app built with XMTP.

- **Create with confidence**

    Developers are free to create the messaging experiences their users want—on a censorship-resistant protocol architected to last forever. Because XMTP isn't a closed proprietary platform, developers can build confidently, knowing their access and functionality can't be revoked by a central authority.

## Try an app built with XMTP

One of the best ways to understand XMTP is to use an app built with XMTP.

Try [xmtp.chat](https://xmtp.chat/), an app made for devs to learn to build with XMTP—using an app built with XMTP.

## Join the XMTP community

- **XMTP builds in the open**

  - Explore the documentation on this site
  - Explore the open [XMTP GitHub org](https://github.com/xmtp), which contains code for LibXMTP, XMTP SDKs, and xmtpd, node software powering the XMTP testnet.
  - Explore the open source code for [xmtp.chat](https://github.com/xmtp/xmtp-js/tree/main/apps/xmtp.chat), an app made for devs to learn to build with XMTP—using an app built with XMTP.

- **XMTP is for everyone**

  - [Join the conversation](https://community.xmtp.org/) and become part of the movement to redefine digital communications.


## pages/chat-apps/intro/build-with-llms.mdx
# Use XMTP documentation with AI coding assistants

To make it easier to use AI coding agents to build with XMTP, you can find an `llms-full.txt` file at [https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/llms/llms-full.txt](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/llms/llms-full.txt).

This `llms-full.txt` file includes all XMTP documentation in a single plain text file for easy parsing by AI agents.

If you're using an LLM tool that allows custom context, you can upload or point to `llms-full.txt` to enhance your AI coding experience with XMTP.


## pages/chat-apps/intro/faq.mdx
# FAQ about XMTP

Get answers to the most frequently asked questions about XMTP.

## What works with XMTP?

In the spirit of web3 composability, here are **just a few** of the building blocks that work well with XMTP. Building your app with these tools can help you deliver and distribute an app—faster and with quality.

:::tip
This list is not exhaustive and is just a starting point. A highly extensible protocol like XMTP can work with more tools than those listed in each section.
:::

### Wallet connectors

Here are some options for connecting wallets to your app built with XMTP:

- [RainbowKit](https://www.rainbowkit.com/)  
  Support for WalletConnect v2 is now standard in RainbowKit. To learn how to upgrade, see [Migrating to WalletConnect v2](https://www.rainbowkit.com/guides/walletconnect-v2).
- [Thirdweb](https://thirdweb.com/)
- [wagmi](https://wagmi.sh/)

### Message payload storage

Here are some options for storing encrypted message payload content:

- [IPFS](https://ipfs.io/)
- [ThirdwebStorage](https://portal.thirdweb.com/infrastructure/storage/how-storage-works)
- [web3.storage](https://web3.storage/)

### Wallet apps

XMTP can be used with EVM-compatible wallet apps that support ECDSA signing on the secp256k1 elliptic curve. These include common wallet apps such as:

- [Coinbase Wallet](https://www.coinbase.com/wallet)
- [MetaMask](https://metamask.io/)
- [Rainbow Wallet](https://rainbow.me/)
- Most wallets in the [WalletConnect network](https://explorer.walletconnect.com/?type=wallet)

The XMTP SDK **does not** include a wallet app abstraction, as XMTP assumes that developers have a way to obtain a wallet app connection.

### Chains

XMTP can work with signatures from any private public key pair and currently supports EOAs and SCWs on Ethereum and Ethereum side-chains and L2s.

Because all Ethereum Virtual Machine (EVM) chains share the same Ethereum wallet and address format and XMTP messages are stored off-chain, XMTP is interoperable across EVM chains, including testnets. (XMTP itself does not use EVMs.)

For example, whether a user has their wallet app connected to Ethereum or an Ethereum side-chain or L2, their private key can generate and retrieve their XMTP key pair to give them access to XMTP.

XMTP is also chain-agnostic, so multi-chain support is possible.

Here are just a few chains that work with XMTP:

- [Arbitrum](https://arbitrum.foundation/)
- [Avalanche](https://www.avax.network/)
- [Base](https://base.org/)
- [(BNB) Chain](https://www.bnbchain.org/)
- [Ethereum](https://ethereum.org/)
- [zk-EVM](https://linea.build/)
- [Optimism](https://www.optimism.io/)
- [Polygon](https://polygon.technology/)
- [Scroll](https://www.scroll.io/)

## Build with XMTP

### Which languages does the XMTP SDK support?

XMTP SDKs are [available for multiple languages](https://docs.xmtp.org/#start-building).

### Which web3 libraries does the XMTP SDK require?

The XMTP SDK currently requires you to use [ethers](https://ethers.org/) or another web3 library capable of supplying an [ethers Signer](https://docs.ethers.io/v5/api/signer/), such as [wagmi](https://wagmi.sh/).

### What is the invalid key package error?

<iframe width="560" height="315" src="https://www.youtube.com/embed/hNlby-SfPzw?si=V7LqaBxk-i4xhbNC" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

### Where can I get official XMTP brand assets?

See the [XMTP brand guidelines](https://github.com/xmtp/brand) GitHub repo.

## Network

See [Network FAQ](/network/run-a-node/#faq-about-the-xmtp-network).

## Fees

### Does XMTP have fees?

XMTP core developers and researchers are working on a specific fee model for XMTP, with the following guiding principles in mind:

- Fees will be dynamic to protect the network from Denial of Service (DoS) attacks.
- Infrastructure costs for the network must remain low even when decentralized, and comparable to the costs for an equivalent centralized messaging service.
- There must be a low "take rate": the biggest driver of cost must be infrastructure costs, with any remaining cost returned to the network.

Have questions or feedback about the fee model for XMTP? See [XIP-57: Messaging fee collection](https://community.xmtp.org/t/xip-57-messaging-fee-collection/876) in the XMTP Community Forums.

## Security

### Has XMTP undergone a security audit?

A security assessment of [LibXMTP](https://github.com/xmtp/libxmtp) and its use of Messaging Layer Security (MLS) was completed by [NCC Group](https://www.nccgroup.com/) in Dec 2024.

See [Public Report: XMTP MLS Implementation Review](https://www.nccgroup.com/us/research-blog/public-report-xmtp-mls-implementation-review/).

## Storage

### Where are XMTP messages stored?

XMTP stores messages in the XMTP network before and after retrieval. App-specific message storage policies may vary.

### What are the XMTP message retention policies?

#### For XMTP's blockchain and node databases

Currently, encrypted payloads are stored indefinitely.

In the coming year, a retention policy will be added.

This retention policy would represent a minimum retention period, not a maximum.

For example, a retention policy may look something like the following, though specifics are subject to change:

- One year for messages
- Indefinite storage for account information and personal preferences  

The team is researching a way to provide this indefinite storage and have it scale forever.

- If research shows that it's possible, we'll share a plan for how it will be achieved.
- If research shows that it isn't possible, we'll share a plan that shows how retention periods will provide a permanent solution to storage scaling.

Have questions or feedback regarding message storage and retention? Post to the [XMTP Community Forums](https://community.xmtp.org/c/development/ideas/54).

#### For the on-device database managed by the XMTP SDK

Messages are stored for as long as the user decides to keep them. However, encryption keys are regularly rotated.

### What are XMTP message storage and retrieval costs?

Messages are stored off-chain on the XMTP network, with all nodes currently hosted by Ephemera. Ephemera currently absorbs all message storage and retrieval costs.

Today, there are no message storage and retrieval-related fees incurred by developers for building with the XMTP SDK.

## Messages

### Which message formats does XMTP support?

XMTP transports a message payload as a set of bytes that can represent any format that a developer wants to support, such as plain text, JSON, or non-text binary or media content.

With XMTP, these message formats are called content types. Currently, there are two basic content types available. These content types aim to establish broad compatibility among apps built with XMTP.

The XMTP community can propose and adopt standards for other content types, either informally or through a governance process.

To learn more about content types, see [Content types](/chat-apps/content-types/content-types).

To learn more about the XMTP improvement proposals governance process, see [What is an XIP?](https://github.com/xmtp/XIPs/blob/main/XIPs/xip-0-purpose-process.md)

### Does XMTP have a maximum message size?

Yes. Messages sent on the XMTP network are limited to just short of 1MB (1048214 bytes).

For this reason, XMTP supports [remote attachments](/chat-apps/content-types/attachments).

### Does XMTP support message deletion and editing?

Not currently. However, Ephemera is exploring ways to support message deletion and editing.

Have ideas about message deletion and editing? Post to the [XMTP Community Forums](https://community.xmtp.org/c/development/ideas/54).

### Is XMTP more like email or chat?

XMTP enables developers to implement messaging features and UX paradigms that best fit their needs. As a result, messages sent using apps built with XMTP might resemble many typical forms of communication, such as email, direct and group messaging, broadcasts, text messaging, push notifications, and more.

## What is Ephemera?

Ephemera is a web3 software company that contributes to XMTP, an open network, protocol, and standards for secure messaging between blockchain accounts.

Ephemera employees work alongside other XMTP community members to build with and extend XMTP. Community [contributions and participation](https://community.xmtp.org/) are critical to the development and adoption of XMTP.

Ephemera focuses on serving developers. We build [SDKs](https://docs.xmtp.org/#start-building), developer tools, and example apps that help developers build great experiences with XMTP.

Ephemera [acquired Converse](https://paragraph.xyz/@ephemera/converse) in June 2024. Converse is now [Convos](https://github.com/ephemeraHQ/convos-app), open-sourced for the entire XMTP network.


## pages/chat-apps/intro/get-started.mdx
# Get started building with XMTP

XMTP (Extensible Message Transport Protocol) is the largest and most secure decentralized messaging network. XMTP is open and permissionless, empowering any developer to build end-to-end encrypted 1:1, group, and agent messaging experiences, and more.

To learn more, see [Why build with XMTP?](/chat-apps/intro/why-xmtp).

## 🛠️ Phase 0: Explore XMTP developer tools

- Pick your SDK:

  <style>
   {`
      /* Inline styles instead of styles.css bc vocs
      search bug doesn't allow imports */
      .sdk-buttons {
         display: flex;
         gap: 20px;
         flex-wrap: wrap;
         margin: 20px 0;
      }

      .sdk-button {
         padding: 8px 16px;
         background-color: #4F46E5;
         border-radius: 5px;
         text-decoration: none;
         color: #ffffff;
         font-weight: 400;
         transition: all 0.2s;
      }

      .sdk-button:hover {
         background-color: #4338CA;
      }
   `}
  </style>

  <div className="sdk-buttons">
    <a href="/chat-apps/sdks/browser"
  className="sdk-button">Browser</a>
    <a href="/chat-apps/sdks/node"
  className="sdk-button">Node</a>
    <a href="/chat-apps/sdks/react-native"
  className="sdk-button">React Native</a>
    <a href="/chat-apps/sdks/android"
  className="sdk-button">Android</a>
    <a href="/chat-apps/sdks/ios"
  className="sdk-button">iOS</a>
  </div>

- [Use llms-full.txt](/chat-apps/intro/build-with-llms) to provide the full text of the XMTP developer documentation to an AI coding assistant.

- [Use xmtp.chat](https://xmtp.chat), the official web chat app for developers, to interact with and test your app

- [Run a local XMTP node](https://github.com/xmtp/xmtp-local-node/tree/main) for development and testing.

## 💬 Phase I: Build core messaging

1. [Create an EOA or SCW signer](/chat-apps/core-messaging/create-a-signer).

2. [Create an XMTP client](/chat-apps/core-messaging/create-a-client). Be sure to set the `appVersion` client option.

3. [Check if an identity is reachable on XMTP](/chat-apps/core-messaging/create-conversations#check-if-an-identity-is-reachable).

4. Create a [group chat](/chat-apps/core-messaging/create-conversations) or [direct message](/chat-apps/core-messaging/create-conversations) (DM) conversation.

   With XMTP, "conversation" refers to both group chat and DM conversations.

5. [Send messages](/chat-apps/core-messaging/send-messages) in a conversation.

6. Manage group chat [permissions](/chat-apps/core-messaging/group-permissions) and [metadata](/chat-apps/core-messaging/group-metadata).

7. [Manage identities, inboxes, and installations](/chat-apps/core-messaging/manage-inboxes).

8. Be sure to [observe rate limits](/chat-apps/core-messaging/rate-limits).

## 📩 Phase II: Manage conversations and messages

1. [List existing conversations](/chat-apps/list-stream-sync/list) from local storage.

2. [Stream new conversations](/chat-apps/list-stream-sync/stream) from the network.

3. [Stream new messages](/chat-apps/list-stream-sync/stream) from the network.

4. [Sync new conversations](/chat-apps/list-stream-sync/sync-and-syncall) from the network.

5. [Sync a specific conversation's messages and preference updates](/chat-apps/list-stream-sync/sync-and-syncall) from the network.

## 💅🏽 Phase III: Enhance the user experience

1. [Implement user consent](/chat-apps/user-consent/support-user-consent), which provides a consent value of either **unknown**, **allowed** or **denied** to each of a user's contacts. You can use these consent values to filter conversations. For example:

   - Conversations with **allowed** contacts go to a user's main inbox
   - Conversations with **unknown** contacts go to a possible spam tab
   - Conversations with **denied** contacts are hidden from view.
  
2. Support rich [content types](/chat-apps/content-types/content-types).

   - [Attachments](/chat-apps/content-types/attachments)
     - Single remote attachment
     - Multiple remote attachments
     - Attachments smaller than 1MB
   - [Reactions](/chat-apps/content-types/reactions)
   - [Replies](/chat-apps/content-types/replies)
   - [Read receipts](/chat-apps/content-types/read-receipts)
   - [Onchain transactions](/chat-apps/content-types/transactions)
   - [Onchain transaction references](/chat-apps/content-types/transaction-refs)

3. [Implement push notifications](/chat-apps/push-notifs/understand-push-notifs), if applicable.

## 🧪 Phase IV: Test and debug

- [Stress and burn-in test](/chat-apps/debug-your-app#xmtp-debug) your chat app.

- [Enable file logging](/chat-apps/debug-your-app#file-logging).

- [Capture network statistics](/chat-apps/debug-your-app#network-statistics).

- Found a bug or need help? Contact [dev support](/chat-apps/intro/dev-support).


## pages/chat-apps/intro/dev-support.mdx
# Get dev support for building with XMTP

Building with XMTP and need help or think you've found a bug?

Please open an issue in the relevant repo:

- [Browser SDK](https://github.com/xmtp/xmtp-js/issues)
- [Node SDK](https://github.com/xmtp/xmtp-js/issues)
- [React Native SDK](https://github.com/xmtp/xmtp-react-native/issues)
- [Android SDK](https://github.com/xmtp/xmtp-android/issues)
- [iOS SDK](https://github.com/xmtp/xmtp-ios/issues)

For all other topics, post to the [XMTP Community Forums](https://community.xmtp.org/).


## pages/chat-apps/content-types/reactions.mdx
---
description: Learn how to use the reaction content type to support reactions in your app built with XMTP
---

# Support reactions in your app built with XMTP

Use the reaction content type to support reactions in your app. A reaction is a quick and often emoji-based way to respond to a message. Reactions are usually limited to a predefined set of emojis or symbols provided by the chat app.

## Use a local database for performance

Use a local database to store reactions. This enables your app to performantly display a reaction with its [referenced message](#send-a-reaction) when rendering message lists.

### Install the package

In some SDKs, the `ReactionCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-reaction
```

```bash [yarn]
yarn add @xmtp/content-type-reaction
```

```bash [pnpm]
pnpm add @xmtp/content-type-reaction
```

:::

## Configure the content type

After importing the package, you can register the codec.

:::code-group

```jsx [Browser]
import {
  ReactionCodec,
} from "@xmtp/content-type-reaction";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new ReactionCodec()],
});
```

```jsx [React Native]
const client = await Client.create(signer, {
  env: "production",
  codecs: [new ReactionCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.ReactionCodec

Client.register(codec = ReactionCodec())
```

```swift [Swift]
Client.register(ReactionCodec());
```

:::

## Send a reaction

With XMTP, reactions are represented as objects with the following keys:

- `reference`: ID of the message being reacted to

- `action`: Action of the reaction (added or removed)

- `content`: String representation of the reaction (smile, for example) to be interpreted by clients

- `schema`: Schema of the reaction (Unicode, shortcode, or custom)

:::code-group

```tsx [Browser]
const reaction = {
  reference: someMessageID,
  action: "added",
  content: "smile",
};

await conversation.send(reaction, {
  contentType: ContentTypeReaction,
});
```

```jsx [React Native]
// Assuming you have a conversation object and the ID of the message you're reacting to
const reactionContent = {
  reaction: {
    reference: messageId, // ID of the message you're reacting to
    action: "added", // Action can be 'added' or 'removed'
    schema: "unicode", // Schema can be 'unicode', 'shortcode', or 'custom'
    content: "👍", // Content of the reaction
  },
};

await conversation.send(reactionContent);
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.Reaction
import org.xmtp.android.library.codecs.ReactionAction
import org.xmtp.android.library.codecs.ReactionSchema
import org.xmtp.android.library.codecs.ContentTypeReaction
import org.xmtp.android.library.SendOptions

val reaction = Reaction(
    reference = messageToReact.id, // the ID of the message you're reacting to
    action = ReactionAction.Added, // the action of the reaction
    content = "U+1F603", // the content of the reaction
    schema = ReactionSchema.Unicode // the schema of the reaction
)
conversation.send(
    content = reaction,
    options = SendOptions(contentType = ContentTypeReaction)
)

```

```swift [Swift]
let reaction = Reaction(
    reference: messageToReact.id,
    action: .added,
    content: "U+1F603",
    schema: .unicode
)

try await conversation.send(
    content: reaction,
    options: .init(contentType: ContentTypeReaction)
)
```

:::

## Receive a reaction

Now that you can send a reaction, you need a way to receive a reaction. For example:

:::code-group

```tsx [Browser]
if (message.contentType.sameAs(ContentTypeReaction)) {
  // We've got a reaction.
  const reaction: Reaction = message.content;
}
```

```jsx [React Native]
if (message.contentTypeId === "xmtp.org/reaction:1.0") {
  const reaction = message.content();
  return reaction;
  //reaction.reference = id of the message being reacted to,
  //reaction.action = 'added',
  //reaction.schema =  'unicode',
  //reaction.content = '💖',
}
```

```kotlin [Kotlin]
if (message.contentType == ContentTypeReaction) {
    // The message is a reaction
    val reactionCodec = ReactionCodec()
    val reaction: Reaction = reactionCodec.decode(message.content)
}
```

```swift [Swift]
let content: Reaction = try message.content()
```

To handle unsupported content types, refer to the [fallback](/chat-apps/content-types/fallback) section.

## Display the reaction

Generally, reactions should be interpreted as emoji. So, "smile" would translate to 😄 in UI clients. That being said, how you ultimately choose to render a reaction in your app is up to you.

## Notifications and reactions

Reactions have `shouldPush` set to `false`, which means that reactions do not trigger push notifications as long as the notification server respects this flag.


## pages/chat-apps/content-types/transactions.mdx
# Support onchain transactions in your app built with XMTP

This package provides an XMTP content type to support sending transactions to a wallet for execution.

Currently, this content type is supported in the Browser, Node, and React Native SDKs only.

For an example of an agent that implements the transaction content type, see [xmtp-transactions](https://github.com/ephemeraHQ/xmtp-agent-examples/tree/main/examples/xmtp-transactions).

:::tip[Open for feedback]

You are welcome to provide feedback on this implementation by commenting on [XIP-59: Trigger on-chain calls via wallet_sendCalls](https://community.xmtp.org/t/xip-59-trigger-on-chain-calls-via-wallet-sendcalls/889).

:::

## Install the package

:::code-group

```bash [npm]
npm i @xmtp/content-type-wallet-send-calls
```

```bash [yarn]
yarn add @xmtp/content-type-wallet-send-calls
```

```bash [pnpm]
pnpm i @xmtp/content-type-wallet-send-calls
```

:::

## Configure the content type

After importing the package, you can register the codec.

```js [Browser]
import {
  WalletSendCallsCodec,
} from "@xmtp/content-type-wallet-send-calls";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new WalletSendCallsCodec()],
});
```

## Create a transaction request

With XMTP, a transaction request is represented using `wallet_sendCalls` with additional metadata for display.

```ts [TypeScript]
const walletSendCalls: WalletSendCallsParams = {
  version: "1.0",
  from: "0x123...abc",
  chainId: "0x2105",
  calls: [
    {
      to: "0x456...def",
      value: "0x5AF3107A4000",
      metadata: {
        description: "Send 0.0001 ETH on base to 0x456...def",
        transactionType: "transfer",
        currency: "ETH",
        amount: 100000000000000,
        decimals: 18,
        toAddress: "0x456...def",
      },
    },
    {
      to: "0x789...cba",
      data: "0xdead...beef",
      metadata: {
        description: "Lend 10 USDC on base with Morpho @ 8.5% APY",
        transactionType: "lend",
        currency: "USDC",
        amount: 10000000,
        decimals: 6,
        platform: "morpho",
        apy: "8.5",
      },
    },
  ],
};
```

## Send a transaction request

Once you have a transaction reference, you can send it as part of your conversation:

```ts [TypeScript]
await conversation.messages.send(walletSendCalls, {
  contentType: ContentTypeWalletSendCalls,
});
```

## Receive a transaction request

To receive and process a transaction request:

```ts [TypeScript]
// Assume `loadLastMessage` is a thing you have
const message: DecodedMessage = await loadLastMessage();

if (!message.contentType.sameAs(ContentTypeWalletSendCalls)) {
  // Handle non-transaction request message
  return;
}

const walletSendCalls: WalletSendCallsParams = message.content;
// Process the transaction request here
```


## pages/chat-apps/content-types/custom.mdx
---
description: Learn how to build custom content types
---
# Build custom content types

Any developer building with XMTP can create a custom content type and immediately start using it in their app. Unlike a standard content type, use of a custom content type doesn't require prerequisite formal adoption through the XRC and XIP processes.

Building a custom content type enables you to manage data in a way that's more personalized or specialized to the needs of your app.

For example, if you need a content type that isn't covered by a [standard](/chat-apps/content-types/content-types#standard-content-types) or [standards-track](/chat-apps/content-types/content-types#standards-track-content-types) content type, you can create a custom content type and begin using it immediately in your app.

:::warning[warning]

Be aware that your custom content type may not be automatically recognized or supported by other apps, which could result in the other apps overlooking or only displaying the fallback text for your custom content type.

:::

Fallback plain text is "alt text"-like description text that you can associate with a custom content type if you are concerned that a receiving app might not be able to handle the content. If the receiving app is unable to handle the custom content, it displays the fallback plain text instead.

If another app wants to display your custom content type, they must implement your custom content type in their code exactly as it's defined in your code.

For more common content types, you can usually find a [standard](/chat-apps/content-types/content-types#standard-content-types) or [standards-track](/chat-apps/content-types/content-types#standards-track-content-types) content type to serve your needs.

If your custom content type generates interest within the developer community, consider proposing it as a standard content type through the [XIP process](/protocol/xips).


## pages/chat-apps/content-types/read-receipts.mdx
---
description: Learn how to use the read receipt content type to support read receipts in your app built with XMTP
---

# Support read receipts in your app built with XMTP

Use the read receipt content type to support read receipts in your app. A read receipt is a `timestamp` that indicates when a message was read. It is sent as a message and can be used to calculate the time since the last message was read.

## Provide an opt-out option

While this is a per-app decision, the best practice is to provide users with the option to opt out of sending read receipts. If a user opts out, when they read a message, a read receipt will not be sent to the sender of the message.

## Install the package

:::code-group

```bash [npm]
npm i @xmtp/content-type-read-receipt
```

```bash [yarn]
yarn add @xmtp/content-type-read-receipt
```

```bash [pnpm]
pnpm add @xmtp/content-type-read-receipt
```

:::

## Configure the content type

:::code-group

```js [Browser]
import {
  ReadReceiptCodec,
} from "@xmtp/content-type-read-receipt";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new ReadReceiptCodec()],
});
```

```js [React Native]
const client = await Client.create(signer, {
  env: "production",
  codecs: [new ReadReceiptCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.Client
import org.xmtp.android.library.codecs.ReadReceiptCodec

Client.register(codec = ReadReceiptCodec())
```

```swift [Swift]
 Client.register(codec: ReadReceiptCodec())
```

:::

## Send a read receipt

:::code-group

```js [Browser]
// The content of a read receipt message must be an empty object.

await conversation.messages.send({}, ContentTypeReadReceipt);
```

```jsx [React Native]
await bobConversation.send({ readReceipt: {} });
```

```kotlin [Kotlin]
import org.xmtp.android.library.Client
import org.xmtp.android.library.codecs.ReadReceipt
import org.xmtp.android.library.codecs.ContentTypeReadReceipt
import org.xmtp.android.library.messages.SendOptions

// Create a ReadReceipt instance
val readReceipt = ReadReceipt

// Send the read receipt
aliceConversation.send(
    content = readReceipt,
    options = SendOptions(contentType = ContentTypeReadReceipt),
)
```

```swift [Swift]
let read = ReadReceipt(timestamp: "2019-09-26T07:58:30.996+0200")

try await conversation.send(
    content: read,
    options: .init(contentType: ContentTypeReadReceipt)
)
```

:::

## Receive a read receipt

Here's how you can receive a read receipt:

:::code-group

```js [Browser]
if (message.contentType.sameAs(ContentTypeReadReceipt)) {
  // The message is a read receipt
  const timestamp = message.sent;
}
```

```js [React Native]
if (message.contentTypeId === "xmtp.org/readReceipt:1.0") {
  return message.sent; //Date received
}
```

```kotlin [Kotlin]
val message: DecodedMessage = conversation.messages().first()
if (message.encodedContent.type == ContentTypeReadReceipt) {
    // The message is a ReadReceipt
    val readReceipt: ReadReceipt? = message.content()
    if (readReceipt != null) {
      println("Message read at: ${message.sent}")
    }
}
```

```swift [Swift]
let content: ReadReceipt = try message.content()
content.timestamp // "2019-09-26T07:58:30.996+0200"
```

:::

## Display a read receipt

`ReadReceipts` have an `undefined` or `nil` fallback, indicating the message is not expected to be displayed. To learn more, see [Handle unsupported content types](/chat-apps/content-types/fallback) section.

## Notifications and read receipts

Read receipts have `shouldPush` set to `false`, which means that read receipts do not trigger push notifications as long as the notification server respects this flag.

## Use a read receipt

Generally, a read receipt indicator should be displayed under the message it's associated with. The indicator can include a timestamp. Ultimately, how you choose to display a read receipt indicator is completely up to you.

The read receipt is provided as an **empty message** whose timestamp provides the data needed for the indicators. **Be sure to filter out read receipt empty messages and not display them to users.**

You can use a read receipt timestamp to calculate the time since the last message was read. While iterating through messages, you can be sure that the last message was read at the timestamp of the read receipt if the string of the timestamp is lower.


## pages/chat-apps/content-types/transaction-refs.mdx
---
description: Learn how to implement an onchain transaction reference content type
---
# Support onchain transaction references in your app built with XMTP

This package provides an XMTP content type to support onchain transaction references. It is a reference to an onchain transaction sent as a message. This content type facilitates sharing transaction hashes or IDs, thereby providing a direct link to onchain activities. Transaction references serve to display transaction details, facilitating the sharing of onchain activities, such as token transfers, between users.

:::tip[Open for feedback]

You're welcome to provide feedback by commenting on [XIP-21: Onchain transaction reference content type](https://community.xmtp.org/t/xip-21-on-chain-transaction-reference-content-type/532).

:::

## Install the package

:::code-group

```bash [npm]
npm i @xmtp/content-type-transaction-reference
```

```bash [yarn]
yarn add @xmtp/content-type-transaction-reference
```

```bash [pnpm]
pnpm add @xmtp/content-type-transaction-reference
```

:::

## Configure the content type

After importing the package, you can register the codec.

:::code-group

```js [Browser]
import {
  ContentTypeTransactionReference,
  TransactionReferenceCodec,
} from "@xmtp/content-type-transaction-reference";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new TransactionReferenceCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.Client
import org.xmtp.android.library.Signer
import org.xmtp.android.library.codecs.ContentTypeTransactionReference
import org.xmtp.android.library.codecs.TransactionReferenceCodec

Client.register(codec = TransactionReferenceCodec())

// Create the XMTP client (assume account is a Signer)
val xmtp = Client.create(account)
```

```swift [Swift]
import XMTP
import XMTPContentTypeTransactionReference

let codec = TransactionReferenceCodec()
Client.register(codec: codec)

// Create the XMTP client (assume account is a signer)
let xmtp = try await Client.create(account: account)
```

:::

## Send a transaction reference

With XMTP, a transaction reference is represented as an object with the following keys:

:::code-group

```ts [Browser]
const transactionReference: TransactionReference = {
  /**
   * Optional namespace for the networkId
   */
  namespace: "eip155",
  /**
   * The networkId for the transaction, in decimal or hexadecimal format
   */
  networkId: 1;
  /**
   * The transaction hash
   */
  reference: "0x123...abc";
  /**
   * Optional metadata object
   */
  metadata: {
    transactionType: "transfer",
    currency: "USDC",
    amount: 100000, // In integer format, this represents 1 USDC (100000/10^6)
    decimals: 6, // Specifies that the currency uses 6 decimal places
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  };
};
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.TransactionReference

val transactionReference = TransactionReference(
  namespace = "eip155",
  networkId = "1",
  reference = "0x123...abc",
  metadata = TransactionReference.Metadata(
    transactionType = "transfer",
    currency = "USDC",
    amount = 100000.0,
    decimals = 6u,
    fromAddress = "0x456...def",
    toAddress = "0x789...ghi"
  )
)
```

```swift [Swift]
import XMTPContentTypeTransactionReference

let transactionReference = TransactionReference(
  namespace: "eip155",
  networkId: "1",
  reference: "0x123...abc",
  metadata: TransactionReference.Metadata(
    transactionType: "transfer",
    currency: "USDC",
    amount: 100_000,
    decimals: 6,
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  )
)
```

:::

Once you have a transaction reference, you can send it as part of your conversation:

:::code-group

```js [Browser]
await conversation.messages.send(transactionReference, {
  contentType: ContentTypeTransactionReference,
});
```

```kotlin [Kotlin]
import kotlinx.coroutines.runBlocking
import org.xmtp.android.library.SendOptions
import org.xmtp.android.library.codecs.ContentTypeTransactionReference

runBlocking {
  conversation.send(
    content = transactionReference,
    options = SendOptions(contentType = ContentTypeTransactionReference)
  )
}
```

```swift [Swift]
try await conversation.send(
  transactionReference,
  options: SendOptions(contentType: ContentTypeTransactionReference)
)
```

:::

## Receive a transaction reference

To receive and process a transaction reference, you can use the following code samples.

To handle unsupported content types, refer to the [fallback](/chat-apps/content-types/fallback) section.

:::code-group

```ts [Browser]
// Assume `loadLastMessage` is a thing you have
const message: DecodedMessage = await loadLastMessage();

if (!message.contentType.sameAs(ContentTypeTransactionReference)) {
  // Handle non-transaction reference message
  return;
}

const transactionRef: TransactionReference = message.content;
// Process the transaction reference here
```

```kotlin [Kotlin]
// Assume message is a DecodedMessage
if (message.type == ContentTypeTransactionReference) {
  val transactionRef: TransactionReference? = message.content()
  // Process the transaction reference here
}
```

```swift [Swift]
if message.contentType == ContentTypeTransactionReference {
  if let transactionRef = message.content as? TransactionReference {
    // Process the transaction reference here
  }
}
```

:::

## Display the transaction reference

Displaying a transaction reference typically involves rendering details such as the transaction hash, network ID, and any relevant metadata. Because the exact UI representation can vary based on your app's design, you might want to fetch onchain data before showing it to the user.


## pages/chat-apps/content-types/attachments.mdx
---
description: Learn how to use the remote attachment, multiple remote attachment, or attachment content types to support attachments in your app built with XMTP
---
# Support attachments in your app built with XMTP

Use the remote attachment, multiple remote attachments, or attachment content type to support attachments in your app.

- Use the [remote attachment content type](#support-remote-attachments-of-any-size) to send one remote attachment of any size.

- Use the [multiple remote attachments content type](#support-multiple-remote-attachments-of-any-size) to send multiple remote attachments of any size.

- Use the [attachment content type](#support-attachments-smaller-than-1mb) to send attachments smaller than 1MB.

## Support remote attachments of any size

One remote attachment of any size can be sent in a message using the `RemoteAttachmentCodec` and a storage provider.

To send multiple remote attachments of any size in a single message, see [Support multiple remote attachments of any size](#support-multiple-remote-attachments-of-any-size).

### Install the package

In some SDKs, the `AttachmentCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-remote-attachment
```

```bash [yarn]
yarn add @xmtp/content-type-remote-attachment
```

```bash [pnpm]
pnpm add @xmtp/content-type-remote-attachment
```

:::

### Configure the content type

After importing the package, you can register the codec.

:::code-group

```jsx [Browser]
import {
  AttachmentCodec,
  RemoteAttachmentCodec,
} from "@xmtp/content-type-remote-attachment";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],
});
```

```jsx [React Native]
const client = await Client.create(signer, {
  env: "production",
  codecs: [new RemoteAttachmentCodec(), new StaticAttachmentCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.Attachment
import org.xmtp.android.library.codecs.AttachmentCodec
import org.xmtp.android.library.codecs.ContentTypeAttachment

Client.register(codec = AttachmentCodec())
Client.register(codec = RemoteAttachmentCodec())
```

```swift [Swift]
Client.register(AttachmentCodec());
Client.register(RemoteAttachmentCodec());
```

:::

### Send a remote attachment

:::code-group

<div data-title="Browser">
Load the file. This example uses a web browser to load the file:

```jsx
//image is the uploaded event.target.files[0];
const data = await new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    if (reader.result instanceof ArrayBuffer) {
      resolve(reader.result);
    } else {
      reject(new Error("Not an ArrayBuffer"));
    }
  };
  reader.readAsArrayBuffer(image);
});
```

Create an attachment object:

```tsx
// Local file details
const attachment = {
  filename: image?.name,
  mimeType: image?.type,
  data: new Uint8Array(data),
};
```

Use `RemoteAttachmentCodec.encodeEncrypted` to encrypt an attachment:

```tsx
const encryptedEncoded = await RemoteAttachmentCodec.encodeEncrypted(
  attachment,
  new AttachmentCodec()
);
```

Upload an encrypted attachment to a location where it will be accessible via an HTTPS GET request. This location will depend on which storage provider you use based on your needs.

<p>Now that you have a `url`, you can create a `RemoteAttachment`:</p>

```jsx
const remoteAttachment = {
  url: url,
  contentDigest: encryptedEncoded.digest,
  salt: encryptedEncoded.salt,
  nonce: encryptedEncoded.nonce,
  secret: encryptedEncoded.secret,
  scheme: "https://",
  filename: attachment.filename,
  contentLength: attachment.data.byteLength,
};
```

Now that you have a remote attachment, you can send it:

```tsx
await conversation.send(remoteAttachment, {
  contentType: ContentTypeRemoteAttachment,
});
```

</div>

<div data-title="React Native">

This method takes a `DecryptedLocalAttachment` object as an argument:

```jsx
const { encryptedLocalFileUri, metadata } = await alice.encryptAttachment({
  fileUri: `file://${file}`,
  mimeType: "text/plain",
});
```

Upload an encrypted file to a remote server:

```jsx
let url = await uploadFile(encryptedLocalFileUri);
```

Send a remote attachment message:

```jsx
await convo.send({
  remoteAttachment: {
    ...metadata,
    scheme: "https://",
    url,
  },
});
```

</div>

<div data-title="Kotlin">

Create an attachment object:

```kotlin [Kotlin]
val attachment = Attachment(
filename = "test.txt",
mimeType = "text/plain",
data = "hello world".toByteStringUtf8(),
)
```

Encode and encrypt an attachment for transport:

```kotlin [Kotlin]
val encodedEncryptedContent = RemoteAttachment.encodeEncrypted(
content = attachment,
codec = AttachmentCodec(),
)
```

Create a remote attachment from an attachment:

```kotlin [Kotlin]
val remoteAttachment = RemoteAttachment.from(
    encryptedEncodedContent = encodedEncryptedContent
)
remoteAttachment.contentLength = attachment.data.size()
remoteAttachment.filename = attachment.filename
```

Send a remote attachment and set the `contentType`:

```kotlin [Kotlin]
val newConversation = client.conversations.newConversation(inboxId)

newConversation.send(
content = remoteAttachment,
options = SendOptions(contentType = ContentTypeRemoteAttachment),
)
```

</div>

<div data-title="Swift">

Create an attachment object:

```swift [Swift]
let attachment = Attachment(
  filename: "screenshot.png",
  mimeType: "image/png",
  data: Data(somePNGData)
)
```

Encode and encrypt an attachment for transport:

```swift [Swift]
// Encode an attachment and encrypt the encoded content
const encryptedAttachment = try RemoteAttachment.encodeEncrypted(
 content: attachment,
 codec: AttachmentCodec()
)
```

Upload an encrypted attachment anywhere where it will be accessible via an HTTPS GET request. For example, you can use web3.storage:

```swift [Swift]
func upload(data: Data, token: String): String {
  let url = URL(string: "https://api.web3.storage/upload")!
  var request = URLRequest(url: url)
  request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
  request.addValue("XMTP", forHTTPHeaderField: "X-NAME")
  request.httpMethod = "POST"

  let responseData = try await URLSession.shared.upload(for: request, from: data).0
  let response = try JSONDecoder().decode(Web3Storage.Response.self, from: responseData)

  return "https://\(response.cid).ipfs.w3s.link"
}

let url = upload(data: encryptedAttachment.payload, token: YOUR_WEB3_STORAGE_TOKEN)
```

Create a remote attachment from an attachment:

```swift [Swift]
let remoteAttachment = try RemoteAttachment(
  url: url,
  encryptedEncodedContent: encryptedEncodedContent
)
```

Send a remote attachment and set the `contentType`:

```swift [Swift]
try await conversation.send(
 content: remoteAttachment,
 options: .init(
  contentType: ContentTypeRemoteAttachment,
  fallback: "a description of the image"
 )
)
```

</div>

:::

### Receive, decode, and decrypt a remote attachment

Now that you can send a remote attachment, you need a way to receive it. For example:

:::code-group

<div data-title="Browser">

```tsx
import { ContentTypeRemoteAttachment } from "@xmtp/content-type-remote-attachment";

if (message.contentType.sameAs(RemoteAttachmentContentType)) {
  const attachment = await RemoteAttachmentCodec.load(message.content, client);
}
```

You now have the original attachment:

```bash [Bash]
attachment.filename // => "screenshot.png"
attachment.mimeType // => "image/png",
attachment.data // => [the PNG data]
```

Once you've created the attachment object, you can create a preview to show in the message input field before sending:

```tsx
const objectURL = URL.createObjectURL(
  new Blob([Buffer.from(attachment.data)], {
    type: attachment.mimeType,
  })
);

const img = document.createElement("img");
img.src = objectURL;
img.title = attachment.filename;
```

</div>

<div data-title="React Native">

On the receiving end, you can use the `decryptAttachment` method to decrypt the downloaded file. This method takes an `EncryptedLocalAttachment` object as an argument and returns a `DecryptedLocalAttachment` object.

```jsx
if (message.contentTypeId === "xmtp.org/remoteStaticAttachment:1.0") {
  // Now we can decrypt the downloaded file using the message metadata.
  const attached = await xmtp_client.decryptAttachment({
    encryptedLocalFileUri: downloadedFileUri,
    metadata: message.content() as RemoteAttachmentContent,
  })

  //attached.filename
  //attached.mimeType
  //attached.fileUri
}
```

Display the attachment:

```jsx
<Image source={{ uri: attached.fileUri }} />
```

</div>

```kotlin [Kotlin]
val message = newConversation.messages().first()
val loadedRemoteAttachment: RemoteAttachment = messages.content()
loadedRemoteAttachment.fetcher = Fetcher()
runBlocking {
  val attachment: Attachment = loadedRemoteAttachment.load()
}
```

<div data-title="Swift">

```swift [Swift]
let attachment: Attachment = try await remoteAttachment.content()
```

You now have the original attachment:

```swift [Swift]
attachment.filename // => "screenshot.png"
attachment.mimeType // => "image/png",
attachment.data // => [the PNG data]
```

Once you've created the attachment object, you can create a preview to show in the message input field before sending:

```swift [Swift]
import UIKIt
import SwiftUI

struct ContentView: View {
 var body: some View {
  Image(uiImage: UIImage(data: attachment.data))
 }
}
```

</div>

:::

To handle unsupported content types, refer to the [fallback]() section.

## Support multiple remote attachments of any size

Multiple remote attachments of any size can be sent in a single message using the `MultiRemoteAttachmentCodec` and a storage provider.

### Register necessary codecs

:::code-group

```tsx [React Native]
export const registerCodecs = () => {
  Client.register(new AttachmentCodec());
  Client.register(new RemoteAttachmentCodec());
  Client.register(new MultiRemoteAttachmentCodec());
};
```

```kotlin [Kotlin]
Client.register(codec = AttachmentCodec())
Client.register(codec = RemoteAttachmentCodec())
Client.register(codec = MultiRemoteAttachmentCodec())
```

```swift [Swift]
Client.register(codec: AttachmentCodec())
Client.register(codec: RemoteAttachmentCodec()) 
Client.register(codec: MultiRemoteAttachmentCodec())
```

:::

### Create multiple attachment objects

Each attachment in the attachments array contains a URL that points to an encrypted `EncodedContent` object. The content must be accessible by an HTTP `GET` request to the URL.

:::code-group

```ts [React Native]
const attachment1: DecryptedLocalAttachment = {
  fileUri: "content://media/external/images/media/image-1.png",
  mimeType: "image/png",
  filename: "image-1.png"
}

const attachment2: DecryptedLocalAttachment = {
  fileUri: "content://media/external/images/media/image-2.png",
  mimeType: "image/png",
  filename: "image-2.png"
}
```

```kotlin [Kotlin]
val attachment1 = Attachment(
    filename = "test1.txt",
    mimeType = "text/plain",
    data = "hello world".toByteStringUtf8(),
)

val attachment2 = Attachment(
    filename = "test2.txt",
    mimeType = "text/plain",
    data = "hello world".toByteStringUtf8(),
)
```

```swift [Swift]
let attachment1 = Attachment(
    filename: "test1.txt",
    mimeType: "text/plain", 
    data: Data("hello world".utf8)
)

let attachment2 = Attachment(
    filename: "test2.txt",
    mimeType: "text/plain",
    data: Data("hello world".utf8)
)
```

:::

### Encrypt and upload multiple attachments to a remote server

:::code-group

```ts [React Native]
const remoteAttachments: RemoteAttachmentInfo[] = []
  for (const attachment of [attachment1, attachment2]) {
    // Encrypt the attachment and receive the local URI of the encrypted file
    const { encryptedLocalFileUri, metadata } = await alix.encryptAttachment(attachment)

    // Upload the attachment to a remote server and receive the URL
    // (Integrator must supply upload from local uri and return url functionality!)
    const url = uploadAttachmentForUrl(encryptedLocalFileUri)

    // Build the remote attachment info
    const remoteAttachmentInfo =
      MultiRemoteAttachmentCodec.buildMultiRemoteAttachmentInfo(url, metadata)
    remoteAttachments.push(remoteAttachmentInfo)
  }
```

```kotlin [Kotlin]
val attachmentCodec = AttachmentCodec()
val remoteAttachmentInfos: MutableList<RemoteAttachmentInfo> = ArrayList()

for (attachment: Attachment in listOf(attachment1, attachment2)) {
    // 1) Encode the attachment to raw bytes
    val encodedBytes = attachmentCodec.encode(attachment).toByteArray()
    // 2) Encrypt the bytes locally
    val encryptedAttachment = MultiRemoteAttachmentCodec.encryptBytesForLocalAttachment(encodedBytes, attachment.filename)
    // 3) "Upload" it, and get a url string back
    // (Integrator must supply upload from local uri and return url functionality!)
    val url = uploadEncryptedPayload(encryptedAttachment.payload.toByteArray())
    // 4) Build a RemoteAttachmentInfo for that URL and encryptedAttachment
    val remoteAttachmentInfo = MultiRemoteAttachmentCodec.buildRemoteAttachmentInfo(encryptedAttachment, URL(url))
    remoteAttachmentInfos.add(remoteAttachmentInfo)
}
```

```swift [Swift]
var remoteAttachmentInfos: [MultiRemoteAttachment.RemoteAttachmentInfo] = []

for att in [attachment1, attachment2] {
    // 1) Encode the attachment to raw bytes
    let encodedBytes = try AttachmentCodec().encode(content: att).serializedData()
    // 2) Encrypt the bytes locally
    let encrypted = try MultiRemoteAttachmentCodec.encryptBytesForLocalAttachment(encodedBytes, filename: att.filename)
    // 3) "Upload" it, and get a url string back
    // (Integrator must supply upload from local uri and return url functionality!)
    let urlString = fakeUpload(encrypted.payload)
    // 4) Build a RemoteAttachmentInfo for that URL and encryptedAttachment
    let info = try MultiRemoteAttachmentCodec.buildRemoteAttachmentInfo(
        encryptedAttachment: encrypted,
        remoteUrl: URL(string: urlString)!
    )
    remoteAttachmentInfos.append(info)
}
```

:::

### Send a message with multiple remote attachments

:::code-group

```ts [React Native]
await convo.send({
    multiRemoteAttachment: {
      attachments: remoteAttachments,
    },
  })
```

```kotlin [Kotlin]
val multiRemoteAttachment = MultiRemoteAttachment(remoteAttachments = remoteAttachmentInfos.toList())

runBlocking {
    aliceConversation.send(
        content = multiRemoteAttachment,
        options = SendOptions(contentType = ContentTypeMultiRemoteAttachment),
    )
}
```

```swift [Swift]
let multiRemoteAttachment = MultiRemoteAttachment(remoteAttachments: remoteAttachmentInfos)
let encodedContent = try MultiRemoteAttachmentCodec().encode(content: multiRemoteAttachment)
try await alixConversation.send(encodedContent: encodedContent)
```

:::

### Recognize and decode a multi remote attachment

:::code-group

```ts [React Native]
const messages = await conversation.messages()
if (messages.size > 0 && messages[0].contentTypeId == 'xmtp.org/multiRemoteStaticContent:1.0') {
  // Decode the raw content back into a MultiRemoteAttachment
    const multiRemoteAttachment: MultiRemoteAttachment = messages[0].content()

    // See next section for download, and decrypt the attachments
}
```

```kotlin [Kotlin]
val messages = runBlocking { conversation.messages() }
if (messages.size > 0 && messages[0].encodedContent.type.id.equals(ContentTypeMultiRemoteAttachment)) {
    // Decode the raw content back into a MultiRemoteAttachment
  val multiRemoteAttachment: FfiMultiRemoteAttachment = messages[0].content()!!

  // See next section for download, and decrypt the attachments
}
```

```swift [Swift]
let messages = try await conversation.messages()
if messages.size > 0 && messages[0].encodedContent.type.id.equals(ContentTypeMultiRemoteAttachment.id) {
  // Decode the raw content back into a MultiRemoteAttachment
  let multiRemoteAttachment: MultiRemoteAttachment = try messages[0].content()

  // See next section for download, and decrypt the attachments
}
```

:::

### Decode, download, and decrypt the attachments

:::code-group

```ts [React Native]
const decryptedAttachments: DecryptedLocalAttachment[] = []

for (const attachment of multiRemoteAttachment.attachments) {
    // Downloading the encrypted payload from the attachment URL and save the local file
    // (Integrator must supply download from url and save to local Uri functionality!)
    const encryptedFileLocalURIAfterDownload: string = downloadFromUrl(
      attachment.url
    )
    // Decrypt the local file
    const decryptedLocalAttachment = await alix.decryptAttachment({
      encryptedLocalFileUri: encryptedFileLocalURIAfterDownload,
      metadata: {
        secret: attachment.secret,
        salt: attachment.salt,
        nonce: attachment.nonce,
        contentDigest: attachment.contentDigest,
        filename: attachment.filename,
      } as RemoteAttachmentContent,
    })
    decryptedAttachments.push(decryptedLocalAttachment)
  }
```

```kotlin [Kotlin]
val decryptedAttachments: MutableList<Attachment> = ArrayList()

for (remoteAttachmentInfo: FfiRemoteAttachmentInfo in multiRemoteAttachment.attachments) {
  // convert to FfiRemoteAttachmentInfo to RemoteAttachment
  val remoteAttachment = RemoteAttachment(
    url = URL(remoteAttachmentInfo.url),
    filename = remoteAttachmentInfo.filename,
    contentDigest = remoteAttachmentInfo.contentDigest,
    nonce = remoteAttachmentInfo.nonce.toByteString(),
    scheme = remoteAttachmentInfo.scheme,
    salt = remoteAttachmentInfo.salt.toByteString(),
    secret = remoteAttachmentInfo.secret.toByteString(),
    contentLength = remoteAttachmentInfo.contentLength?.toInt(),
  )
  // Download the encrypted payload (Integrator must supply download from url functionality!)
  val url = remoteAttachment.url.toString()
  val encryptedPayload: ByteArray = downloadFromUrl(url)

  // Combine encrypted payload with RemoteAttachment to create an EncryptedEncodedContent Object
  val encryptedAttachment: EncryptedEncodedContent = MultiRemoteAttachmentCodec.buildEncryptAttachmentResult(remoteAttachment, encryptedPayload)
  
  // Decrypt payload
  val encodedContent: EncodedContent = MultiRemoteAttachmentCodec.decryptAttachment(encryptedAttachment)
  
  // Convert EncodedContent to Attachment
  val attachment = attachmentCodec.decode(encodedContent)
  decryptedAttachments.add(attachment)
}
```

```swift [Swift]
var decryptedAttachments: [Attachment] = []

for remoteAttachmentInfo in multiRemoteAttachment.remoteAttachments {
    // convert to RemoteAttachmentInfo to RemoteAttachment
    let remoteAttachment = try RemoteAttachment(
        url: remoteAttachmentInfo.url,
        contentDigest: remoteAttachmentInfo.contentDigest,
        secret: remoteAttachmentInfo.secret,
        salt: remoteAttachmentInfo.salt,
        nonce: remoteAttachmentInfo.nonce,
        scheme: RemoteAttachment.Scheme(rawValue: remoteAttachmentInfo.scheme) ?? .https,
        contentLength: Int(remoteAttachmentInfo.contentLength),
        filename: remoteAttachmentInfo.filename
    )

    // Download the encrypted payload (Integrator must supply download from url functionality!)
    guard let encryptedPayload = downloadFromUrl(remoteAttachment.url)

    // Combine encrypted payload with RemoteAttachment to create an EncryptedEncodedContent Object
    let encryptedAttachment = MultiRemoteAttachmentCodec.buildEncryptAttachmentResult(
        remoteAttachment: remoteAttachment,
        encryptedPayload: downloadedPayload
    )

    // Decrypt payload
    let encodedContent = try MultiRemoteAttachmentCodec.decryptAttachment(encryptedAttachment)

    // Convert EncodedContent to Attachment
    let attachment: Attachment = try encodedContent.decoded()
    decryptedAttachments.append(attachment)
}
```

:::

### Accessing the unencrypted attachments

Use the file URIs in the decrypted attachments objects to display the attachments.

:::code-group

```ts [React Native]
// Example showing displaying attachments if they represent images
const attachment1 = decryptedAttachments[0]
const attachment2 = decryptedAttachments[1]

<Image source={{ uri: attachment1.fileUri }} />
<Image source={{ uri: attachment2.fileUri }} />
```

```kotlin [Kotlin]
// Example showing accessing filenames of final decrypted attachments
assertEquals(decryptedAttachments[0].filename, "test1.txt")
assertEquals(decryptedAttachments[1].filename, "test2.txt")

```

```swift [Swift]
// Example showing accessing filenames of final decrypted attachments
XCTAssertEqual(decryptedAttachments[0].filename, "test1.txt")
XCTAssertEqual(decryptedAttachments[1].filename, "test2.txt")
```

:::

## Support attachments smaller than 1MB

Attachments smaller than 1MB can be sent using the `AttachmentCodec`. The codec will automatically encrypt the attachment and upload it to the XMTP network.

:::warning

Unless a very specific use case we recommend using the [remote attachment content type](/chat-apps/content-types/attachments) instead since many attachments are larger than 1MB in a chat app.
:::

### Install the package

In some SDKs, the `AttachmentCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-remote-attachment
```

```bash [yarn]
yarn add @xmtp/content-type-remote-attachment
```

```bash [pnpm]
pnpm add @xmtp/content-type-remote-attachment
```

:::

### Import and register

:::code-group

```jsx [Browser]
import {
  AttachmentCodec,
} from "@xmtp/content-type-remote-attachment";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new AttachmentCodec()],
});
```

```jsx [React Native]
const client = await Client.create(signer, {
  env: "production",
  codecs: [new StaticAttachmentCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.Attachment
import org.xmtp.android.library.codecs.AttachmentCodec
import org.xmtp.android.library.codecs.ContentTypeAttachment

Client.register(codec = AttachmentCodec())
```

```swift [Swift]
Client.register(AttachmentCodec());
```

:::

### Load local file

```tsx
// Read local file and extract its details
const file = fs.readFileSync("xmtp.png");
const filename = path.basename("xmtp.png");
const extname = path.extname("xmtp.png");
console.log(`Filename: ${filename}`);
console.log(`File Type: ${extname}`);
```

### Send encrypted file

```tsx
// Convert the file to a Uint8Array
const blob = new Blob([file], { type: extname });
let imgArray = new Uint8Array(await blob.arrayBuffer());

const attachment = {
  filename: filename,
  mimeType: extname, //image, video or audio
  data: imgArray,
};

console.log("Attachment created", attachment);
await conversation.send(attachment, { contentType: ContentTypeAttachment });
```

### Receive encrypted file

```jsx
if (message.contentType.sameAs(ContentTypeAttachment)) {
  const blobdecoded = new Blob([message.content.data], {
    type: message.content.mimeType,
  });
  const url = URL.createObjectURL(blobdecoded);
}
```


## pages/chat-apps/content-types/fallback.mdx
# Use fallback text for content type compatibility

When building with XMTP, you can't know in advance whether a recipient's app will support a given content type, especially a [custom one](/chat-apps/content-types/custom). Likewise, your own app might receive messages with content types it doesn't support.

To prevent a poor user experience or app crashes, you should use the `fallback` property.

**For sending:** When sending a message with a custom content type, always provide a `fallback` string. This string offers a human-readable representation of the content. If the recipient's app doesn't support your custom type, it can display the `fallback` text instead. To learn more, see [Build custom content types](/chat-apps/content-types/custom).

**For receiving:** When your app receives a message, check if it supports the message's `contentType`. If not, render the `fallback` text.

However, some content types, especially those not meant for display (like read receipts), won't have a `fallback`. In these `undefined` cases, you should generally ignore the message entirely. Displaying a generic "unsupported content" message for every silent background event would create a poor user experience and clutter the chat. The code examples below show how to handle both scenarios.

:::code-group

```js [Browser]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```js [Node]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```jsx [React Native]
//contentTypeID has the following structure `${contentType.authorityId}/${contentType.typeId}:${contentType.versionMajor}.${contentType.versionMinor}`;
const isRegistered = message.contentTypeID in client.codecRegistry;
if (!isRegistered) {
  // Not supported content type
  if (message?.fallback != null) {
    return message?.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```kotlin [Kotlin]
val codec = client.codecRegistry.find(options?.contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```swift [Swift]
let codec = client.codecRegistry.find(for: contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

:::


## pages/chat-apps/content-types/content-types.mdx
# Understand content types with XMTP

When you build an app with XMTP, all messages are encoded with a content type to ensure that an XMTP client knows how to encode and decode messages, ensuring interoperability and consistent display of messages across apps.

In addition, message payloads are transported as a set of bytes. This means that payloads can carry any content type that a client supports, such as plain text, JSON, or even non-text binary or media content.

At a high level, there are three categories of content types with XMTP:

- Standard
- Standards-track
- Custom

## Standard content types

A standard content type is one that has undergone the XMTP Request for Comment (XRC) process and has been adopted as an [XMTP Improvement Proposal](https://github.com/xmtp/XIPs#readme) (XIP).

Once adopted, a standard content type is bundled in XMTP client SDKs. A developer can then import the standard content type from an SDK for use in their app.

Here is the current standard content type:

### Text content type

An app built with XMTP uses the `TextCodec` (plain text) standard content type by default. This means that if your app is sending plain text messages only, you don't need to perform any additional steps related to content types.

```jsx [Node]
await conversation.send("gm");
```

## Standards-track content types

A standards-track content type is one that's being actively reviewed for adoption as a standard content type through the XIP process.

Here are standards-track content types that you can review, test, and adopt in your app today:

- [Attachment content type](/chat-apps/content-types/attachments/#support-attachments-smaller-than-1mb): Use to send attachments smaller than 1MB.
- [Remote attachment content type](/chat-apps/content-types/attachments): Use to send attachments of any size.
- [Multiple remote attachments content type](/chat-apps/content-types/attachments#support-multiple-remote-attachments-of-any-size): Use to send attachments of any size.
- [Read receipt content type](/chat-apps/content-types/read-receipts): Use to send a read receipt, which is a `timestamp` that indicates when a message was read.
- [Reaction content type](/chat-apps/content-types/reactions): Use a reaction to send a quick and often emoji-based way to respond to a message.
- [Reply content type](/chat-apps/content-types/replies): Use a reply to send a direct response to a specific message in a conversation. Users can select and reply to a particular message instead of sending a new one.
- [Onchain transaction reference content type](/chat-apps/content-types/transaction-refs): Use to send references to onchain transactions, such as crypto payments.
- [Onchain transaction content type](/chat-apps/content-types/transactions): Use to support sending transactions to a wallet for execution.


## pages/chat-apps/content-types/replies.mdx
---
description: Learn how to use the reply content type to support quote replies in your app built with XMTP
---

# Support replies in your app built with XMTP

Use the reply content type to support quote replies in your app. A reply is a method to directly respond to a specific message in a conversation. Users can select and reply to a particular message instead of sending a new one.

## Use a local database for performance

Use a local database to store replies. This will enable your app to performantly display a reply with its [referenced message](#send-a-reply) when rendering message lists.

### Install the package

In some SDKs, the `ReplyCodec` is already included in the SDK. If not, you can install the package using the following command:

:::code-group

```bash [npm]
npm i @xmtp/content-type-reply
```

```bash [yarn]
yarn add @xmtp/content-type-reply
```

```bash [pnpm]
pnpm add @xmtp/content-type-reply
```

:::

## Configure the content type

After importing the package, you can register the codec.

:::code-group

```js [Browser]
import { ReplyCodec } from "@xmtp/content-type-reply";
// Create the XMTP client
const xmtp = await Client.create(signer, {
  env: "dev",
  codecs: [new ReplyCodec()],
});
```

```js [React Native]
const client = await Client.create(signer, {
  env: "production",
  codecs: [new ReplyCodec()],
});
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.ReplyCodec

Client.register(codec = ReplyCodec())
```

```swift [Swift]
Client.register(codec: ReplyCodec())
```

:::

## Send a reply

Once you've created a reply, you can send it. Replies are represented as objects with two keys:

- `reference`: ID of the message being replied to

- `content`: String representation of the reply

:::code-group

```ts [Browser]
import { ContentTypeText } from "@xmtp/content-type-text";
import { ContentTypeReply } from "@xmtp/content-type-reply";
import type { Reply } from "@xmtp/content-type-reply";

const reply: Reply = {
  reference: someMessageID,
  contentType: ContentTypeText,
  content: "I concur",
};

await conversation.send(reply, {
  contentType: ContentTypeReply,
});
```

```js [React Native]
// Assuming you have a conversation object and the ID of the message you're replying to
const replyContent = {
  reply: {
    reference: messageId, // ID of the message you're replying to
    content: {
      text: "This is a reply", // Content of the reply
    },
  },
};

await conversation.send(replyContent);
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.ContentTypeReply
import org.xmtp.android.library.codecs.ContentTypeText
import org.xmtp.android.library.codecs.Reply

// Assuming aliceConversation and messageToReact are already defined
val reply = Reply(
    reference = messageToReact.id,
    content = "Hello",
    contentType = ContentTypeText
)

aliceConversation.send(
    content = reply,
    options = SendOptions(contentType = ContentTypeReply),
)
```

```swift [Swift]
let reply = Reply(
  reference: messageToReply.id,
  content: "Hello",
  contentType: ContentTypeText
)

try await conversation.send(
  content: reply,
  options: .init(contentType: ContentTypeReply)
)
```

:::

## Receive the content type

:::code-group

```ts [Browser]
if (message.contentType.sameAs(ContentTypeReply)) {
  // We've got a reply.
  const reply: Reply = message.content;
}
```

```jsx [React Native]
if (message.contentTypeId === "xmtp.org/reply:1.0") {
  const reply = message.content();
  if (reply) {
    const replyContent: ReplyContent = reply;
    const replyContentType = replyContent.contentType;
    const codec = client.codecRegistry[replyContentType];
    const actualReplyContent = codec.decode(replyContent.content);
  }
}
```

```kotlin [Kotlin]
if (encodedContent.type == ContentTypeReply) {
    // The message is a reply
    val reply: Reply? = message.content()
    println("Reply to: ${reply?.reference}")
    println("Content: ${reply?.content}")
}
```

```swift [Swift]
let content: Reply = try message.content()
```

:::

To handle unsupported content types, refer to the [fallback](/chat-apps/content-types/fallback) section.

## Display the reply

How you choose to display replies in your app is up to you. It might be useful to look at the user experience for replies in popular apps such as Telegram and Discord.
For example, in Discord, users can reply to individual messages, and the reply provides a link to the original message.

Note that the user experience of replies in iMessage and Slack follows more of a threaded pattern, where messages display in logical groupings, or threads. This reply content type doesn't support the threaded pattern. If you'd like to request support for a threaded reply pattern, [post an XIP idea](https://community.xmtp.org/c/development/ideas/54).


## pages/chat-apps/user-consent/user-consent.mdx
# Understand how user consent preferences support spam-free chats

In any open and permissionless messaging ecosystem, spam is an inevitable reality, and XMTP is no exception.

However, with XMTP, you can give your users chats that are **spam-free spaces for chosen contacts only** by supporting user consent preferences.

## 🎥 walkthrough: Consent

This video provides a walkthrough of consent, covering the key ideas discussed in this doc. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/Qy_naNXYxmU?si=JEVL8Mruy_4Px4D5" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

## How user consent preferences work

With user consent preferences, an identity registered on the XMTP network can have one of three user consent preference values in relation to another user's identity:

- Unknown
- Allowed
- Denied

For example:

1. `alix.id` starts a conversation with `bo.id`. At this time, `alix.id` is unknown to `bo.id` and the conversation displays in a message requests UI.

2. When `bo.id` views the message request, they express their user consent preference to **Block** or **Accept** `alix.id` as a contact.

   - If `bo.id` accepts `alix.id` as a contact, their conversation displays in `bo.id`'s main inbox. Because only contacts `bo.id` accepts display in their main inbox, their inbox remains spam-free.

   - If `bo.id` blocks contact with `alix.id`, remove the conversation from `bo.id`'s view. In an appropriate location in your app, give the user the option to unblock the contact.

Your app should aim to handle consent preferences appropriately because they are an expression of user intent.

For example, if a user blocked a contact, your app should respect the user's intent to not see messages from the blocked contact. Handling the consent preference incorrectly and showing the user messages from the blocked contact may cause the user to lose trust in your app.

These user consent preferences are stored privately in an encrypted consent list on the XMTP network. The consent list is accessible by all apps that a user has authorized. This means a user can accept, or block, a contact once and have that consent respected across all other XMTP apps they use.

Be sure to load the latest consent list from the network at appropriate steps in your app flow to ensure that your app can operate using the latest data.

## How user consent preferences are set

Here are some of the ways user consent preferences are set:

### Unknown

Conversation created in an app on an SDK version **with** user consent support:

- For a new conversation that a peer contact wants to start with a user, the consent preference is set to `unknown`.

Conversation created in an app on an SDK version **without** user consent support:

- For all conversations with any peer contact, the consent preference is set to `unknown`.

### Allowed

Conversation created in an app on an SDK version **with** user consent support:

- For a new conversation that a user created with a peer contact, the SDK sets the consent preference to `allowed`.

  The user's creation of the conversation with the contact is considered consent.

- For an existing conversation created by a peer contact that hasn't had its consent preference updated on the network (`unknown`) and that the user responds to, the SDK will update the consent preference to `allowed`.

  The user's response to the conversation is considered consent.

- For a peer contact that a user has taken the action to allow, subscribe to, or enable notifications from, for example, the app must update the consent preference to `allowed`.

Conversation created in an app on an SDK version **without** user consent support:

- There are no scenarios in which a user consent preference will be set to `allowed`.

### Denied

Conversation created in an app on an SDK version **with** user consent support:

- For a peer contact that a user has taken the action to block, unsubscribe from, or disable notifications from, for example, the app must update the consent preference to `denied`.

Conversation created in an app on an SDK version **without** user consent support:

- There are no scenarios in which a user consent preference will be set to `denied`.


## pages/chat-apps/user-consent/support-user-consent.mdx
# Support user consent preferences to provide spam-free chats

Use the following methods to provide users with control over their messaging experience, ensuring their chats are tailored to their preferences and spam-free.

## Sync new consent preferences from the network

You can sync new consent preferences (and HMAC keys) from the network using any of these calls:

- [Sync preferences only](/chat-apps/list-stream-sync/sync-preferences)

- [Sync all new conversations, messages, and preferences](/chat-apps/list-stream-sync/sync-and-syncall)

- [Stream all group chat and DM messages and preferences](/chat-apps/list-stream-sync/stream)

## Get the consent state of a conversation

Check the current consent state of a specific conversation:

:::code-group

```js [Browser]
import { ConsentEntityType } from "@xmtp/browser-sdk";

// get consent state from the client
const conversationConsentState = await client.getConsentState(
  ConsentEntityType.GroupId,
  groupId
);

// or get consent state directly from a conversation
const groupConversation = await client.conversations.findConversationById(
  groupId
);
const groupConversationConsentState = await groupConversation.consentState();
```

```js [Node]
import { ConsentEntityType } from "@xmtp/node-sdk";

// get consent state from the client
const conversationConsentState = await client.getConsentState(
  ConsentEntityType.GroupId,
  groupId
);

// or get consent state directly from a conversation
const groupConversation = await client.conversations.findConversationById(
  groupId
);
const groupConversationConsentState = await groupConversation.consentState();
```

```tsx [React Native]
await conversation.consentState();
```

```kotlin [Kotlin]
conversation.consentState()
```

```swift [Swift]
try conversation.consentState()
```

:::

## Update the conversation consent state

Update the consent state of a conversation to allow or deny messages:

:::code-group

```js [Browser]
import { ConsentEntityType, ConsentState } from "@xmtp/browser-sdk";

// set consent state from the client (can set multiple states at once)
await client.setConsentStates([
  {
    entityId: groupId,
    entityType: ConsentEntityType.GroupId,
    state: ConsentState.Allowed,
  },
]);

// set consent state directly on a conversation
const groupConversation = await client.conversations.findConversationById(
  groupId
);
await groupConversation.updateConsentState(ConsentState.Allowed);
```

```js [Node]
import { ConsentEntityType, ConsentState } from "@xmtp/node-sdk";

// set consent state from the client (can set multiple states at once)
await client.setConsentStates([
  {
    entityId: groupId,
    entityType: ConsentEntityType.GroupId,
    state: ConsentState.Allowed,
  },
]);

// set consent state directly on a conversation
const groupConversation = await client.conversations.findConversationById(
  groupId
);
await groupConversation.updateConsentState(ConsentState.Allowed);
```

```tsx [React Native]
await conversation.updateConsent("allowed"); // 'allowed' | 'denied'
```

```kotlin [Kotlin]
conversation.updateConsent(ALLOWED) // ALLOWED | DENIED
```

```swift [Swift]
try await conversation.updateConsent(.allowed) // .allowed | .denied
```

:::

## Stream consent preferences in real-time

Listen for real-time updates to consent preferences:

:::code-group

```tsx [Browser]
// Stream consent records in real-time
const stream = await client.preferences.streamConsent({
  onValue: (updates) => {
    // Received consent updates
    console.log("Consent updates:", updates);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Consent stream failed");
  }
});

// Or use for-await loop
for await (const updates of stream) {
  // Received consent updates
  console.log("Consent updates:", updates);
}
```

```tsx [Node]
// Stream consent records in real-time
const stream = await client.preferences.streamConsent({
  onValue: (updates) => {
    // Received consent updates
    console.log("Consent updates:", updates);
  },
  onError: (error) => {
    // Log any stream errors
    console.error(error);
  },
  onFail: () => {
    console.log("Consent stream failed");
  }
});

// Or use for-await loop
for await (const updates of stream) {
  // Received consent updates
  console.log("Consent updates:", updates);
}
```

```tsx [React Native]
await client.preferences.streamConsent()
```

```kotlin [Kotlin]
client.preferences.streamConsent().collect {
  // Received ConsentRecord
}
```

```swift [Swift]
for await consent in try await client.preferences.streamConsent() {
  // Received consent
}
```

:::

## Update consent for an individual in a group chat

Update the consent state for an individual in a group chat:

:::tip[Note]
You may want to enable users to deny or allow a users on an individual basis. You can then update the group chat UI to hide messages from denied individuals.
:::

:::code-group

```js [Browser]
import { ConsentEntityType, ConsentState } from "@xmtp/browser-sdk";

await client.setConsentStates([
  {
    entityId: inboxId,
    entityType: ConsentEntityType.InboxId,
    state: ConsentState.Denied,
  },
]);
```

```js [Node]
import { ConsentEntityType, ConsentState } from "@xmtp/node-sdk";

// set consent state from the client (can set multiple states at once)
await client.setConsentStates([
  {
    entityId: inboxId,
    entityType: ConsentEntityType.InboxId,
    state: ConsentState.Denied,
  },
]);
```

```tsx [React Native]
await client.preferences.setConsentState(
  new ConsentRecord(inboxId, 'inbox_id', 'denied')
)
```

```kotlin [Kotlin]
client.preferences.setConsentState(
    listOf(
        ConsentRecord(
            inboxId,
            EntryType.INBOX_ID,
            ConsentState.DENIED
        )
    )
)
```

```swift [Swift]
try await client.preferences.setConsentState(
  entries: [
    ConsentRecord(
      value: inboxID, 
      entryType: .inbox_id,
      consentType: .denied)
  ])
```

:::

## Get the consent state of an individual in a group chat

Get the consent state of an individual in a group chat:

:::tip[Note]
You may want to enable users to deny or allow a users on an individual basis. You can then update the group chat UI to hide messages from denied individuals.
:::

:::code-group

```js [Browser]
import { ConsentEntityType } from "@xmtp/browser-sdk";

const inboxConsentState = await client.getConsentState(
  ConsentEntityType.InboxId,
  inboxId
);
```

```js [Node]
import { ConsentEntityType } from "@xmtp/node-sdk";

const inboxConsentState = await client.getConsentState(
  ConsentEntityType.InboxId,
  inboxId
);
```

```tsx [React Native]
// Get consent directly on the member
const memberConsentStates = (await group.members()).map(
  (member) => member.consentState()
)

// Get consent from the inboxId
const inboxConsentState = await client.preferences.inboxIdConsentState(inboxId)
```

```kotlin [Kotlin]
// Get consent directly on the member
val memberConsentStates = group.members().map { it.consentState }

// Get consent from the inboxId
val inboxConsentState = client.preferences.inboxIdState(inboxId)
```

```swift [Swift]
// Get consent directly on the member
let memberConsentStates = try await group.members.map(\.consentState)

// Get consent from the inboxId
let inboxConsentState = try await client.preferences.inboxIdState(inboxId: inboxId)
```

:::

## See who created and added you to a group

Get the inbox ID of the individual who added you to a group or created the group to check the consent state for it:

```tsx [React Native]
group.addedByInboxId
await group.creatorInboxId()
```

```kotlin [Kotlin]
group.addedByInboxId()
group.creatorInboxId()
```

```swift [Swift]
try await group.addedByInboxId()
try await group.creatorInboxId()
```

## Handle unknown contacts

With user consent preferences, an inbox ID or conversation ID can have one of three user consent preference values in relation to another user's inbox ID:

- Unknown
- Allowed
- Denied

You can implement user consent preferences to give your users inboxes that are **spam-free spaces for allowed conversations and contacts only**.

You can then handle message requests from unknown contacts in a separate UI.

These message requests from unknown contacts could be from:

- Contacts the user might know
- Contacts the user might not know
- Spammy or scammy contacts

You can filter these unknown contacts to:

- Identify contacts the user might know or want to know and display them on a **You might know** tab, for example.
- Identify contacts the user might not know and not want to know, which might include spam, and display them on a **Hidden requests** tab, for example.

### Identify contacts the user might know

To identify contacts the user might know or want to know, you can look for signals in onchain data that imply an affinity between addresses.

```kotlin
val inboxState = inboxStateForInboxId(inboxId)
val identities = inboxState.identities
val ethAddresses = identities
    .filter { it.kind == ETHEREUM }
    .map { it.identifier }
```

You can then display appropriate messages on a **You might know** tab, for example.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/you-might-know-tab.jpg" width="400" />
</div>

### Identify contacts the user might not know, including spammy or scammy requests

To identify contacts the user might not know or not want to know, which might include spam, you can consciously decide to scan messages in an unencrypted state to find messages that might contain spammy or scammy content. You can also look for an absence of onchain interaction data between the addresses, which might indicate that there is no affinity between addresses. You can then filter the appropriate messages to display on a **Hidden requests** tab, for example.

<div>
<img src="https://raw.githubusercontent.com/xmtp/docs-xmtp-org/refs/heads/main/docs/pages/img/hidden-requests-tab.jpg" width="400" />
</div>

The decision to scan unencrypted messages is yours as the app developer. If you take this approach:

- Handle unencrypted messages with extreme care, and don't store unencrypted messages beyond the time necessary to scan them.
- Consider telling users that your app scans unencrypted messages for spammy or scammy content.
- Consider making spam and scam message detection optional for users who prefer not to have their messages scanned.

### Why is content moderation handled by apps and not XMTP?

XMTP is a decentralized, open protocol built to ensure private, secure, and censorship-resistant communication. As such, XMTP can't read unencrypted messages, and therefore, it also can't scan or filter message contents for spammy or scammy material.

The protocol can analyze onchain data signals, such as shared activity between wallet addresses, to infer potential affinities between addresses. However, because all XMTP repositories are open source, malicious actors could inspect these methods and develop workarounds to bypass them.

Additionally, applying spam filtering or content moderation directly at the protocol level would introduce centralization, which goes against the decentralized, permissionless, and open ethos of XMTP and web3. A protocol-driven approach could limit interoperability and trust by imposing subjective rules about content across all apps.

Instead, content filtering and moderation should be implemented at the app layer. Apps can decide how opinionated or lenient they want to be, tailoring their filtering approach to the needs of their users. For example, one app may choose to aggressively scan and block spam to provide a highly curated experience, attracting users who value more protection. Another app may opt for minimal or no filtering, appealing to users who prioritize full control and unfiltered communication.

This flexibility enables different apps to serve different user preferences, fostering an ecosystem where users can choose the experience that best suits them. Whether an app scans messages or not, XMTP ensures that developers remain free to build in line with their own values, without imposing restrictions at the infrastructure level. This separation between the protocol and app layers is crucial to maintaining XMTP's commitment to openness, interoperability, and user choice.

:::tip

Is your app using a great third-party or public good tool to help with spam and keep chats safe? Open an [issue](https://github.com/xmtp/docs-xmtp-org/issues) to share information about it.

:::


# Summary

This documentation contains 75 files.
