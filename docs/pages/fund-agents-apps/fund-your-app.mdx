import *as React from 'react';
import* as RadixTabs from '@radix-ui/react-tabs';

{/*
Custom Tabs component for creating tabbed content in documentation.

This component is defined inline instead of imported from a separate file
because Vocs has a bug where local file imports break search indexing.
Only npm package imports (like react and @radix-ui/react-tabs) are safe.

Features:

- Renders tabbed content with styling that matches Vocs theme
- Auto-switches to the correct tab when clicking outline/TOC links
- Uses forceMount to keep all tab content in DOM (required for outline links)
- Polls for hash changes as fallback when hashchange events don't fire

Usage:

  <Tabs.Root defaultValue="tab-id">
    <Tabs.List>
      <Tabs.Trigger value="tab1">Tab 1 Title</Tabs.Trigger>
      <Tabs.Trigger value="tab2">Tab 2 Title</Tabs.Trigger>
    </Tabs.List>
    <Tabs.Content value="tab1">Content for tab 1</Tabs.Content>
    <Tabs.Content value="tab2">Content for tab 2</Tabs.Content>
  </Tabs.Root>
*/}
export const Tabs = (() => {
  const Root = ({ defaultValue, children }) => {
    const [activeTab, setActiveTab] = React.useState(defaultValue);
    const rootRef = React.useRef(null);

    React.useEffect(() => {
      const timeouts = [];

      const switchToTabContainingHash = () => {
        const hash = window.location.hash.slice(1);
        if (!hash) return;

        const timeoutId = setTimeout(() => {
          const allHeadings = document.querySelectorAll(`[id="${hash}"]`);

          allHeadings.forEach((heading) => {
            const tabContent = heading.closest('[data-value]');
            if (tabContent && rootRef.current?.contains(tabContent)) {
              const tabValue = tabContent.getAttribute('data-value');
              if (tabValue && tabValue !== activeTab) {
                setActiveTab(tabValue);
                const scrollTimeoutId = setTimeout(() => {
                  heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
                timeouts.push(scrollTimeoutId);
              }
            }
          });
        }, 100);
        timeouts.push(timeoutId);
      };

      switchToTabContainingHash();
      window.addEventListener('hashchange', switchToTabContainingHash);

      const interval = setInterval(() => {
        const hash = window.location.hash.slice(1);
        if (hash) {
          const heading = document.getElementById(hash);
          if (heading) {
            const tabContent = heading.closest('[data-value]');
            if (tabContent && rootRef.current?.contains(tabContent)) {
              const tabValue = tabContent.getAttribute('data-value');
              if (tabValue && tabValue !== activeTab) {
                setActiveTab(tabValue);
                const scrollTimeoutId = setTimeout(() => {
                  heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
                timeouts.push(scrollTimeoutId);
              }
            }
          }
        }
      }, 500);

      return () => {
        window.removeEventListener('hashchange', switchToTabContainingHash);
        clearInterval(interval);
        timeouts.forEach(clearTimeout);
      };
    }, [activeTab]);

    return React.createElement(RadixTabs.Root, {
      value: activeTab,
      onValueChange: setActiveTab,
      className: 'tabs-root',
      ref: rootRef
    }, children);

};

const List = ({ children }) =>
React.createElement(RadixTabs.List, { className: 'tabs-list' }, children);

const Trigger = ({ value, children }) =>
React.createElement(RadixTabs.Trigger, { value, className: 'tabs-trigger' }, children);

const Content = ({ value, children }) =>
React.createElement(RadixTabs.Content, {
value,
className: 'tabs-content',
forceMount: true,
'data-value': value
}, children);

return { Root, List, Trigger, Content };
})();

{/*
Note: CSS is inlined here instead of imported from a separate file
because Vocs has a bug where local file imports (like import './styles.css')
break search indexing. npm package imports are fine, but CSS files must be inlined.
*/}

<style>{`
.tabs-root {
  display: flex;
  flex-direction: column;
  margin: 1.5rem 0;
}

.tabs-list {
  display: flex;
  border-bottom: 1px solid var(--vocs-color_border);
  gap: 0;
}

.tabs-trigger {
  all: unset;
  font-family: inherit;
  background-color: transparent;
  padding: 0.75rem 1.5rem;
  height: 45px;
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9375rem;
  line-height: 1;
  color: var(--vocs-color_text3);
  user-select: none;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
}

.tabs-trigger:hover {
  color: var(--vocs-color_text);
  background-color: var(--vocs-color_background2);
}

.tabs-trigger[data-state="active"] {
  color: var(--vocs-color_text);
  border-bottom-color: var(--vocs-color_link);
  font-weight: 500;
}

.tabs-trigger:focus-visible {
  outline: 2px solid var(--vocs-color_link);
  outline-offset: 2px;
}

.tabs-content {
  padding: 1.5rem 0;
  outline: none;
}

.tabs-content[data-state="inactive"] {
  display: block !important;
  position: absolute;
  opacity: 0;
  pointer-events: none;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.tabs-content:focus {
  outline: none;
}

.tabs-content > *:not(:last-child) {
  margin-bottom: var(--vocs-space_24);
}

.tabs-content > *:last-child {
  margin-bottom: 0;
}
`}</style>

# Fund an app or agent to send messages with XMTP

Use this guide to learn how to use the XMTP Funding Portal to fund an app or agent to send messages with XMTP. You can also use the portal to view usage and current and projected fees.

Behind the scenes, the Funding Portal handles Payer Registry smart contract deposits, XMTP Broadcast Network messaging fee and XMTP App Chain gas payments, and all blockchain interactions.

[Ephemera](https://ephemerahq.com/) currently hosts the XMTP Funding Portal UI as a community service. Stewardship will move to DUNA post-GA.

The [smart contracts](https://github.com/xmtp/smart-contracts) used by the portal are fully decentralized and non-custodial. Full audits from [Trail of Bits](https://www.trailofbits.com/) and [Octane](https://www.octane.security/) will be published before paid messaging is enforced.

## Understand payer wallets

A payer wallet is what an app or agent's XMTP Gateway Service uses to pay fees.

You can:

- [Self-fund a payer wallet](#self-fund-a-payer-wallet)
- [Fund a payer wallet using another wallet](#fund-a-payer-wallet-using-another-wallet)

For example, you might self-fund your payer wallet if it already has or can easily obtain USDC. Or, you might ask your finance team to fund your payer wallet from a company multi-sig. You might also use a wallet you control to support a different app or agent by funding its payer wallet.

<Tabs.Root defaultValue="self-fund">
  <Tabs.List>
    <Tabs.Trigger value="self-fund">Self-fund a payer wallet</Tabs.Trigger>
    <Tabs.Trigger value="other-wallet">Fund a payer wallet using another wallet</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Content value="self-fund">

## Self-fund a payer wallet

### Step 1. Create the payer wallet

The payer wallet must be:

- A standard Ethereum-compatible wallet account
- Non-custodial, meaning you control the private key (not a third-party service)
- Able to sign and transact on the Base and XMTP App Chain networks
- Able to hold and transfer USDC tokens

You can create a payer wallet using common non-custodial wallet apps, such as Coinbase Wallet and MetaMask.

Payer wallets can be funded by Ethereum EOAs and smart contract wallets. For example, a Gnosis Safe or any ERC-1271 wallet can deposit funds into a payer account using the Funding Portal.

You'll need your payer wallet's private key when setting up your [XMTP Gateway Service](/fund-agents-apps/run-gateway).

### Step 2. Register the payer wallet

1. Use your payer wallet to connect to the XMTP Funding Portal → testnet link coming soon.
2. On the **Welcome** page, click **Use connected wallet**.
3. Open the drop-down menu in the upper right and click **Manage payers**.
4. Click the pencil icon to give your payer wallet a human-readable name.
5. Click the green check button to save.

Your payer wallet is now a payer in the Payer Registry smart contract.

### Step 3: Fund the payer wallet with USDC on Base

Fund your payer wallet with USDC on Base. Here are some sources you can use to acquire USDC:

- Centralized exchanges: Binance, Coinbase, Kraken
- Direct purchase: Circle, Coinbase
- Business accounts: Circle business accounts for larger operations

To get USDC on Base Sepolia for use with XMTP testnet, you can use [https://faucet.circle.com/](https://faucet.circle.com/), which provides 10 USDC per hour.

### Step 4: Allocate funds for messaging

:::warning

Once you self-fund a payer wallet, only the payer wallet can [withdraw](#step-6-withdraw-and-claim-funds) USDC from the messaging and gas fee allowance.

- Withdrawals from the Payer Registry will be available after 48 hours and require a second transaction to claim.
- Withdrawals from the XMTP App Chain that require bridging to Base will be available after 7 days and require a second transaction to claim.

:::

The XMTP Funding Portal will accept only testnet USDC until **November 1, 2025**. Plan your testnet and mainnet funding accordingly.

1. Connect the payer wallet to the XMTP Funding Portal → testnet link coming soon.
2. In the drop-down menu in the upper right, be sure to select the payer wallet.
3. On the **Dashboard** page, click **Fund**.
4. Enter the amount of USDC you want to allocate from your payer wallet.
5. The XMTP Funding Portal automatically optimizes how the funds are allocated to cover messaging fees and gas fees. Expand the **Transaction details** area to view the details of the split.
6. Click **Continue**.
7. The **Depositing funds** screen displays. You can click **Cancel transaction** to attempt to cancel the transaction, if needed.

Your payer wallet now has:

- USDC allocated to your registered payer wallet in the Payer Registry smart contract. This allowance will be used to pay XMTP Broadcast Network messaging fees.
- USDC bridged to your payer wallet on the XMTP App Chain. This balance will be used to pay XMTP App Chain gas fees.

### Step 5: Monitor your usage and allowance

You can use the **Usage** panel on the XMTP Funding Portal **Dashboard** to review the number of messages sent by your app, as well as actual and projected fees.

Before data can display in the Usage panel, you must have completed the following on the appropriate network (testnet or mainnet):

1. [Deployed your XMTP Gateway Service](/fund-agents-apps/run-gateway)
2. Updated your app to [use a compatible XMTP SDK](/fund-agents-apps/update-sdk)
3. Sent messages using your app

We recommend funding an allowance for 3-6 months of estimated usage.

If your allowance goes to zero, the Payer Registry smart contract rejects new messages sent to the XMTP Broadcast Network and returns an `INSUFFICIENT_PAYER_BALANCE` error.

### Step 6: Withdraw and claim funds

You can use the payer wallet (and only the payer wallet) to withdraw USDC from the messaging and gas fee allowance at any time.

- Withdrawals from the Payer Registry will be available after 48 hours and require a second transaction to claim.
- Withdrawals from the XMTP App Chain that require bridging to Base will be available after 7 days and require a second transaction to claim.

1. Connect your payer wallet to the XMTP Funding Portal → testnet link coming soon.
2. On the **Dashboard** page, click **Withdraw**.
3. Enter the amount of USDC you want to withdraw from your messaging balance. Click **MAX** if you want to withdraw the maximum amount available.
4. Click **Request withdrawal**.
5. After the required wait time, return to the XMTP Funding Portal to complete your withdrawal. On the homepage, view the **Transaction** panel and locate your **Withdrawal** and **Bridge** transactions. The **Status** column should be set to **_Ready to withdraw_**.
6. Click **Ready to withdraw** to display the **Transaction details** panel.
7. Verify the withdrawal details and click **Claim USDC**.

</Tabs.Content>

<Tabs.Content value="other-wallet">

## Fund a payer wallet using another wallet

### Step 1. Get the payer wallet address

To fund an app using a wallet other than its payer wallet, you need the payer wallet address.

### Step 2. Select the payer wallet you want to fund

1. Use the wallet you want to use to fund the payer wallet to connect to the XMTP Funding Portal → testnet link coming soon.
2. On the **Welcome** page, click **Use other wallet**.
3. On the **Manage payer wallets** screen, enter the payer wallet address you want to fund and a human-readable display name.
4. Click the green check button to save.

Your wallet can now fund the payer wallet.

### Step 3: Deposit USDC into your wallet

Deposit USDC into your wallet on Base. This is the wallet you want to use to fund the payer wallet.

Here are some sources you can use to acquire USDC:

- Centralized exchanges: Binance, Coinbase, Kraken
- Direct purchase: Circle, Coinbase
- Business accounts: Circle business accounts for larger operations

To get USDC on Base Sepolia for use with XMTP testnet, you can use [https://faucet.circle.com/](https://faucet.circle.com/), which provides 10 USDC per hour.

### Step 4: Allocate funds to the payer wallet

:::warning

Once you use your wallet to allocate funds to the payer wallet, only the payer wallet can [withdraw](#step-6-withdraw-and-claim-funds) USDC from the messaging fee allowance.

:::

The XMTP Funding Portal will accept only testnet USDC until **November 1, 2025**. Plan your testnet and mainnet funding accordingly.

1. Use the wallet you funded in Step 3 to connect to the XMTP Funding Portal → testnet link coming soon.
2. In the drop-down menu in the upper right, be sure to select the payer wallet.
3. On the **Dashboard** page, click **Fund**.
4. Enter the amount of USDC you want to allocate from your wallet to the payer wallet.
5. The XMTP Funding Portal automatically optimizes how the funds are allocated to cover messaging fees and gas fees. Expand the **Transaction details** area to view the details of the split.
6. Click **Continue**.
7. The **Depositing funds** screen displays. You can click **Cancel transaction** to attempt to cancel the transaction, if needed.

The payer wallet now has:

- USDC allocated to the registered payer wallet in the Payer Registry smart contract. This allowance will be used to pay XMTP Broadcast Network messaging fees.
- USDC bridged to the payer wallet on the XMTP App Chain. This balance will be used to pay XMTP App Chain gas fees.

</Tabs.Content>
</Tabs.Root>

## Troubleshooting

### Is there a testnet?

Yes. The XMTP App Chain testnet and XMTP Broadcast Network testnet run smart contracts that are identical to those run on mainnet.

You can dry-run allocating funds using Base Sepolia USDC and sending messages using these XMTP testnets.

### Signature rejected (MetaMask only)

If you see a **Signature rejected** error in MetaMask, it can sometimes be caused by a stuck or out-of-sync **nonce** (a number that keeps track of your transaction order).

To fix this:

1. Open MetaMask.
2. Click your **account icon** in the top right.
3. Go to **Settings → Advanced**.
4. Click **Reset Account**. This does not affect your funds or wallet.

If the issue persists:

- Check for any stuck or pending transactions in your wallet.
- Try sending a new transaction with a **custom nonce** if needed.

### Bridge pending > 15 min

Check Base status: [https://status.base.org/](https://status.base.org/).

### Message reverted

Check for `INSUFFICIENT_PAYER_BALANCE`.

### Region restrictions

Nodes in the XMTP testnet and mainnet that operate in US jurisdiction do so in compliance with Office of Foreign Assets Control (OFAC) sanctions and Committee on Foreign Investment in the United States (CFIUS) export compliance regulations. Accordingly, for these nodes, IP-based geoblocking is in place for the following countries/territories:

- Cuba
- Iran
- North Korea
- Syria
- The Crimea, Donetsk People’s Republic, and Luhansk People’s Republic regions of Ukraine
