---
description: Learn how to implement an onchain transaction reference content type
---

# Support onchain transaction references in your app built with XMTP

This package provides an XMTP content type to support onchain transaction references. It is a reference to an onchain transaction sent as a message. This content type facilitates sharing transaction hashes or IDs, thereby providing a direct link to onchain activities. Transaction references serve to display transaction details, facilitating the sharing of onchain activities, such as token transfers, between users.

:::tip[Open for feedback]

You're welcome to provide feedback by commenting on [XIP-21: Onchain transaction reference content type](https://community.xmtp.org/t/xip-21-on-chain-transaction-reference-content-type/532).

:::

## Configure the content type

For Browser SDK (v6.0.0+) and Node SDK (v5.0.0+), transaction references are built-in and do not require codec registration. Skip this step for these SDKs.

For other SDKs, register the codec:

:::code-group

```kotlin [Kotlin]
import org.xmtp.android.library.Client
import org.xmtp.android.library.Signer
import org.xmtp.android.library.codecs.ContentTypeTransactionReference
import org.xmtp.android.library.codecs.TransactionReferenceCodec

Client.register(codec = TransactionReferenceCodec())

// Create the XMTP client (assume account is a Signer)
val xmtp = Client.create(account)
```

```swift [Swift]
import XMTP
import XMTPContentTypeTransactionReference

let codec = TransactionReferenceCodec()
Client.register(codec: codec)

// Create the XMTP client (assume account is a signer)
let xmtp = try await Client.create(account: account)
```

:::

## Send a transaction reference

With XMTP, a transaction reference is represented as an object with the following keys:

:::code-group

```ts [Browser]
const transactionReference = {
  namespace: "eip155",
  networkId: 1,
  reference: "0x123...abc",
  metadata: {
    transactionType: "transfer",
    currency: "USDC",
    amount: 100000,
    decimals: 6,
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  }
};
```

```ts [Node]
const transactionReference = {
  namespace: "eip155",
  networkId: 1,
  reference: "0x123...abc",
  metadata: {
    transactionType: "transfer",
    currency: "USDC",
    amount: 100000,
    decimals: 6,
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  }
};
```

```kotlin [Kotlin]
import org.xmtp.android.library.codecs.TransactionReference

val transactionReference = TransactionReference(
  namespace = "eip155",
  networkId = "1",
  reference = "0x123...abc",
  metadata = TransactionReference.Metadata(
    transactionType = "transfer",
    currency = "USDC",
    amount = 100000.0,
    decimals = 6u,
    fromAddress = "0x456...def",
    toAddress = "0x789...ghi"
  )
)
```

```swift [Swift]
import XMTPContentTypeTransactionReference

let transactionReference = TransactionReference(
  namespace: "eip155",
  networkId: "1",
  reference: "0x123...abc",
  metadata: TransactionReference.Metadata(
    transactionType: "transfer",
    currency: "USDC",
    amount: 100_000,
    decimals: 6,
    fromAddress: "0x456...def",
    toAddress: "0x789...ghi"
  )
)
```

:::

Once you have a transaction reference, you can send it as part of your conversation:

:::code-group

```js [Browser]
await conversation.sendTransactionReference(transactionReference);
```

```js [Node]
await conversation.sendTransactionReference(transactionReference);
```

```kotlin [Kotlin]
import kotlinx.coroutines.runBlocking
import org.xmtp.android.library.SendOptions
import org.xmtp.android.library.codecs.ContentTypeTransactionReference

runBlocking {
  conversation.send(
    content = transactionReference,
    options = SendOptions(contentType = ContentTypeTransactionReference)
  )
}
```

```swift [Swift]
try await conversation.send(
  transactionReference,
  options: SendOptions(contentType: ContentTypeTransactionReference)
)
```

:::

## Receive a transaction reference

To receive and process a transaction reference, you can use the following code samples.

To handle unsupported content types, refer to the [fallback](/chat-apps/content-types/fallback) section.

:::code-group

```ts [Browser]
import { contentTypesAreEqual } from '@xmtp/content-type-primitives';
import { contentTypeTransactionReference } from '@xmtp/browser-sdk';

const messages = await conversation.messages();
const message = messages[0];

if (contentTypesAreEqual(message.contentType, await contentTypeTransactionReference())) {
  const transactionRef = message.content;
  // Process the transaction reference here
  console.log('Network:', transactionRef.networkId);
  console.log('Transaction:', transactionRef.reference);
}
```

```ts [Node]
import { contentTypesAreEqual } from '@xmtp/content-type-primitives';
import { contentTypeTransactionReference } from '@xmtp/node-sdk';

const messages = await conversation.messages();
const message = messages[0];

if (contentTypesAreEqual(message.contentType, contentTypeTransactionReference())) {
  const transactionRef = message.content;
  // Process the transaction reference here
  console.log('Network:', transactionRef.networkId);
  console.log('Transaction:', transactionRef.reference);
}
```

```kotlin [Kotlin]
// Assume message is a DecodedMessage
if (message.type == ContentTypeTransactionReference) {
  val transactionRef: TransactionReference? = message.content()
  // Process the transaction reference here
}
```

```swift [Swift]
if message.contentType == ContentTypeTransactionReference {
  if let transactionRef = message.content as? TransactionReference {
    // Process the transaction reference here
  }
}
```

:::

## Display the transaction reference

Displaying a transaction reference typically involves rendering details such as the transaction hash, network ID, and any relevant metadata. Because the exact UI representation can vary based on your app's design, you might want to fetch onchain data before showing it to the user.
