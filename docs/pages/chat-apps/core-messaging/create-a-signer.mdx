# Create a EOA or SCW signer

XMTP SDKs support message signing with 2 different types of Ethereum accounts: **Externally Owned Accounts** (EOAs) and **Smart Contract Wallets** (SCWs).

Smart contract wallets have addresses that are unique to the chain on which they are deployed, while EOAs share the same address across multiple EVM-compatible chains.

All XMTP clients require a signer object (or instance) that provides a method for signing messages on behalf of the account.

## Wallet comparison

| Feature        | Wallet (EOA)                                                                                  | Smart Wallet (SCW)                                                                                                       |
| -------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| On-chain form  | Native account                                                                                | Smart contract                                                                                                           |
| Authentication | [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) private key | Programmable (e.g. [Passkeys](https://fidoalliance.org/passkeys/))                                                       |
| Recovery       | Recovery / Seed phrase                                                                        | Programmable ([multisig](https://shivanisb10.medium.com/multisig-contracts-in-ethereum-ffd8a1a9a025), trusted guardians) |
| Gas payment    | User pays native gas                                                                          | Relayer can pay (e.g. [Base](https://www.base.org/))                                                                     |
| Security model | Single key                                                                                    | Policy-based, multi-layer security                                                                                       |

## Create an Externally Owned Account signer

The EOA signer must have 3 properties: the account type, a function that returns the account identifier, and a function that signs messages.

:::code-group

```tsx [Browser]
import type { Signer, Identifier } from '@xmtp/browser-sdk';
import { IdentifierKind } from '@xmtp/browser-sdk';

const accountIdentifier: Identifier = {
  identifier: '0x...', // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: 'EOA',
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};
```

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from '@xmtp/node-sdk';

const accountIdentifier: Identifier = {
  identifier: '0x...', // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: 'EOA',
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
};
```

```tsx [React Native]
// Example EOA Signer
export function convertEOAToSigner(eoaAccount: EOAAccount): Signer {
  return {
    getIdentifier: async () =>
      new PublicIdentity(eoaAccount.address, 'ETHEREUM'),
    getChainId: () => undefined, // Provide a chain ID if available or return undefined
    getBlockNumber: () => undefined, // Block number is typically not available in Wallet, return undefined
    signerType: () => 'EOA', // "EOA" indicates an externally owned account
    signMessage: async (message: string) => {
      const signature = await eoaAccount.signMessage(message);

      return {
        signature,
      };
    },
  };
}
```

```kotlin [Kotlin]
class EOAWallet : SigningKey {
    override val publicIdentity: PublicIdentity
      get() = PublicIdentity(
          IdentityKind.ETHEREUM,
          key.publicAddress
      )
    override val type: SignerType
      get() = SignerType.EOA

    override suspend fun sign(message: String): SignedData {
        val signature = key.sign(message = message)
        return SignedData(signature)
    }
}
```

```swift [Swift]
public struct EOAWallet: SigningKey {
    public var identity: PublicIdentity {
      return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
    }

    public var type: SignerType { .EOA }

    public func sign(message: String) async throws -> SignedData {
        let signature = try await key.sign(message: message)
        return SignedData(signature)
    }
}
```

:::

## Create a Smart Contract Wallet signer

The SCW signer has the same 3 required properties as the EOA signer, but also requires a function that returns the chain ID of the blockchain being used and an optional function that returns the block number to verify signatures against. If a function is not provided to retrieve the block number, the latest block number will be used.

Here is a list of supported chain IDs for SCWs:

| Chain ID | Network          |
| -------- | ---------------- |
| 0        | Signifies an EOA |
| 1        | Ethereum Mainnet |
| 10       | Optimism         |
| 100      | Gnosis           |
| 137      | Polygon          |
| 232      | Lens             |
| 324      | zkSync Era       |
| 480      | World            |
| 2741     | Abstract         |
| 8453     | Base             |
| 42161    | Arbitrum One     |
| 59144    | Linea            |

:::tip[Note]
Chain ID `0` is reserved by XMTP as a sentinel value indicating that an inbox was registered via an EOA rather than a Smart Contract Wallet. Standard EOA signatures can be used for inboxes registered by EOAs that support [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702), which enables smart-wallet functionality on demand.
:::

To add SCW support for a new EVM chain, add the chain ID and a public RPC endpoint to [chain_urls_default.json](https://github.com/xmtp/libxmtp/blob/main/xmtp_id/src/scw_verifier/chain_urls_default.json).

The details of creating an SCW signer are highly dependent on the wallet provider and the library you're using to interact with it. Here are some general guidelines to consider:

- **Wallet provider integration**: Different wallet providers (Safe, Argent, Rainbow, etc.) have different methods for signing messages. See the wallet provider documentation for more details.

- **Library selection**: Choose a library that supports your wallet provider (e.g., viem, ethers.js, web3.js). Each library has its own API for interacting with wallets. See the library documentation for more details.

- **Add an Ethereum-specific prefix**: Before signing, Ethereum requires a specific prefix to be added to the message. To learn more, see [ERC-191: Signed Data Standard](https://eips.ethereum.org/EIPS/eip-191). Libraries and wallet providers might add the prefix for you, so make sure you don't add the prefix twice.

- **Hash the prefixed message with Keccak-256**: The prefixed message is hashed using the Keccak-256 algorithm, which is Ethereum's standard hashing algorithm. This step creates a fixed-length representation of the message, ensuring consistency and security. Note that some wallet providers might handle this hashing internally.

- **Sign the replay-safe hash**: The replay-safe hash is signed using the private key of the SCW. This generates a cryptographic signature that proves ownership of the wallet and ensures the integrity of the message.

- **Convert the signature to a Uint8Array**: The resulting signature is converted to a `Uint8Array` format, which is required by the XMTP SDK for compatibility and further processing.

The code snippets below are examples only and will need to be adapted based on your specific wallet provider and library.

:::code-group

```tsx [Browser]
import { IdentifierKind } from '@xmtp/browser-sdk';

export const createSCWSigner = (
  address: `0x${string}`,
  walletClient: WalletClient,
  chainId: bigint,
): Signer => {
  return {
    type: "SCW",
    getIdentifier: () => ({
      identifier: address.toLowerCase(),
      identifierKind: IdentifierKind.Ethereum,
    }),
    signMessage: async (message: string) => {
      const signature = await walletClient.signMessage({
        account: address,
        message,
      });
      return toBytes(signature);
    },
    getChainId: () => {
      return chainId;
    },
  };
```

```tsx [Node]
import type { Signer, Identifier, IdentifierKind } from '@xmtp/node-sdk';

const accountIdentifier: Identifier = {
  identifier: '0x...', // Ethereum address as the identifier
  identifierKind: IdentifierKind.Ethereum, // Specifies the identity type
};

const signer: Signer = {
  type: 'SCW',
  getIdentifier: () => accountIdentifier,
  signMessage: async (message: string): Uint8Array => {
    // typically, signing methods return a hex string
    // this string must be converted to bytes and returned in this function
  },
  getChainId: () => BigInt(8453), // Example: Base chain ID
};
```

```tsx [React Native]
// Example SCW Signer
export function convertSCWToSigner(scwAccount: SCWAccount): Signer {
  return {
    getIdentifier: async () =>
      new PublicIdentity(scwAccount.address, 'ETHEREUM'),
    getChainId: () => 8453, // https://chainlist.org/
    getBlockNumber: () => undefined, // Optional: will be computed at runtime
    signerType: () => 'SCW', // "SCW" indicates smart contract wallet account
    signMessage: async (message: string) => {
      const byteArray = await scwAccount.signMessage(message);
      const signature = ethers.utils.hexlify(byteArray); // Convert to hex string

      return {
        signature,
      };
    },
  };
}
```

```kotlin [Kotlin]
  class SCWallet : SigningKey {
    override val publicIdentity: PublicIdentity
      get() = PublicIdentity(
          IdentityKind.ETHEREUM,
          key.publicAddress
      )
    override val type: SignerType
      get() = SignerType.SCW

    override var chainId: Long? = 8453 // https://chainlist.org/
    override var blockNumber: Long? = null // Optional: will be computed at runtime

    override suspend fun sign(message: String): SignedData {
        val signature = key.sign(message = message)
        return SignedData(signature)
    }
}
```

```swift [Swift]
public struct SCWallet: SigningKey {
    public var identity: PublicIdentity {
      return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
    }

    public var chainId: Int64? {
        8453
    }

    public var blockNumber: Int64? {
        nil
    }

    public var type: SignerType { .SCW }

    public func sign(message: String) async throws -> SignedData {
        let signature = try await key.sign(message: message)
        return SignedData(signature.hexStringToByteArray )
    }
}
```

:::

:::tip[Want support for a different chain ID?]

Post your request to the [XMTP Improvement Forum](https://improve.xmtp.org/c/general/ideas/54). To look up chain IDs, see [ChainList](https://chainlist.org/). For an overview of the process for adding a non-EVM chain, see [Extend the XMTP identity model](/chat-apps/core-messaging/extend-id-model).

:::

## Retrieve your wallet's private key

:::danger[Security Warning]
Your private key and recovery phrase provide complete control over your wallet and all associated assets. Never share these with anyone, and store them securely. Exposing your private key can result in permanent loss of funds.
:::

MetaMask users can [export their account's private key](https://support.metamask.io/configure/accounts/how-to-export-an-accounts-private-key/) to use with other applications. If your wallet provides a recovery phrase based on [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) instead, you can convert it to a private key using a BIP39 mnemonic converter. Follow these steps to convert your recovery phrase using [Ian Coleman's BIP39 Converter](https://iancoleman.io/bip39/):

1. [Download the offline version](https://github.com/iancoleman/bip39/releases) of the converter to prevent potential security risks
2. Enter your recovery phrase in the "BIP39 Mnemonic" field
3. Set "Coin" to "ETH - Ethereum"
4. Under "Derivation Path", select "BIP44"
5. Find your wallet address in the "Derived Addresses" section
6. Copy the corresponding "Private Key"

## Common errors

### AssociationError.ChainIdMismatch

> Wrong chain id. Initially added with {0} but now signing from {1}

This error occurs when there's a mismatch between the chain ID used when initially creating an XMTP identity and the chain ID being used for subsequent signing operations. The chain ID verification prevents [cross-chain signature attacks on smart contract wallets](https://github.com/xmtp/libxmtp/pull/1180). Double-check your chain configuration to ensure the chain ID is properly set (when using SCWs) and consistent across your application.

### NotFound.InboxIdForAddress

> inbox id for address {0} not found

This typically happens when trying to create a DM with an address that hasn't been registered or associated with an XMTP inbox ID yet. You can only message wallet addresses that have been registered on the XMTP network. Registration occurs when a wallet is used with an XMTP-based chat app or one of our Client SDKs.

This error may also occur if your client is connected to a different XMTP network environment than the target address. For example, your client might be using the dev network while the target address was registered on production.

### SignatureError.Invalid

> Signature error Signature validation failed

This error occurs when attempting to connect a Smart Contract Wallet (SCW) using an incorrect chain. For example, selecting "Ethereum" as the chain for an SCW that is deployed on "Base".
