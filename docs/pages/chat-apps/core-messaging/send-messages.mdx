# Send messages

Once you have the group chat or DM conversation, you can send messages in the conversation.

:::code-group

```tsx [Browser]
// For a DM conversation
await dm.sendText('Hello world');

// OR for a group chat
await group.sendText('Hello everyone');
```

```tsx [Node]
// For a DM conversation
await dm.sendText('Hello world');

// OR for a group chat
await group.sendText('Hello everyone');
```

```tsx [React Native]
// For a DM conversation
const dm = await client.conversations.findOrCreateDm(recipientInboxId);
await dm.send('Hello world');

// OR for a group chat
const group = await client.conversations.newGroup([
  recipientInboxId1,
  recipientInboxId2,
]);
await group.send('Hello everyone');
```

```kotlin [Kotlin]
// For a DM conversation
val dm = client.conversations.findOrCreateDm(recipientInboxId)
dm.send(text = "Hello world")

// OR for a group chat
val group = client.conversations.newGroup(listOf(recipientInboxId1, recipientInboxId2))
group.send(text = "Hello everyone")
```

```swift [Swift]
// For a DM conversation
let dm = try await client.conversations.findOrCreateDm(with: recipientInboxId)
try await dm.send(content: "Hello world")

// OR for a group chat
let group = try await client.conversations.newGroup([recipientInboxId1, recipientInboxId2])
try await group.send(content: "Hello everyone")
```

:::

## Control message visibility and push notifications

Use `MessageVisibilityOptions` to control whether a message triggers push notifications. This is useful for messages that shouldn't interrupt the recipient, such as typing indicators or read receipts.

:::code-group

```kotlin [Kotlin]
// Send a message without triggering a push notification
val visibilityOptions = MessageVisibilityOptions(
    shouldPush = false
)

conversation.send(
    text = "Typing...",
    visibilityOptions = visibilityOptions
)

// Using with prepareMessage
conversation.prepareMessage(
    content = "Background update",
    visibilityOptions = MessageVisibilityOptions(shouldPush = false)
)
```

:::

| Option | Description |
| ------ | ----------- |
| `shouldPush` | When `false`, the message won't trigger push notifications on recipient devices. Defaults to `true`. |

## Optimistically send messages

When a user sends a message with XMTP, they might experience a slight delay between sending the message and seeing their sent message display in their app UI.

Typically, the slight delay is caused by the app needing to wait for the XMTP network to finish processing the message before the app can display the message in its UI.

Messaging without optimistic sending:

![Messaging without optimistic sending. Note the slight delay after clicking Send.](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/without-opt-sending.gif)

Note the slight delay after clicking **Send**.

Implement optimistic sending to be able to immediately display the sent message in the sender's UI while processing the message in the background. This provides the user with immediate feedback and enables them to continue messaging without waiting for their previous message to finish processing.

Messaging with optimistic sending:

![Messaging with optimistic sending. The message displays immediately for the sender, with a checkmark indicator displaying once the message has been successfully sent.](https://raw.githubusercontent.com/xmtp/docs-xmtp-org/main/docs/pages/img/with-opt-sending.gif)

The message displays immediately for the sender, with a checkmark indicator displaying once the message has been successfully sent.

### How it works

There are two steps to optimistically send a message:

1. Send the message to the local database so you can display it immediately in the sender's UI.
2. Publish the message to the XMTP network so it can be delivered to the recipient.

:::tip

If you want finer control over when the prepared message gets published, you can use the `noSend` parameter. To learn more, see [Control publication of optimistic messages](#control-publication-of-optimistic-messages).

:::

### 1. Optimistically send a message locally

Send the message to the local database. This ensures that the message will be there when you query for messages and can immediately display the message in the sender's UI.

:::code-group

```tsx [Browser]
// Optimistically send the message to the local database
await conversation.sendText('Hello world', true);
```

```tsx [Node]
// Optimistically send the message to the local database
await conversation.sendText('Hello world', true);
```

```tsx [React Native]
// Optimistically send the message to the local database
await conversation.prepareMessage('Hello world');

// For custom content types, specify the content type
const customContent = { foo: 'bar' };
const contentType = new ContentTypeId({
  authorityId: 'example',
  typeId: 'test',
  versionMajor: 1,
  versionMinor: 0,
});
await conversation.prepareMessage(customContent, contentType);
```

```kotlin [Kotlin]
// Optimistically send the message to the local database
conversation.prepareMessage("Hello world")

// For custom content types, specify the content type
val customContent = mapOf("foo" to "bar")
val contentType = ContentTypeId(
    authorityId = "example",
    typeId = "test",
    versionMajor = 1,
    versionMinor = 0
)
conversation.prepareMessage(customContent, contentType)
```

```swift [Swift]
// Optimistically send the message to the local database
try await conversation.prepareMessage("Hello world")

// For custom content types, specify the content type
let customContent = ["foo": "bar"]
let contentType = ContentTypeId(
    authorityId: "example",
    typeId: "test",
    versionMajor: 1,
    versionMinor: 0
)
try await conversation.prepareMessage(customContent, contentType: contentType)
```

:::

### 2. Publish an optimistically sent message to the network

After optimistically sending a message, use `publishMessages` to publish the message to the XMTP network so it can be delivered to recipients.

:::code-group

```tsx [Browser]
// Publish all pending optimistically sent messages to the network
// Call this only after using the optimistic parameter to send a message locally
async function sendMessageWithOptimisticUI(conversation, messageText) {
  try {
    // Add message to UI immediately (optimistic = true)
    await conversation.sendText(messageText, true);

    // Actually send the message to the network
    await conversation.publishMessages();
    return true;
  } catch (error) {
    console.error('Failed to send message:', error);
    return false;
  }
}
```

```tsx [Node]
// Publish all pending optimistically sent messages to the network
// Call this only after using the optimistic parameter to send a message locally
async function sendMessageWithOptimisticUI(conversation, messageText) {
  try {
    // Add message to UI immediately (optimistic = true)
    await conversation.sendText(messageText, true);

    // Actually send the message to the network
    await conversation.publishMessages();
    return true;
  } catch (error) {
    console.error('Failed to send message:', error);
    return false;
  }
}
```

```tsx [React Native]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
async function sendMessageWithOptimisticUI(
  conversation: Conversation,
  messageText: string
): Promise<boolean> {
  try {
    // Add message to UI immediately
    await conversation.prepareMessage(messageText);

    // Actually send the message to the network
    await conversation.publishPreparedMessages();
    return true;
  } catch (error) {
    console.error('Failed to send message:', error);
    return false;
  }
}
```

```kotlin [Kotlin]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
suspend fun sendMessageWithOptimisticUI(conversation: Conversation, messageText: String): Boolean {
    return try {
        // Add message to UI immediately
        conversation.prepareMessage(messageText)

        // Actually send the message to the network
        conversation.publishMessages()
        true
    } catch (error: Exception) {
        Log.e("XMTP", "Failed to send message: ${error.message}", error)
        false
    }
}
```

```swift [Swift]
// Publish all pending optimistically sent messages to the network
// Call this only after using prepareMessage to send a message locally
func sendMessageWithOptimisticUI(conversation: Conversation, messageText: String) async throws -> Bool {
    do {
        // Add message to UI immediately
        try await conversation.prepareMessage(messageText)

        // Actually send the message to the network
        try await conversation.publishMessages()
        return true
    } catch {
        print("Failed to send message: \(error)")
        return false
    }
}
```

:::

### Key UX considerations for optimistically sent messages

- After optimistically sending a message, show the user an indicator that the message is still being processed. After successfully sending the message, show the user a success indicator.
  - An optimistically sent message initially has an `unpublished` status. Once published to the network, it has a `published` status. You can use this status to determine which indicator to display in the UI.
- If an optimistically sent message fails to send it will have a `failed` status. In this case, be sure to give the user an option to retry sending the message or cancel sending. Use a try/catch block to intercept errors and allow the user to retry or cancel.

### Control publication of optimistic messages

By default, `publishMessages()` publishes all prepared messages. For more control, use the `noSend` parameter when preparing a message. The message won't be published until you explicitly call `publishMessage(messageId)`.

This is useful when sending [remote attachments](/chat-apps/content-types/attachments). You can validate that the attachment upload succeeded before publishing. If the upload failed, you can choose to delete the local prepared message instead of publishing it.

:::code-group

```kotlin [Kotlin]
// Prepare message without auto-publishing
val messageId = conversation.prepareMessage(content = content, noSend = true)

// Publish the specific message when ready
conversation.publishMessage(messageId)

// Or delete it locally if needed
conversation.deleteMessageLocally(messageId)
```

```swift [Swift]
// Prepare message without auto-publishing
let messageId = try await conversation.prepareMessage(content: content, noSend: true)

// Publish the specific message when ready
try await conversation.publishMessage(messageId: messageId)

// Or delete it locally if needed
try await conversation.deleteMessageLocally(messageId: messageId)
```

:::
