# Message types with XMTP

This document covers **protocol-level message types** (key package, welcome, commit, etc.) that are internal to the XMTP protocol's [Messaging Layer Security](https://www.rfc-editor.org/rfc/rfc9420.html)(MLS) implementation. This information is primarily useful for:

- Developers contributing to the XMTP protocol itself
- Understanding XMTP internals and debugging
- Reading XMTP Improvement Proposals (XIPs)

The protocol-level message types described here are handled automatically by XMTP SDKs and rarely need direct interaction from app developers.

For **app development**, you'll typically work with [content types](/inboxes/content-types/content-types) instead. Content types define how your app's messages are structured and encoded (text, attachments, reactions, etc.) and are what you'll use in your day-to-day development.

## Overview

XMTP uses several message types to establish and maintain secure communication:

- **Key package** - Cryptographic credentials for user installations
- **Welcome** - Bootstraps new members into existing groups
- **Commit** - Updates group state, membership, and permissions
- **Identity update** - Verifies and authenticates user identities
- **Chat** - Day-to-day communication between users

These message types work together to enable secure group communication with [forward secrecy and post-compromise security](/protocol/security).

**Note**: In the MLS context, "group" refers to any collection of clients that share cryptographic state, which includes both direct message (1:1) or group chat conversations.

## Key package message

A key package is a cryptographic credential bundle that provides public information about a user's installation. XMTP SDKs create and upload fresh key packages behind the scenes when an installation is initialized or rotated.

Think of a key package as a calling card for an installation that says: here's how to encrypt to me, here's how long this card is valid, and it's signed so you can trust it.

A key package contains:
- Public key for encrypting welcome messages
- Signature key for authentication
- Capabilities (supported protocol version, cipher suites, lifetime, etc.)
- Credential for identity verification
- Content of the leaf node representing this client

Group members cache key packages to authenticate future handshakes and welcome material, enabling asynchronous addition of clients to groups.

When an app inspects a group member, the SDK provides a `PublicIdentity` object containing the decoded fields, allowing apps to display identity information or check if the key package has expired.

## Welcome message

A welcome message bootstraps a new member into an existing group. The welcome is dependent on the newcomer's [key package](#key-package-message) and provides the new member with the current state of the group after application of a [commit message](#commit-message).

A welcome message contains:
- Group context information
- Encrypted group secrets
- Tree structure for the group
- Confirmation tags for epoch verification

If decryption fails due to an outdated or missing key package, the SDK automatically fetches the latest package and retries.

## Commit message

While technically a single message type, commit messages serve many different purposes, including implementing the group evolution mechanism.

Understanding commit messages is especially helpful when debugging and understanding your app's user experience. For example:

- Different commit types help explain why certain messages appear in logs
- Some commits happen invisibly, while others are tied to user actions

### User-initiated commits

- **Add member commits**: When a user explicitly adds someone to a group
- **Remove member commits**: When a user removes someone from a group  
- **Update metadata commits**: When a user changes group name, description, or permissions
- **Update permissions commits**: When a user modifies group permission settings

These commit messages work to update a group's state, permissions, and membership. Every commit initiates a new epoch, instructing group members to update their representation of the group's cryptographic state by applying proposals and advancing the key schedule. This ensures all members converge on the same group state.

### System-initiated commits

- **Key update commits**: Automatically generated when a new member joins before sending their first message
- **Missing member commits**: Triggered when the system detects someone is missing from the group
- **Scheduled commits**: Periodic commits for security maintenance

### MLS protocol commits

- **Update path commits**: Generated by the MLS protocol for key rotation and security
- **External sender commits**: For handling external participants

For more information about MLS commits, see [RFC 9420 Section 12.4](https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4).

## Identity update message

An identity update message verifies and authenticates a user identity across the network. It is signed by the user's identity and verifiable by peers.

Identity update messages enable group members to rotate their signature or HPKE keys while preserving group continuity and authenticity.

They handle:
- Linking an installation to an XMTP inbox
- Key rotation and revocation
- Linking multiple devices (though [history sync](/inboxes/history-sync) is used to synchronize data between those devices)

Identity update messages are stored permanently to ensure continuity of trust and identity verification.

## Chat message

A chat message represents the day-to-day communication between users, including payloads like text, attachments, reactions, onchain transactions, etc.

Chat messages are:
- Encrypted using the group's shared secrets
- Authenticated with sender signatures
- Encoded using XMTP content types
- Sent on the `groupMessage` topic
