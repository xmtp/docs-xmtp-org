# Build a chat inbox

This guide walks you through the steps to build a chat inbox using the XMTP SDK. 

:::tip[Learn to build with XMTP.chat]

Learn to build a chat inbox with the help of [XMTP.chat](https://xmtp.chat/), an interactive developer tool and chat app.

:::

## Pick your SDK

### Web

- [Browser SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/browser-sdk)

- [Node SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/node-sdk)

### Mobile

- [React Native SDK](https://github.com/xmtp/xmtp-react-native) 

- [Kotlin SDK](https://github.com/xmtp/xmtp-android)

- [Swift SDK](https://github.com/xmtp/xmtp-ios)

## Create or build a client

### Create an account signer 

This code defines two functions that convert different types of Ethereum accountsâ€”Externally Owned Accounts (EOAs) and Smart Contract Wallets (SCWs)â€”into a unified `Signer` interface. This ensures that both account types conform to a common interface for message signing and deriving shared secrets as per MLS (Message Layer Security) requirements. `SigningKey` now supports only one sign method: `sign(signatureText: String): SignedData`.

- For an EOA, the `convertEOAToSigner` function creates a signer that can get the account identity and sign messages and has placeholder methods for chain ID and block number. 

  :::code-group 

  ```tsx [Browser] 
  import type { Signer } from "@xmtp/browser-sdk"; 

  const accountIdentity = { 
    kind: "ETHEREUM", // Specifies the identity type 
    identifier: "0x...", // Ethereum address as the identifier 
  }; 

  const signer: Signer = { 
    getIdentity: () => accountIdentity, 
    signMessage: async (message) => { 
      // return value from a signing method here 
    }, 
  }; 
  ```

  ```tsx [Node] 
  import type { Signer } from "@xmtp/node-sdk"; 

  const accountIdentity = { 
    kind: "ETHEREUM", // Specifies the identity type 
    identifier: "0x...", // Ethereum address as the identifier 
  }; 

  const signer: Signer = { 
    getIdentity: () => accountIdentity, 
    signMessage: async (message) => { 
      // return value from a signing method here 
    }, 
  }; 
  ```

  ```tsx [React Native] 
  // Example EOA Signer 
  export function convertEOAToSigner(eoaAccount: EOAAccount): Signer {
    return {
      getIdentifier: async () => new PublicIdentity(eoaAccount.address, 'ETHEREUM'),
      getChainId: () => undefined, // Provide a chain ID if available or return undefined
      getBlockNumber: () => undefined, // Block number is typically not available in Wallet, return undefined
      signerType: () => 'EOA', // "EOA" indicates an externally owned account
      signMessage: async (message: string) => {
        const signature = await eoaAccount.signMessage(message)

        return {
          signature,
        }
      },
    }
  }
  ```

  ```kotlin [Kotlin] 
  class EOAWallet : SigningKey {
      override val publicIdentity: PublicIdentity
        get() = PublicIdentity(
            IdentityKind.ETHEREUM,
            key.publicAddress
        )
      override val type: SignerType
        get() = SignerType.EOA
      
      override suspend fun sign(message: String): SignedData {
          val signature = key.sign(message = message)
          return SignedData(signature)
      }
  }
  ```

  ```swift [Swift] 
  public struct EOAWallet: SigningKey { 
      public var identity: PublicIdentity {
        return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
      }

      public var type: SignerType { .EOA }

      public func sign(message: String) async throws -> SignedData { 
          let signature = try await key.sign(message: message) 
          return SignedData(signature)
      } 
  }
  ```

  :::

- For an SCW, the `convertSCWToSigner` function similarly creates a signer but includes a specific implementation for chain ID and an optional block number computation.

  :::code-group 

  ```tsx [Browser] 
  import type { Signer } from "@xmtp/browser-sdk"; 

  const accountIdentity = { 
    kind: "ETHEREUM", // Specifies the identity type 
    identifier: "0x...", // Smart Contract Wallet address 
  }; 

  const signer: Signer = { 
    getIdentity: () => accountIdentity, 
    signMessage: async (message) => { 
      // return value from a signing method here 
    }, 
    // These methods are required for smart contract wallets 
    getBlockNumber: () => undefined, // Optional block number 
    getChainId: () => BigInt(8453), // Example: Base chain ID 
  };
  ```

  ```tsx [Node]
  import type { Signer } from "@xmtp/node-sdk";

  const accountIdentity = { 
    kind: "ETHEREUM", // Specifies the identity type 
    identifier: "0x...", // Smart Contract Wallet address 
  };

  const signer: Signer = { 
    getIdentity: () => accountIdentity, 
    signMessage: async (message) => { 
      // return value from a signing method here 
    },
    // These methods are required for smart contract wallets 
    getBlockNumber: () => undefined, // Optional block number 
    getChainId: () => BigInt(8453), // Example: Base chain ID 
  }; 
  ```

  ```tsx [React Native] 
  // Example SCW Signer 
  export function convertSCWToSigner(scwAccount: SCWAccount): Signer {
    return {
      getIdentifier: async () => new PublicIdentity(scwAccount.address, 'ETHEREUM'),
      getChainId: () => 8453, // https://chainlist.org/ 
      getBlockNumber: () => undefined, // Optional: will be computed at runtime
      signerType: () => 'SCW', // "SCW" indicates an externally owned account
      signMessage: async (message: string) => {
        const byteArray = await scwAccount.signMessage(message); 
        const signature = ethers.utils.hexlify(byteArray); // Convert to hex string 
        
        return {
          signature,
        }
      },
    }
  }
  ```

  ```kotlin [Kotlin] 
    class SCWallet : SigningKey {
      override val publicIdentity: PublicIdentity
        get() = PublicIdentity(
            IdentityKind.ETHEREUM,
            key.publicAddress
        )
      override val type: SignerType
        get() = SignerType.SCW

      override var chainId: Long? = 8453 // https://chainlist.org/
      override var blockNumber: Long? = null // Optional: will be computed at runtime
      
      override suspend fun sign(message: String): SignedData {
          val signature = key.sign(message = message)
          return SignedData(signature)
      }
  }
  ```

  ```swift [Swift] 
  public struct SCWallet: SigningKey { 
      public var identity: PublicIdentity {
        return PublicIdentity(kind: .ethereum, identifier: key.publicAddress)
      }
      
      public var chainId: Int64? { 
          8453 
      } 

      public var blockNumber: Int64? { 
          nil 
      } 

      public var type: SignerType { .SCW }

      public func sign(message: String) async throws -> SignedData { 
          let signature = try await key.sign(message: message)
          return SignedData(signature.hexStringToByteArray )
      } 
  } 
  ```

  :::

### Create an XMTP client

Create an XMTP MLS client that can use the signing capabilities provided by the `SigningKey` parameter. This `SigningKey` links the client to the appropriate EOA or SCW.

#### ðŸŽ¥ walkthrough: Create a client

This video provides a walkthrough of creating a client, covering the key ideas discussed in this doc. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/kdUP1ZaauNI?si=ETuEbvwbKx4bjtwc" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

#### Create a client

:::code-group

```tsx [Browser]
import { Client, type Signer } from "@xmtp/browser-sdk";

const accountIdentity = {
  kind: "ETHEREUM", // Specifies the identity type
  identifier: "0x...", // Ethereum address as the identifier
};

const signer: Signer = {
  getIdentity: () => accountIdentity,
  signMessage: async (message) => {
    // return value from a signing method here
  },
};

// This value should be generated once per installation and stored securely
const encryptionKey = window.crypto.getRandomValues(new Uint8Array(32));

const client = await Client.create(
  signer,
  encryptionKey,
  options /* optional */
);
```

```tsx [Node]
import { Client, type Signer } from "@xmtp/node-sdk";
import { getRandomValues } from "node:crypto";

const accountIdentity = {
  kind: "ETHEREUM", // Specifies the identity type
  identifier: "0x...", // Ethereum address as the identifier
};

const signer: Signer = {
  getIdentity: () => accountIdentity,
  signMessage: async (message) => {
    // return value from a signing method here
  },
};

// This value should be generated once per installation and stored securely
const encryptionKey = getRandomValues(new Uint8Array(32));

const client = await Client.create(
  signer,
  encryptionKey,
  options /* optional */
);
```

```tsx [React Native]
Client.create(SigningKey, {
  env: "production", // 'local' | 'dev' | 'production'
  dbEncryptionKey: keyBytes, // 32 bytes
});
```

```kotlin [Kotlin]
val options = ClientOptions(
    ClientOptions.Api(XMTPEnvironment.PRODUCTION, true),
    appContext = ApplicationContext(),
    dbEncryptionKey = keyBytes // 32 bytes
)
val client = Client().create(
        account = SigningKey,
        options = options
    )
```

```swift [Swift]
let options = ClientOptions.init(
  api: .init(env: .production, isSecure: true),
  dbEncryptionKey: keyBytes // 32 bytes
)
let client = try await Client.create(
  account: SigningKey,
  options: options
)
```

:::

When an app first callsÂ `Client.create()`, a client creates a local database to manage messaging between the app and the network. In subsequent calls, it loads the existing database. The database is encrypted using the keys from theÂ `Signer`Â interface.

To learn more about database operations, see theÂ [XMTP MLS protocol spec](https://github.com/xmtp/libxmtp/blob/main/xmtp_mls/README.md).

##### Configure an XMTP client

You can configure an XMTP client with these parameters of `Client.create`:

| Parameter       | Default                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| env             | `DEV`                                           | Connect to the specified XMTP network environment. Valid values include `DEV`, `PRODUCTION`, or `LOCAL`. For important details about working with these environments, see [XMTP DEV, PRODUCTION, and LOCAL network environments](#xmtp-dev-production-and-local-network-environments). |
| apiURL             | undefined                                           | Manually specify an API URL to use. If specified, value of `env` will be ignored. |
| appContext (Android-only)     | null                                      | Required. The app context used to create and access the local database. |
| dbEncryptionKey | null                                      | Required. A 32-byte `ByteArray` used to encrypt the local database.    |
| dbDirectory | xmtp_db                                      | Optional. Specify a database directory. If no directory is specified, the value is set to `xmtp_db` by default. |
| historySyncUrl  | `https://message-history.dev.ephemera.network/` | The history sync URL used to specify where history can be synced from other devices on the network. For production apps, use `https://message-history.production.ephemera.network`. |

#### XMTP DEV, PRODUCTION, and LOCAL network environments

XMTP provides `DEV`, `PRODUCTION`, and `LOCAL` network environments to support the development phases of your project.

The `PRODUCTION` and `DEV` networks are completely separate and not interchangeable.

For example, an XMTP identity on the `DEV` network is completely distinct from the XMTP identity on the `PRODUCTION` network, as are the messages associated with these identities. In addition, XMTP identities and messages created on the `DEV` network can't be accessed from or moved to the `PRODUCTION` network, and vice versa.

:::tip
When you [create a client](/inboxes/build-inbox/#create-an-xmtp-client), it connects to the XMTP `DEV` environment by default. Use the `env` parameter to explicitly set your client's network environment.
:::

Here are some best practices for when to use each environment:

- `DEV`: Use to have a client communicate with the `DEV` network. As a best practice, set `env` to `DEV` while developing and testing your app. Follow this best practice to isolate test messages to `DEV` inboxes.

- `PRODUCTION`: Use to have a client communicate with the `PRODUCTION` network. As a best practice, set `env` to `PRODUCTION` when your app is serving real users. Follow this best practice to isolate messages between real-world users to `PRODUCTION` inboxes.

- `LOCAL`: Use to have a client communicate with an XMTP node you are running locally. For example, an XMTP node developer can set `env` to `LOCAL` to generate client traffic to test a node running locally.

The `PRODUCTION` network is configured to store messages indefinitely. XMTP may occasionally delete messages and keys from the `DEV` network, and will provide advance notice in the [XMTP Community Forms](https://community.xmtp.org/).

### Build an existing client

Build, or resume, an existing client that's logged in and has an existing local database.

:::code-group

```tsx [React Native]
Client.build(identity, {
  env: "production", // 'local' | 'dev' | 'production'
  dbEncryptionKey: keyBytes, // 32 bytes
});
```

```kotlin [Kotlin]
val options = ClientOptions(
    ClientOptions.Api(XMTPEnvironment.PRODUCTION, true),
    appContext = ApplicationContext(),
    dbEncryptionKey = keyBytes
)
val client = Client().build(
        identity = identity,
        options = options
    )
```

```swift [Swift]
let options = ClientOptions.init(
  api: .init(env: .production, isSecure: true),
  dbEncryptionKey: keyBytes // 32 bytes
)
let client = try await Client.build(
  identity: identity,
  options: options
)
```

:::

### Log out a client

When you log a user out of your app, you can give them the option to delete their local database.

:::tip[Important]
If the user chooses to delete their local database, they will have to create a new installation the next time they log in and will lose all of their messages.
:::

:::code-group

```tsx [React Native]
  await client.deleteLocalDatabase()
  await Client.dropClient(client.installationId)
```

```kotlin [Kotlin]
  client.deleteLocalDatabase()
```

```swift [Swift]
  try await client.deleteLocalDatabase()
```

:::

## Check if an identity is reachable

The first step to creating a conversation is to verify that participantsâ€™ identities are reachable on XMTP. The `canMessage` method checks each identity's compatibility, returning a response indicating whether each identity can receive messages.

Once you have the verified identities, you can create a new conversation, whether it's a group chat or direct message (DM).

:::code-group

```js [Browser]
import { Client } from "@xmtp/browser-sdk";

// response is a Map of string (identity) => boolean (is reachable)
const response = await Client.canMessage([bo.identity, caro.identity]);
```

```js [Node]
import { Client } from "@xmtp/node-sdk";

// response is a Map of string (identity) => boolean (is reachable)
const response = await Client.canMessage([bo.identity, caro.identity]);
```

```tsx [React Native]
// Request
const canMessage = await client.canMessage([
  boIdentity,
  v2OnlyIdentity,
  badIdentity,
])

// Response
{
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
}
```

```kotlin [Kotlin]
// Request
val boIdentity = Identity(ETHEREUM, '0xboAddress')
val v2Identity = Identity(ETHEREUM, '0xV2OnlyAddress')
val badIdentity = Identity(ETHEREUM, '0xBadAddress')

val canMessage = client.canMessage(listOf(boIdentity, v2Identity, badIdentity))

// Response
[
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
]
```

```swift [Swift]
// Request
let canMessage = try await client.canMessage([boIdentity, v2OnlyIdentity, badIdentity])

// Response
[
  "0xboAddress": true,
  "0xV2OnlyAddress": false,
  "0xBadAddress": false,
]
```

:::

:::tip
Regarding how to handle identities that arenâ€™t reachable, the XMTP V3.0.0 release notes will outline the next steps to ensure smooth onboarding for all participants.
:::

## Create a conversation

### Create a new group chat

Once you have the verified identities, create a new group chat:

:::code-group

```js [Browser]
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);
```

```js [Node]
const group = await client.conversations.newGroup(
  [bo.inboxId, caro.inboxId],
  createGroupOptions /* optional */
);
```

```tsx [React Native]
// New Group
const group = await alix.conversations.newGroup([bo.inboxId, caro.inboxId]);

// New Group with Metadata
const group = await alix.conversations.newGroup([bo.inboxId, caro.inboxId], {
  name: "The Group Name",
  imageUrl: "www.groupImage.com",
  description: "The description of the group",
  permissionLevel: "admin_only", // 'all_members' | 'admin_only'
});
```

```kotlin [Kotlin]
// New Group
val group = alix.conversations.newGroup(listOf(bo.inboxId, caro.inboxId))

// New Group with Metadata
val group = alix.conversations.newGroup(listOf(bo.inboxId, caro.inboxId),
  permissionLevel = GroupPermissionPreconfiguration.ALL_MEMBERS, // ALL_MEMBERS | ADMIN_ONLY
  name = "The Group Name",
  imageUrl = "www.groupImage.com",
  description = "The description of the group",
)
```

```swift [Swift]
// New Group
let group = try await alix.conversations.newGroup([bo.inboxId, caro.inboxId])

// New Group with Metadata
let group = try await alix.conversations.newGroup([bo.inboxId, caro.inboxId],
  permissionLevel: .admin_only, // .all_members | .admin_only
  name: "The Group Name",
  imageUrl: "www.groupImage.com",
  description: "The description of the group",
)
```

:::

### Create a new DM

Once you have the verified identity, get its inbox ID and create a new DM:

:::code-group

```js [Browser]
const group = await client.conversations.newDm(bo.inboxId);
```

```js [Node]
const group = await client.conversations.newDm(bo.inboxId);
```

```tsx [React Native]
const dm = await alix.conversations.findOrCreateDm(bo.inboxId);
```

```kotlin [Kotlin]
val dm = alix.conversations.findOrCreateDm(bo.inboxId)

// calls the above function under the hood but returns a type conversation instead of a dm
val conversation = client.conversations.newConversation(inboxId)
```

```swift [Swift]
let dm = try await alix.conversations.findOrCreateDm(with: bo.inboxId)

// calls the above function under the hood but returns a type conversation instead of a dm
let conversation = try await client.conversations.newConversation(inboxId)
```

:::

## Send a message

Once you have the group chat or DM conversation, send a message in the conversation.

:::code-group

```tsx [React Native]
// For a DM conversation
const dm = await client.conversations.findOrCreateDm(recipientInboxId);
await dm.send("Hello world");

// OR for a group chat
const group = await client.conversations.newGroup([recipientInboxId1, recipientInboxId2]);
await group.send("Hello everyone");
```

```kotlin [Kotlin]
// For a DM conversation
val dm = client.conversations.findOrCreateDm(recipientInboxId)
dm.send(text = "Hello world")

// OR for a group chat
val group = client.conversations.newGroup(listOf(recipientInboxId1, recipientInboxId2))
group.send(text = "Hello everyone")
```

```swift [Swift]
// For a DM conversation
let dm = try await client.conversations.findOrCreateDm(with: recipientInboxId)
try await dm.send(content: "Hello world")

// OR for a group chat
let group = try await client.conversations.newGroup([recipientInboxId1, recipientInboxId2])
try await group.send(content: "Hello everyone")
```

:::

## List conversations and messages

### List new group chats or DMs

Get any new group chats or DMs from the network:

:::code-group

```js [Browser]
await client.conversations.sync();
```

```js [Node]
await client.conversations.sync();
```

```tsx [React Native]
await client.conversations.sync();
```

```kotlin [Kotlin]
client.conversations.sync()
```

```swift [Swift]
try await client.conversations.sync()
```

:::

### Sync

Sync all new messages and conversations from the network.

:::tip[Note]
Syncing does not refetch existing messages and conversations. It also does not fetch messages for group chats you are no longer a part of.
:::

#### ðŸŽ¥ walkthrough: Syncing

This video provides a walkthrough of syncing, covering the key ideas discussed in this doc. After watching, feel free to continue reading for more details.

<iframe width="560" height="315" src="https://www.youtube.com/embed/jl7P0onApxw?si=YNafIHebx9Kxycos" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>

#### Sync

:::code-group

```js [Browser]
await client.conversations.syncAll();
```

```js [Node]
await client.conversations.syncAll();
```

```tsx [React Native]
await client.conversations.syncAllConversations();
```

```kotlin [Kotlin]
client.conversations.syncAllConversations()
```

```swift [Swift]
try await client.conversations.syncAllConversations()
```

:::

#### Handle unsupported content types

As more [custom](/inboxes/content-types/content-types#create-a-custom-content-type) and [standards-track](/inboxes/content-types/content-types#standards-track-content-types) content types are introduced into the XMTP ecosystem, your app may encounter content types it does not support. This situation, if not handled properly, could lead to app crashes.

Each message is accompanied by a `fallback` property, which offers a descriptive string representing the content type's expected value. It's important to note that fallbacks are immutable and are predefined in the content type specification. In instances where `fallback` is `undefined`, such as read receipts, it indicates that the content is not intended to be rendered. If you're venturing into creating custom content types, you're provided with the flexibility to specify a custom fallback string. For a deeper dive into this, see [Build custom content types](/inboxes/content-types/custom).

:::code-group

```js [Browser]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```js [Node]
const codec = client.codecFor(content.contentType);
if (!codec) {
  /*Not supported content type*/
  if (message.fallback !== undefined) {
    return message.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```jsx [React Native]
//contentTypeID has the following structure `${contentType.authorityId}/${contentType.typeId}:${contentType.versionMajor}.${contentType.versionMinor}`;
const isRegistered = message.contentTypeID in client.codecRegistry;
if (!isRegistered) {
  // Not supported content type
  if (message?.fallback != null) {
    return message?.fallback;
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```kotlin [Kotlin]
val codec = client.codecRegistry.find(options?.contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

```swift [Swift]
let codec = client.codecRegistry.find(for: contentType)
if (!codec) {
  /*Not supported content type*/
  if (message.fallback != null) {
    return message.fallback
  }
  // Handle other types like ReadReceipts which are not meant to be displayed
}
```

:::

### List existing group chats or DMs

Get a list of existing group chats or DMs in the local database. By default, the conversations are listed in descending order by their `lastMessage` created at value. If a conversation does not contain any messages, the conversation is ordered by its `createdAt` value.

:::code-group

```js [Browser]
const allConversations = await client.conversations.list();
const allGroups = await client.conversations.listGroups();
const allDms = await client.conversations.listDms();
```

```js [Node]
const allConversations = await client.conversations.list();
const allGroups = await client.conversations.listGroups();
const allDms = await client.conversations.listDms();
```

```tsx [React Native]
// List Conversation items
await alix.conversations.list();

// List Conversation items but only return specified fields
await alix.conversations.list(
  {
    members: false,
    consentState: false,
    description: false,
    creatorInboxId: false,
    addedByInboxId: false,
    isActive: false,
    lastMessage: true,
  },
);
```

```kotlin [Kotlin]
// List conversations (both groups and dms)
val conversations = alix.conversations.list()
val orderFilteredConversations = client.conversations.list(consentState: ALLOWED)

// List just dms
val conversations = alix.conversations.listDms()
val orderFilteredConversations = client.conversations.listDms(consentState: ALLOWED)

//List just groups
val conversations = alix.conversations.listGroups()
val orderFilteredConversations = client.conversations.listGroups(consentState: ALLOWED)

```

```swift [Swift]
// List conversations (both groups and dms)
let conversations = try await alix.conversations.list()
let orderFilteredConversations = try await client.conversations.list(consentState: .allowed)

// List just dms
let conversations = try await alix.conversations.listDms()
let orderFilteredConversations = try await client.conversations.listDms(consentState: .allowed)

//List just groups
let conversations = try await alix.conversations.listGroups()
let orderFilteredConversations = try await client.conversations.listGroups(consentState: .allowed)
```

:::

## Stream conversations and messages

### Stream all group chats and DMs

Listens to the network for new group chats and DMs. Whenever a new conversation starts, it triggers the provided callback function with a [`ConversationContainer` object](#conversationcontainer-interface). This allows the client to immediately respond to any new group chats or DMs initiated by other users.

:::code-group

```js [Node]
const stream = await client.conversations.stream();
// to stream only groups, use `client.conversations.streamGroups()`
// to stream only dms, use `client.conversations.streamDms()`

try {
  for await (const conversation of stream) {
    // Received a conversation
  }
} catch (error) {
  // log any stream errors
  console.error(error);
}
```

```tsx [React Native]
await alix.conversations.stream(async (conversation: Conversation<any>) => {
  // Received a conversation
});
```

```kotlin [Kotlin]
alix.conversations.stream(type: /* OPTIONAL DMS, GROUPS, ALL */).collect {
  // Received a conversation
}
```

```swift [Swift]
for await convo in try await alix.conversations.stream(type: /* OPTIONAL .dms, .groups, .all */) {
  // Received a conversation
}
```

:::

### Stream all group chat and DM messages

Listens to the network for new messages within all active group chats and DMs. Whenever a new message is sent to any of these conversations, the callback is triggered with a `DecodedMessage` object. This keeps the inbox up to date by streaming in messages as they arrive.

:::warning[Important]

The stream is infinite. Therefore, any looping construct used with the stream won't terminate unless you explicitly initiate the termination. You can initiate the termination by breaking the loop or by making an external call to `return`.

:::

:::code-group

```js [Node]
// stream all messages from all conversations
const stream = await client.conversations.streamAllMessages();

// stream only group messages
const stream = await client.conversations.streamAllGroupMessages();

// stream only dm messages
const stream = await client.conversations.streamAllDmMessages();

try {
  for await (const message of stream) {
    // Received a message
  }
} catch (error) {
  // log any stream errors
  console.error(error);
}
```

```tsx [React Native]
await alix.conversations.streamAllMessages(
  async (message: DecodedMessage<any>) => {
    // Received a message
  }
);
```

```kotlin [Kotlin]
alix.conversations.streamAllMessages(type: /* OPTIONAL DMS, GROUPS, ALL */).collect {
  // Received a message
}
```

```swift [Swift]
for await message in try await alix.conversations.streamAllMessages(type: /* OPTIONAL .dms, .groups, .all */) {
  // Received a message
}
```

:::

## Helper methods and class interfaces

### Conversation helper methods

Use these helper methods to quickly locate and access specific conversationsâ€”whether by conversation ID, topic, group ID, or DM identityâ€”returning the appropriate ConversationContainer, group, or DM object.

:::code-group

```js [Browser]
// get a conversation by its ID
const conversationById = await client.conversations.getConversationById(
  conversationId
);

// get a message by its ID
const messageById = await client.conversations.getMessageById(messageId);

// get a 1:1 conversation by a peer's inbox ID
const dmByInboxId = await client.conversations.getDmByInboxId(peerInboxId);
```

```js [Node]
// get a conversation by its ID
const conversationById = await client.conversations.getConversationById(
  conversationId
);

// get a message by its ID
const messageById = await client.conversations.getMessageById(messageId);

// get a 1:1 conversation by a peer's inbox ID
const dmByInboxId = await client.conversations.getDmByInboxId(peerInboxId);
```

```tsx [React Native]
// Returns a ConversationContainer
await alix.conversations.findConversation(conversation.id);
await alix.conversations.findConversationByTopic(conversation.topic);
// Returns a Group
await alix.conversations.findGroup(group.id);
// Returns a DM
await alix.conversations.findDmByIdentity(bo.identity);
```

```kotlin [Kotlin]
// Returns a ConversationContainer
alix.conversations.findConversation(conversation.id)
alix.conversations.findConversationByTopic(conversation.topic)
// Returns a Group
alix.conversations.findGroup(group.id)
// Returns a DM
alix.conversations.findDmbyInboxId(bo.inboxId);
```

```swift [Swift]
// Returns a ConversationContainer
try alix.conversations.findConversation(conversation.id)
try alix.conversations.findConversationByTopic(conversation.topic)
// Returns a Group
try alix.conversations.findGroup(group.id)
// Returns a DM
try alix.conversations. findDmbyInboxId(bo.inboxId)
```

:::

### Conversation union type

Serves as a unified structure for managing both group chats and DMs. It provides a consistent set of properties and methods to seamlessly handle various conversation types.

- React Native: [Conversation.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Conversation.ts)

### Group class

Represents a group chat conversation, providing methods to manage group-specific functionalities such as sending messages, synchronizing state, and handling group membership.

- React Native: [Group.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Group.ts)

### Dm class

Represents a DM conversation, providing methods to manage one-on-one communications, such as sending messages, synchronizing state, and handling message streams.

- React Native: [Dm.ts](https://github.com/xmtp/xmtp-react-native/blob/main/src/lib/Dm.ts)
