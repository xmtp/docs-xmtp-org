import Mermaid from '../../components/Mermaid'

# Run an XMTP Gateway Service

A XMTP Gateway Service is a proxy that pays for and forwards messages to the XMTP Network on behalf of your users. Think of it as your app's payment gateway for messaging.

Behind the scenes, your XMTP Gateway Service handles all the complexity of blockchain payments so your users (and you) don't have to think about it.

You host your XMTP Gateway Service on your infrastructure because it contains sensitive information such as your Payer Private Key.

XMTP provides a standard implementation of an XMTP Gateway Service that you can extend to meet your unique needs. Once your XMTP Gateway Service is deployed, you will need to include the `payer_service_address` when creating any XMTP client in your app or agent.

## Get started

Every app needs a XMTP Gateway Service.

### For Node.js apps

The XMTP Gateway Service is built into the XMTP Node SDK. No need to run a separate XMTP Gateway Service.

```jsx
// Automatic gateway included, no separate service needed
const client = await Client.create(wallet, {
  env: 'mainnet'
})
```

### For browser and mobile client apps

You must run the XMTP Gateway Service written in Go. Choose the option that works best for you:

**Option 1: Basic Docker image** (No Go knowledge required)

- XMTP provides a Docker image that works out of the box
- Authorizes all requests (add authentication for production)
- Suitable for testing

**Option 2: Custom implementation** (Go knowledge required)

- Start with XMTP's Go implementation
- Add your own authentication logic
- Implement custom rate limiting
- Required for apps with authentication needs

## A minimal example

This is all the code you need to create the most bare bones XMTP Gateway Service. The service will configure itself from command line flags or environment variables, and begin receiving traffic on ports `5050` and `5055`.

This minimal example will authorize every request it receives with no limits. In a real production app, you will want to make sure that you only approve requests from your own users.

```go
package main

import (
	"context"
	"log"

	"github.com/xmtp/xmtpd/pkg/payer"
)

func main() {
	payerService, err := payer.NewPayerServiceBuilder(payer.MustLoadConfig()).
		Build()
	if err != nil {
		log.Fatalf("Failed to build XMTP Gateway Service: %v", err)
	}

	err = payerService.Serve(context.Background())
	if err != nil {
		log.Fatalf("Failed to serve XMTP Gateway Service: %v", err)
	}
}
```

## Configure your XMTP Gateway Service

You can provide the configuration options for your XMTP Gateway Service either directly in your code, via command line flag, or through environment variables.

| Name                     | Required | Command line flag                      | Environment variable             | Info                                                                                               |
| ------------------------ | -------- | -------------------------------------- | -------------------------------- | -------------------------------------------------------------------------------------------------- |
| Payer Private Key        | `true`   | `--payer.private-key`                  | `XMTPD_PAYER_PRIVATE_KEY`        | The `secp256k1` private key of the Ethereum Account you have already funded in the Funding Portal. Used to sign transactions and pay fees from your payer allowance in the PayerRegistry smart contract.    |
| Appchain WSS URL        | `true`   | `--contracts.app-chain.wss-url`        | `XMTPD_APP_CHAIN_WSS_URL`        | The websocket URL of your Blockchain RPC provider's endpoint for XMTP Chain                        |
| Settlement Chain WSS URL | `true`   | `--contracts.settlement-chain.wss-url` | `XMTPD_SETTLEMENT_CHAIN_WSS_URL` | The websocket URL of your Blockchain RPC provider's endpoint for the Base chain                    |
| Environment              | `true`   | `--contracts.environment`              | `XMTPD_CONTRACTS_ENVIRONMENT`    | The environment your XMTP Gateway Service will run in. Valid values are `local`, `testnet`, and `mainnet` |
| Enable Redis             | `true`   | `--redis.enable`                       | `XMTPD_REDIS_ENABLE`             | Use Redis for nonce management and rate limiting.                                                  |
| Redis Connection String  | `false`  | `--redis.connection-string`            | `XMTPD_REDIS_CONNECTION_STRING`  | The connection string for your Redis instance                                                      |

{/* TODO:nm: Include all non-required options */}

### Metrics and observability

If the XMTP Gateway Service is configured with the `--metrics.enable` flag, it will expose a [Prometheus](https://prometheus.io) endpoint at `/metrics` on port `8008` which can be ingested by any compatible monitoring system.

## Fund your payer

The private key for your XMTP Gateway Service is an Ethereum account that is expected to be funded in the XMTP Funding Portal.

To learn more, see [Funding your XMTP Gateway Service](fund-apps/quickstart).

## Authenticate users

You can think of the XMTP Gateway Service as an extension of your client app. If you already have a system for authenticating user requests in your app, you should use it in your XMTP Gateway Service. For example, many apps use [JSON Web Tokens](https://jwt.io) (JWTs) to authenticate client requests to servers.

You can use any authentication scheme you like to authenticate requests from your client to the XMTP Gateway Service.

:::tip[IMPORTANT]

Browser and mobile client apps that need user authentication must customize the XMTP Gateway Service to integrate with their authentication system. Node.js apps that need user authentication can use the XMTP Gateway Service provided by the XMTP Node SDK without customization.

:::

### In your client

When creating a XMTP client, you can optionally provide an `payerAuthTokenFetcher` as part of client configuration.

The value returned by this function will be included all client requests to the XMTP Gateway Service. The `fetchAuthToken` function will be called before the first request is made to the XMTP Gateway Service, and after any request to the XMTP Gateway Service fails due to a `PermissionDenied` error.

### Create a `payerAuthTokenFetcher`

A Payer Auth Token Fetcher provides a single function: `fetchAuthToken` that returns a string.

:::code-group

```tsx [Browser]
import type { PayerAuthTokenFetcher } from "@xmtp/browser-sdk";

const authTokenFetcher: PayerAuthTokenFetcher = {
  fetchAuthToken: async () => {
    // Get the auth token from your app somehow
    return "my-auth-token";
  },
};
```

```tsx [Node]
import type { PayerAuthTokenFetcher } from "@xmtp/node-sdk";

const authTokenFetcher: PayerAuthTokenFetcher = {
  fetchAuthToken: async () => {
    return "my-auth-token";
  },
};
```

```tsx [React Native]
import type { PayerAuthTokenFetcher } from "@xmtp/react-native-sdk";

const authTokenFetcher: PayerAuthTokenFetcher = {
  fetchAuthToken: async () => {
    return "my-auth-token";
  },
};
```

```kotlin [Kotlin]
class MyAuthTokenFetcher : PayerAuthTokenFetcher {
    override suspend fun fetchAuthToken(): String {
        return "my-auth-token"
    }
}
```

```swift [Swift]
public struct MyAuthTokenFetcher: PayerAuthTokenFetcher {
    public func fetchAuthToken() async throws -> String {
        return "my-auth-token"
    }
}
```

:::

### In the XMTP Gateway Service

The `PayerServiceBuilder` allows you to provide an `IdentityFn` that you can use to identify your users. The function is expected to return a `payer.Identity` struct, which identifies the user in a way that is unique to your app.

This identity will then be used for rate limiting, and will be passed to your `AuthorizePublishFn` as additional context.

:::code-group

```go [IP Address]
//  We provide a simple implementation that uses the client's IP address to identify users. For a production application, you should limit requests to only users actually authenticated in your application.
payerService, err := payer.NewPayerServiceBuilder(payer.MustLoadConfig()).
	WithIdentityFn(payer.IPIdentityFn).
	Build()
```

```go [JWT]
package main

import (
	"context"
	"errors"
	"log"

	"github.com/golang-jwt/jwt/v5"
	"github.com/xmtp/xmtpd/pkg/payer"
)

const EXPECTED_ISSUER = "my-app.com"

var (
	ErrMissingToken     = errors.New("missing JWT token")
	ErrInvalidToken     = errors.New("invalid JWT token")
	ErrInvalidSignature = errors.New("invalid token signature")
)

// jwtIdentityFn creates an identity function that verifies JWTs
func jwtIdentityFn(publicKey []byte) payer.IdentityFn {
	return func(ctx context.Context) (payer.Identity, error) {
		authHeader := payer.AuthorizationHeaderFromContext(ctx)
		if authHeader == "" {
			return payer.Identity{}, payer.NewUnauthenticatedError(
				"Missing JWT token",
				ErrMissingToken,
			)
		}

		// Parse and verify the token
		token, err := jwt.ParseWithClaims(
			authHeader,
			&jwt.RegisteredClaims{},
			func(token *jwt.Token) (interface{}, error) {
				// Verify signing method
				if _, ok := token.Method.(*jwt.SigningMethodECDSA); !ok {
					return nil, payer.NewPermissionDeniedError(
						"Invalid signing method",
						ErrInvalidSignature,
					)
				}
				return publicKey, nil
			},
			jwt.WithIssuer(EXPECTED_ISSUER),
		)
		if err != nil {
			return payer.Identity{}, payer.NewPermissionDeniedError("failed to validate token", err)
		}

		// Extract claims
		claims, ok := token.Claims.(*jwt.RegisteredClaims)
		if !ok || !token.Valid {
			return payer.Identity{}, payer.NewPermissionDeniedError(
				"failed to validate token",
				ErrInvalidToken,
			)
		}

		userID, err := claims.GetSubject()
		if err != nil {
			return payer.Identity{}, payer.NewPermissionDeniedError(
				"failed to get subject from token",
				err,
			)
		}

		// Return identity based on JWT claims
		return payer.NewUserIdentity(userID), nil
	}
}

func main() {
	// In a real application, this would be a secure key loaded from environment/config
	publicKey := []byte("your-applications-public-key")

	payerService, err := payer.NewPayerServiceBuilder(payer.MustLoadConfig()).
		WithIdentityFn(jwtIdentityFn(publicKey)).
		Build()
	if err != nil {
		log.Fatalf("Failed to build XMTP Gateway Service: %v", err)
	}

	err = payerService.Serve(context.Background())
	if err != nil {
		log.Fatalf("Failed to serve XMTP Gateway Service: %v", err)
	}
}

```

:::

## Authorize requests

Now that you have an identity for the caller of your API, you can use it to authorize requests. We provide some helpers to handle common authorization patterns, such as rate limiting.

You can add multiple authorizers to your XMTP Gateway Service. All authorizers will be called in parallel. The first authorizer (based on the order they are added) that returns `false` or an error will cause the request to be rejected.

:::code-group

```go [IP Allowlist]
package main

import (
	"context"
	"log"
	"slices"

	"github.com/xmtp/xmtpd/pkg/payer"
)

func main() {
	payerService, err := payer.NewPayerServiceBuilder(payer.MustLoadConfig()).
		WithAuthorizers(func(ctx context.Context, identity payer.Identity, req payer.PublishRequest) (bool, error) {
			// A simple authorization function that allows only the IP 127.0.0.1
			allowedIPs := []string{"127.0.0.1"}
			if !slices.Contains(allowedIPs, identity.Identity) {
				return false, payer.ErrUnauthorized
			}
			return true, nil
		}).
		Build() // This will gather all the config from environment variables and flags
	if err != nil {
		log.Fatalf("Failed to build XMTP Gateway Service: %v", err)
	}

	err = payerService.Serve(context.Background())
	if err != nil {
		log.Fatalf("Failed to serve XMTP Gateway Service: %v", err)
	}
}
```

```go [Rate Limiter]
package main

import (
	"context"
	"log"
	"time"

	"github.com/xmtp/xmtpd/pkg/payer"
)

func main() {
	cfg := payer.MustLoadConfig()

	payerService, err := payer.NewPayerServiceBuilder(cfg).
		// Rate limit to allow 50 requests per minute and 10,000 requests per day
		WithAuthorizers(payer.NewRateLimitAuthorizer(cfg, payer.RateLimit{
			MaxRequests: 50,
			Window:      time.Minute,
		}), payer.NewRateLimitAuthorizer(cfg, payer.RateLimit{
			MaxRequests: 10000,
			Window:      time.Hour * 24,
		})).
		Build()
	if err != nil {
		log.Fatalf("Failed to build XMTP Gateway Service: %v", err)
	}

	err = payerService.Serve(context.Background())
	if err != nil {
		log.Fatalf("Failed to serve XMTP Gateway Service: %v", err)
	}
}

```

:::

## Deploy your XMTP Gateway Service

Deploy the XMTP Gateway Service on your infrastructure of choice, such as a container hosting service ($25-50/month minimum).

We provide a Docker image that corresponds to the bare bones example above that you can run with the appropriate environment variables set in any hosting provider that supports Docker.

```bash
docker run -p 5050:5050 -p 5055:5055 -e XMTPD_PAYER_PRIVATE_KEY=... xmtp/payer-service-example:latest
```

Most production apps will require some level of customization to authorize user requests. We provide a sample Dockerfile in the [`examples/docker`](#TODO) directory that you can use as a starting point.

The system is able to run without any external dependencies, but we recommend configuring a Redis instance to use for nonce management and rate limiting.

## Test your XMTP Gateway Service

Here are some high priority scenarios to test:

- [ ]  Deploy and test XMTP Gateway Service (unless using Node.js)
- [ ]  Verify authentication works properly
- [ ]  Test with expected message volumes
- [ ]  Monitor resource usage and costs
- [ ]  Simulate failure scenarios

You can test on Base Sepolia, Appchain testnet, and Broadcast Network testnet. They all run identical contracts so you can dry-run funding and messaging.

To get testnet USDC, use [https://faucet.circle.com/](https://faucet.circle.com/), which provides 10 USDC per hour.

### Testing timeline

**July 29 - October 6**: Testnet-only period

- Use testnet USDC (no real costs)
- Validate XMTP Gateway Service setup
- Test authentication flows
- Ensure infrastructure scales

**October 7+**: Full mainnet testing

- Funding Portal accepts real USDC
- Production environment testing
- Cost validation with real funds
- Final integration checks

## XMTP Gateway Service flows

The following sequence diagrams illustrate the XMTP Gateway Service's role in the following key flows.

### Flow for sending a message to the XMTP Network

<Mermaid
  id="xmtp-network-flow"
  chart={`
sequenceDiagram
    title: Message sent to XMTP Network
    participant App
    participant Gateway Service
    participant XMTP Network

    App->>Gateway Service: Request to send message
    Gateway Service->>Gateway Service: Verify user authorization
    Gateway Service->>Gateway Service: Sign with payer wallet key
    Gateway Service->>XMTP Network: Send message and pay network message fees
    alt Sufficient funds in PayerRegistry
        XMTP Network-->>App: Message sent
    else Insufficient funds in PayerRegistry
        XMTP Network-->>App: Message not sent
    end
`} />

### Flow for sending a message to the XMTP Appchain

<Mermaid
  id="xmtp-appchain-flow"
  chart={`
sequenceDiagram
    title: Message sent to XMTP Appchain
    participant App
    participant Gateway Service
    participant XMTP Appchain

    App->>Gateway Service: Request to send message
    Gateway Service->>Gateway Service: Verify user authorization
    Gateway Service->>Gateway Service: Sign with payer wallet key
    Gateway Service->>XMTP Appchain: Send message and pay Appchain gas fee
    alt Sufficient funds
        XMTP Appchain-->>App: Message sent
    else Insufficient funds
        XMTP Appchain-->>App: Message not sent
    end
`} />
