# Group chat

Build agents that manage group conversations with permission control and member management.

## Permission system

XMTP groups use a three-tier permission system:

**Member roles:**
- **Member**: Basic participant  
- **Admin**: Elevated permissions for moderation
- **Super Admin**: Full group control

**Permission policies:**
- **Allow**: All members can perform action
- **Admin**: Admins and super admins only
- **Super Admin**: Super admins only

**Default permissions:**
- Add members: Allow
- Remove members: Admin  
- Manage admins: Super Admin
- Update metadata: Allow

## Creating groups

```typescript
import { Agent, PermissionPolicy } from "@xmtp/agent-sdk";

// Default open group
const group = await client.conversations.newGroup([inboxId1, inboxId2], {
  groupName: "My Agent Group",
  groupDescription: "A group managed by my agent",
});

// Admin-controlled group
const adminGroup = await client.conversations.newGroup(memberInboxIds, {
  groupName: "Admin Controlled",
  permissions: {
    addMember: PermissionPolicy.Admin,
    removeMember: PermissionPolicy.Admin,
    updateMetadata: PermissionPolicy.Admin,
  }
});
```

## Group management

```typescript
agent.on("text", async (ctx) => {
  const message = ctx.message.content;
  const senderAddress = ctx.getSenderAddress();
  const isSuperAdmin = ctx.conversation.isSuperAdmin(senderAddress);
  const isAdmin = ctx.conversation.isAdmin(senderAddress);
  
  // Member management (admin required)
  if (message.startsWith("/add ") && isAdmin) {
    const newMemberAddress = message.split(" ")[1];
    await ctx.conversation.addMembers([newMemberAddress]);
    await ctx.conversation.send(`Added ${newMemberAddress} to the group!`);
  }
  
  if (message.startsWith("/remove ") && isAdmin) {
    const memberToRemove = message.split(" ")[1];
    await ctx.conversation.removeMembers([memberToRemove]);
    await ctx.conversation.send(`Removed ${memberToRemove} from the group.`);
  }
  
  // Admin management (super admin required)
  if (message.startsWith("/promote ") && isSuperAdmin) {
    const targetAddress = message.split(" ")[1];
    await ctx.conversation.addAdmin(targetAddress);
    await ctx.conversation.send(`Promoted ${targetAddress} to admin!`);
  }
  
  if (message.startsWith("/demote ") && isSuperAdmin) {
    const targetAddress = message.split(" ")[1];
    await ctx.conversation.removeAdmin(targetAddress);
    await ctx.conversation.send(`Demoted ${targetAddress} from admin.`);
  }
});
```

## Group information

```typescript
// Get group info
if (ctx.message.content === "/info") {
  const members = await ctx.conversation.members();
  const info = `**${ctx.conversation.name}**\nMembers: ${members.length}\nAdmins: ${ctx.conversation.admins.length}`;
  await ctx.conversation.send(info);
}

// List members with roles
if (ctx.message.content === "/members") {
  const members = await ctx.conversation.members();
  let memberList = "**Members:**\n";
  
  for (const member of members.slice(0, 10)) {
    const role = ctx.conversation.isSuperAdmin(member.inboxId) ? "👑" :
                 ctx.conversation.isAdmin(member.inboxId) ? "🛡️" : "👤";
    memberList += `${role} ${member.inboxId}\n`;
  }
  
  await ctx.conversation.send(memberList);
}
```

## Group metadata

```typescript
// Update group name (admin required)
if (ctx.message.content.startsWith("/name ") && ctx.conversation.isAdmin(ctx.getSenderAddress())) {
  const newName = ctx.message.content.substring(6);
  await ctx.conversation.updateName(newName);
  await ctx.conversation.send(`Group name updated to: ${newName}`);
}

// Update group description
if (ctx.message.content.startsWith("/desc ") && ctx.conversation.isAdmin(ctx.getSenderAddress())) {
  const newDesc = ctx.message.content.substring(6);
  await ctx.conversation.updateDescription(newDesc);
  await ctx.sendText("Group description updated!");
}

// Update group image
await ctx.conversation.updateImageUrl("https://example.com/image.jpg");
```

## Working with members

```typescript
// Get all members
const members = await group.members();

// Find member by inbox ID
const member = members.find(m => m.inboxId === targetInboxId);

// Get member's Ethereum address
const ethIdentifier = member?.accountIdentifiers.find(
  id => id.identifierKind === IdentifierKind.Ethereum
);

// Add member by Ethereum address
const dm = await client.conversations.newDmWithIdentifier({
  identifier: "0x7c40611372d354799d138542e77243c284e460b2",
  identifierKind: IdentifierKind.Ethereum,
});
await group.addMembers([dm.peerInboxId]);
```

## Error handling

```typescript
// Simple error handling for group operations
try {
  await ctx.conversation.addMembers([newMemberAddress]);
  await ctx.conversation.send(`Added ${newMemberAddress} to the group!`);
} catch (error) {
  await ctx.sendText("Failed to add member. Check permissions and address format.");
}
```
